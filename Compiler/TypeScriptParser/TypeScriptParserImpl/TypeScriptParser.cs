//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 TypeScript.g3 2016-05-06 13:05:54

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

 #pragma warning disable 219, 162 

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  Xebic.Parsers.ES3 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class TypeScriptParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ABSTRACT", "ADD", "ADDASS", "AMBIENTFUNCTION", "AND", "ANDASS", "ANY", "ARGS", "ARRAY", "ARRAY_TYPE", "ARROW", "ASSIGN", "AWAIT", "BLOCK", "BOOLEAN", "BREAK", "BSLASH", "BYFIELD", "BYINDEX", "BYTE", "BackslashSequence", "CALL", "CALL_SIG", "CASE", "CATCH", "CEXPR", "CHAR", "CLASS", "COLON", "COMMA", "CONST", "CONSTRUCTOR", "CONST_DECL", "CONST_SIG", "CONST_TYPE", "CONTINUE", "CR", "CharacterEscapeSequence", "DEC", "DECLARE", "DEFAULT", "DELETE", "DIV", "DIVASS", "DO", "DOT", "DOUBLE", "DQUOTE", "DecimalDigit", "DecimalIntegerLiteral", "DecimalLiteral", "ELLIPSIS", "ELSE", "ENUM", "EOL", "EQ", "EXPORT", "EXPR", "EXTENDS", "EscapeSequence", "ExponentPart", "FALSE", "FF", "FINAL", "FINALLY", "FLOAT", "FOR", "FORITER", "FORSTEP", "FUNCTION", "FUNCTIONDECLARATION", "FUNCTION_TYPE", "FUNC_TYPE", "GET", "GOTO", "GT", "GTE", "HexDigit", "HexEscapeSequence", "HexIntegerLiteral", "IF", "IMPLEMENTS", "IMPORT", "IN", "INC", "INDEX", "INDEX_SIG", "INSTANCEOF", "INT", "INTERFACE", "INV", "ITEM", "Identifier", "IdentifierNameASCIIStart", "IdentifierPart", "IdentifierStartASCII", "LABELLED", "LAND", "LBRACE", "LBRACK", "LF", "LONG", "LOR", "LPAREN", "LS", "LT", "LTE", "LineTerminator", "METH_DECL", "METH_SIG", "MOD", "MODASS", "MODULE", "MUL", "MULASS", "MultiLineComment", "NAMEDVALUE", "NATIVE", "NBSP", "NEG", "NEQ", "NEW", "NOT", "NSAME", "NULL", "NUMBER", "OBJECT", "OBJECT_TYPE", "OR", "ORASS", "OctalDigit", "OctalEscapeSequence", "OctalIntegerLiteral", "PACKAGE", "PARAM", "PARAMS", "PARAM_ARRAY", "PARAM_OPT", "PAREXPR", "PDEC", "PINC", "POS", "PRIVATE", "PROP_SIG", "PROTECTED", "PS", "PUBLIC", "QUE", "RBRACE", "RBRACK", "REQUIRE", "RETURN", "RPAREN", "RegularExpressionChar", "RegularExpressionFirstChar", "RegularExpressionLiteral", "SAME", "SEMIC", "SET", "SHL", "SHLASS", "SHORT", "SHR", "SHRASS", "SHU", "SHUASS", "SP", "SQUOTE", "STATIC", "STRING", "SUB", "SUBASS", "SUPER", "SWITCH", "SYNCHRONIZED", "SingleLineComment", "StringLiteral", "TAB", "THIS", "THROW", "THROWS", "TRANSIENT", "TRUE", "TRY", "TUPLE_TYPE", "TYPE", "TYPEOF", "TYPEREF", "TYPE_ARGS", "TYPE_PARAMS", "USP", "UnicodeEscapeSequence", "VAR", "VAR_OPT", "VOID", "VOLATILE", "VT", "WHILE", "WITH", "WhiteSpace", "XOR", "XORASS", "YIELD", "ZeroToThree"
	};
	public const int EOF=-1;
	public const int ABSTRACT=4;
	public const int ADD=5;
	public const int ADDASS=6;
	public const int AMBIENTFUNCTION=7;
	public const int AND=8;
	public const int ANDASS=9;
	public const int ANY=10;
	public const int ARGS=11;
	public const int ARRAY=12;
	public const int ARRAY_TYPE=13;
	public const int ARROW=14;
	public const int ASSIGN=15;
	public const int AWAIT=16;
	public const int BLOCK=17;
	public const int BOOLEAN=18;
	public const int BREAK=19;
	public const int BSLASH=20;
	public const int BYFIELD=21;
	public const int BYINDEX=22;
	public const int BYTE=23;
	public const int BackslashSequence=24;
	public const int CALL=25;
	public const int CALL_SIG=26;
	public const int CASE=27;
	public const int CATCH=28;
	public const int CEXPR=29;
	public const int CHAR=30;
	public const int CLASS=31;
	public const int COLON=32;
	public const int COMMA=33;
	public const int CONST=34;
	public const int CONSTRUCTOR=35;
	public const int CONST_DECL=36;
	public const int CONST_SIG=37;
	public const int CONST_TYPE=38;
	public const int CONTINUE=39;
	public const int CR=40;
	public const int CharacterEscapeSequence=41;
	public const int DEC=42;
	public const int DECLARE=43;
	public const int DEFAULT=44;
	public const int DELETE=45;
	public const int DIV=46;
	public const int DIVASS=47;
	public const int DO=48;
	public const int DOT=49;
	public const int DOUBLE=50;
	public const int DQUOTE=51;
	public const int DecimalDigit=52;
	public const int DecimalIntegerLiteral=53;
	public const int DecimalLiteral=54;
	public const int ELLIPSIS=55;
	public const int ELSE=56;
	public const int ENUM=57;
	public const int EOL=58;
	public const int EQ=59;
	public const int EXPORT=60;
	public const int EXPR=61;
	public const int EXTENDS=62;
	public const int EscapeSequence=63;
	public const int ExponentPart=64;
	public const int FALSE=65;
	public const int FF=66;
	public const int FINAL=67;
	public const int FINALLY=68;
	public const int FLOAT=69;
	public const int FOR=70;
	public const int FORITER=71;
	public const int FORSTEP=72;
	public const int FUNCTION=73;
	public const int FUNCTIONDECLARATION=74;
	public const int FUNCTION_TYPE=75;
	public const int FUNC_TYPE=76;
	public const int GET=77;
	public const int GOTO=78;
	public const int GT=79;
	public const int GTE=80;
	public const int HexDigit=81;
	public const int HexEscapeSequence=82;
	public const int HexIntegerLiteral=83;
	public const int IF=84;
	public const int IMPLEMENTS=85;
	public const int IMPORT=86;
	public const int IN=87;
	public const int INC=88;
	public const int INDEX=89;
	public const int INDEX_SIG=90;
	public const int INSTANCEOF=91;
	public const int INT=92;
	public const int INTERFACE=93;
	public const int INV=94;
	public const int ITEM=95;
	public const int Identifier=96;
	public const int IdentifierNameASCIIStart=97;
	public const int IdentifierPart=98;
	public const int IdentifierStartASCII=99;
	public const int LABELLED=100;
	public const int LAND=101;
	public const int LBRACE=102;
	public const int LBRACK=103;
	public const int LF=104;
	public const int LONG=105;
	public const int LOR=106;
	public const int LPAREN=107;
	public const int LS=108;
	public const int LT=109;
	public const int LTE=110;
	public const int LineTerminator=111;
	public const int METH_DECL=112;
	public const int METH_SIG=113;
	public const int MOD=114;
	public const int MODASS=115;
	public const int MODULE=116;
	public const int MUL=117;
	public const int MULASS=118;
	public const int MultiLineComment=119;
	public const int NAMEDVALUE=120;
	public const int NATIVE=121;
	public const int NBSP=122;
	public const int NEG=123;
	public const int NEQ=124;
	public const int NEW=125;
	public const int NOT=126;
	public const int NSAME=127;
	public const int NULL=128;
	public const int NUMBER=129;
	public const int OBJECT=130;
	public const int OBJECT_TYPE=131;
	public const int OR=132;
	public const int ORASS=133;
	public const int OctalDigit=134;
	public const int OctalEscapeSequence=135;
	public const int OctalIntegerLiteral=136;
	public const int PACKAGE=137;
	public const int PARAM=138;
	public const int PARAMS=139;
	public const int PARAM_ARRAY=140;
	public const int PARAM_OPT=141;
	public const int PAREXPR=142;
	public const int PDEC=143;
	public const int PINC=144;
	public const int POS=145;
	public const int PRIVATE=146;
	public const int PROP_SIG=147;
	public const int PROTECTED=148;
	public const int PS=149;
	public const int PUBLIC=150;
	public const int QUE=151;
	public const int RBRACE=152;
	public const int RBRACK=153;
	public const int REQUIRE=154;
	public const int RETURN=155;
	public const int RPAREN=156;
	public const int RegularExpressionChar=157;
	public const int RegularExpressionFirstChar=158;
	public const int RegularExpressionLiteral=159;
	public const int SAME=160;
	public const int SEMIC=161;
	public const int SET=162;
	public const int SHL=163;
	public const int SHLASS=164;
	public const int SHORT=165;
	public const int SHR=166;
	public const int SHRASS=167;
	public const int SHU=168;
	public const int SHUASS=169;
	public const int SP=170;
	public const int SQUOTE=171;
	public const int STATIC=172;
	public const int STRING=173;
	public const int SUB=174;
	public const int SUBASS=175;
	public const int SUPER=176;
	public const int SWITCH=177;
	public const int SYNCHRONIZED=178;
	public const int SingleLineComment=179;
	public const int StringLiteral=180;
	public const int TAB=181;
	public const int THIS=182;
	public const int THROW=183;
	public const int THROWS=184;
	public const int TRANSIENT=185;
	public const int TRUE=186;
	public const int TRY=187;
	public const int TUPLE_TYPE=188;
	public const int TYPE=189;
	public const int TYPEOF=190;
	public const int TYPEREF=191;
	public const int TYPE_ARGS=192;
	public const int TYPE_PARAMS=193;
	public const int USP=194;
	public const int UnicodeEscapeSequence=195;
	public const int VAR=196;
	public const int VAR_OPT=197;
	public const int VOID=198;
	public const int VOLATILE=199;
	public const int VT=200;
	public const int WHILE=201;
	public const int WITH=202;
	public const int WhiteSpace=203;
	public const int XOR=204;
	public const int XORASS=205;
	public const int YIELD=206;
	public const int ZeroToThree=207;

	public TypeScriptParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public TypeScriptParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return TypeScriptParser.tokenNames; } }
	public override string GrammarFileName { get { return "TypeScript.g3"; } }


		public override void ReportError(RecognitionException e) { throw e; }



	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_token();
	partial void LeaveRule_token();
	// $ANTLR start "token"
	// TypeScript.g3:318:1: token : ( reservedWord | identifierAllowedKeyword | identifier | punctuator | numericLiteral | StringLiteral );
	[GrammarRule("token")]
	private AstParserRuleReturnScope<object, IToken> token()
	{
		EnterRule_token();
		EnterRule("token", 1);
		TraceIn("token", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken StringLiteral6 = default(IToken);
		AstParserRuleReturnScope<object, IToken> reservedWord1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> identifierAllowedKeyword2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> identifier3 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> punctuator4 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> numericLiteral5 = default(AstParserRuleReturnScope<object, IToken>);

		object StringLiteral6_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "token");
		DebugLocation(318, 1);
		try
		{
			// TypeScript.g3:319:2: ( reservedWord | identifierAllowedKeyword | identifier | punctuator | numericLiteral | StringLiteral )
			int alt1=6;
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case BREAK:
			case CASE:
			case CATCH:
			case CONTINUE:
			case DEFAULT:
			case DELETE:
			case DO:
			case ELSE:
			case FINALLY:
			case FOR:
			case FUNCTION:
			case IF:
			case IN:
			case INSTANCEOF:
			case NEW:
			case RETURN:
			case SWITCH:
			case THIS:
			case THROW:
			case TRY:
			case TYPEOF:
			case VAR:
			case VOID:
			case WHILE:
			case WITH:
				{
				alt1 = 1;
				}
				break;
			case ABSTRACT:
			case BOOLEAN:
			case BYTE:
			case CHAR:
			case CLASS:
			case CONST:
			case DOUBLE:
			case ENUM:
			case EXTENDS:
			case FALSE:
			case FINAL:
			case FLOAT:
			case GOTO:
			case IMPLEMENTS:
			case IMPORT:
			case INT:
			case INTERFACE:
			case LONG:
			case NATIVE:
			case NULL:
			case PACKAGE:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case SHORT:
			case STATIC:
			case SUPER:
			case SYNCHRONIZED:
			case THROWS:
			case TRANSIENT:
			case TRUE:
			case VOLATILE:
				{
				alt1 = 1;
				}
				break;
			case ANY:
			case CONSTRUCTOR:
			case DECLARE:
			case GET:
			case MODULE:
			case NUMBER:
			case REQUIRE:
			case SET:
			case STRING:
			case TYPE:
				{
				alt1 = 2;
				}
				break;
			case Identifier:
				{
				alt1 = 3;
				}
				break;
			case ADD:
			case ADDASS:
			case AND:
			case ANDASS:
			case ASSIGN:
			case COLON:
			case COMMA:
			case DEC:
			case DIV:
			case DIVASS:
			case DOT:
			case EQ:
			case GT:
			case GTE:
			case INC:
			case INV:
			case LAND:
			case LBRACE:
			case LBRACK:
			case LOR:
			case LPAREN:
			case LT:
			case LTE:
			case MOD:
			case MODASS:
			case MUL:
			case MULASS:
			case NEQ:
			case NOT:
			case NSAME:
			case OR:
			case ORASS:
			case QUE:
			case RBRACE:
			case RBRACK:
			case RPAREN:
			case SAME:
			case SEMIC:
			case SHL:
			case SHLASS:
			case SHR:
			case SHRASS:
			case SHU:
			case SHUASS:
			case SUB:
			case SUBASS:
			case XOR:
			case XORASS:
				{
				alt1 = 4;
				}
				break;
			case DecimalLiteral:
			case HexIntegerLiteral:
			case OctalIntegerLiteral:
				{
				alt1 = 5;
				}
				break;
			case StringLiteral:
				{
				alt1 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:319:4: reservedWord
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(319, 4);
				PushFollow(Follow._reservedWord_in_token2943);
				reservedWord1=reservedWord();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, reservedWord1.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:320:4: identifierAllowedKeyword
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(320, 4);
				PushFollow(Follow._identifierAllowedKeyword_in_token2948);
				identifierAllowedKeyword2=identifierAllowedKeyword();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifierAllowedKeyword2.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:321:4: identifier
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(321, 4);
				PushFollow(Follow._identifier_in_token2953);
				identifier3=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifier3.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:322:4: punctuator
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(322, 4);
				PushFollow(Follow._punctuator_in_token2958);
				punctuator4=punctuator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, punctuator4.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:323:4: numericLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(323, 4);
				PushFollow(Follow._numericLiteral_in_token2963);
				numericLiteral5=numericLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, numericLiteral5.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScript.g3:324:4: StringLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(324, 4);
				StringLiteral6=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_token2968); if (state.failed) return retval;
				if (state.backtracking == 0) {
				StringLiteral6_tree = (object)adaptor.Create(StringLiteral6);
				adaptor.AddChild(root_0, StringLiteral6_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("token", 1);
			LeaveRule("token", 1);
			LeaveRule_token();
		}
		DebugLocation(325, 1);
		} finally { DebugExitRule(GrammarFileName, "token"); }
		return retval;

	}
	// $ANTLR end "token"

	partial void EnterRule_reservedWord();
	partial void LeaveRule_reservedWord();
	// $ANTLR start "reservedWord"
	// TypeScript.g3:329:1: reservedWord : ( keyword | futureReservedWord | NULL | booleanLiteral );
	[GrammarRule("reservedWord")]
	private AstParserRuleReturnScope<object, IToken> reservedWord()
	{
		EnterRule_reservedWord();
		EnterRule("reservedWord", 2);
		TraceIn("reservedWord", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NULL9 = default(IToken);
		AstParserRuleReturnScope<object, IToken> keyword7 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> futureReservedWord8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> booleanLiteral10 = default(AstParserRuleReturnScope<object, IToken>);

		object NULL9_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "reservedWord");
		DebugLocation(329, 1);
		try
		{
			// TypeScript.g3:330:2: ( keyword | futureReservedWord | NULL | booleanLiteral )
			int alt2=4;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case BREAK:
			case CASE:
			case CATCH:
			case CONTINUE:
			case DEFAULT:
			case DELETE:
			case DO:
			case ELSE:
			case FINALLY:
			case FOR:
			case FUNCTION:
			case IF:
			case IN:
			case INSTANCEOF:
			case NEW:
			case RETURN:
			case SWITCH:
			case THIS:
			case THROW:
			case TRY:
			case TYPEOF:
			case VAR:
			case VOID:
			case WHILE:
			case WITH:
				{
				alt2 = 1;
				}
				break;
			case ABSTRACT:
			case BOOLEAN:
			case BYTE:
			case CHAR:
			case CLASS:
			case CONST:
			case DOUBLE:
			case ENUM:
			case EXTENDS:
			case FINAL:
			case FLOAT:
			case GOTO:
			case IMPLEMENTS:
			case IMPORT:
			case INT:
			case INTERFACE:
			case LONG:
			case NATIVE:
			case PACKAGE:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case SHORT:
			case STATIC:
			case SUPER:
			case SYNCHRONIZED:
			case THROWS:
			case TRANSIENT:
			case VOLATILE:
				{
				alt2 = 2;
				}
				break;
			case NULL:
				{
				alt2 = 3;
				}
				break;
			case FALSE:
			case TRUE:
				{
				alt2 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:330:4: keyword
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(330, 4);
				PushFollow(Follow._keyword_in_reservedWord2981);
				keyword7=keyword();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, keyword7.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:331:4: futureReservedWord
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(331, 4);
				PushFollow(Follow._futureReservedWord_in_reservedWord2986);
				futureReservedWord8=futureReservedWord();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, futureReservedWord8.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:332:4: NULL
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(332, 4);
				NULL9=(IToken)Match(input,NULL,Follow._NULL_in_reservedWord2991); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NULL9_tree = (object)adaptor.Create(NULL9);
				adaptor.AddChild(root_0, NULL9_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:333:4: booleanLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(333, 4);
				PushFollow(Follow._booleanLiteral_in_reservedWord2996);
				booleanLiteral10=booleanLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, booleanLiteral10.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("reservedWord", 2);
			LeaveRule("reservedWord", 2);
			LeaveRule_reservedWord();
		}
		DebugLocation(334, 1);
		} finally { DebugExitRule(GrammarFileName, "reservedWord"); }
		return retval;

	}
	// $ANTLR end "reservedWord"

	partial void EnterRule_keyword();
	partial void LeaveRule_keyword();
	// $ANTLR start "keyword"
	// TypeScript.g3:340:1: keyword : ( BREAK | CASE | CATCH | CONTINUE | DEFAULT | DELETE | DO | ELSE | FINALLY | FOR | FUNCTION | IF | IN | INSTANCEOF | NEW | RETURN | SWITCH | THIS | THROW | TRY | TYPEOF | VAR | VOID | WHILE | WITH );
	[GrammarRule("keyword")]
	private AstParserRuleReturnScope<object, IToken> keyword()
	{
		EnterRule_keyword();
		EnterRule("keyword", 3);
		TraceIn("keyword", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set11 = default(IToken);

		object set11_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "keyword");
		DebugLocation(340, 1);
		try
		{
			// TypeScript.g3:341:2: ( BREAK | CASE | CATCH | CONTINUE | DEFAULT | DELETE | DO | ELSE | FINALLY | FOR | FUNCTION | IF | IN | INSTANCEOF | NEW | RETURN | SWITCH | THIS | THROW | TRY | TYPEOF | VAR | VOID | WHILE | WITH )
			DebugEnterAlt(1);
			// TypeScript.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(341, 2);

			set11=(IToken)input.LT(1);
			if (input.LA(1)==BREAK||(input.LA(1)>=CASE && input.LA(1)<=CATCH)||input.LA(1)==CONTINUE||(input.LA(1)>=DEFAULT && input.LA(1)<=DELETE)||input.LA(1)==DO||input.LA(1)==ELSE||input.LA(1)==FINALLY||input.LA(1)==FOR||input.LA(1)==FUNCTION||input.LA(1)==IF||input.LA(1)==IN||input.LA(1)==INSTANCEOF||input.LA(1)==NEW||input.LA(1)==RETURN||input.LA(1)==SWITCH||(input.LA(1)>=THIS && input.LA(1)<=THROW)||input.LA(1)==TRY||input.LA(1)==TYPEOF||input.LA(1)==VAR||input.LA(1)==VOID||(input.LA(1)>=WHILE && input.LA(1)<=WITH))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set11));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("keyword", 3);
			LeaveRule("keyword", 3);
			LeaveRule_keyword();
		}
		DebugLocation(366, 1);
		} finally { DebugExitRule(GrammarFileName, "keyword"); }
		return retval;

	}
	// $ANTLR end "keyword"

	partial void EnterRule_futureReservedWord();
	partial void LeaveRule_futureReservedWord();
	// $ANTLR start "futureReservedWord"
	// TypeScript.g3:372:1: futureReservedWord : ( ABSTRACT | BOOLEAN | BYTE | CHAR | CLASS | CONST | DOUBLE | ENUM | EXTENDS | FINAL | FLOAT | GOTO | IMPLEMENTS | IMPORT | INT | INTERFACE | LONG | NATIVE | PACKAGE | PRIVATE | PROTECTED | PUBLIC | SHORT | STATIC | SUPER | SYNCHRONIZED | THROWS | TRANSIENT | VOLATILE );
	[GrammarRule("futureReservedWord")]
	private AstParserRuleReturnScope<object, IToken> futureReservedWord()
	{
		EnterRule_futureReservedWord();
		EnterRule("futureReservedWord", 4);
		TraceIn("futureReservedWord", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set12 = default(IToken);

		object set12_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "futureReservedWord");
		DebugLocation(372, 1);
		try
		{
			// TypeScript.g3:373:2: ( ABSTRACT | BOOLEAN | BYTE | CHAR | CLASS | CONST | DOUBLE | ENUM | EXTENDS | FINAL | FLOAT | GOTO | IMPLEMENTS | IMPORT | INT | INTERFACE | LONG | NATIVE | PACKAGE | PRIVATE | PROTECTED | PUBLIC | SHORT | STATIC | SUPER | SYNCHRONIZED | THROWS | TRANSIENT | VOLATILE )
			DebugEnterAlt(1);
			// TypeScript.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(373, 2);

			set12=(IToken)input.LT(1);
			if (input.LA(1)==ABSTRACT||input.LA(1)==BOOLEAN||input.LA(1)==BYTE||(input.LA(1)>=CHAR && input.LA(1)<=CLASS)||input.LA(1)==CONST||input.LA(1)==DOUBLE||input.LA(1)==ENUM||input.LA(1)==EXTENDS||input.LA(1)==FINAL||input.LA(1)==FLOAT||input.LA(1)==GOTO||(input.LA(1)>=IMPLEMENTS && input.LA(1)<=IMPORT)||(input.LA(1)>=INT && input.LA(1)<=INTERFACE)||input.LA(1)==LONG||input.LA(1)==NATIVE||input.LA(1)==PACKAGE||input.LA(1)==PRIVATE||input.LA(1)==PROTECTED||input.LA(1)==PUBLIC||input.LA(1)==SHORT||input.LA(1)==STATIC||input.LA(1)==SUPER||input.LA(1)==SYNCHRONIZED||(input.LA(1)>=THROWS && input.LA(1)<=TRANSIENT)||input.LA(1)==VOLATILE)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set12));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("futureReservedWord", 4);
			LeaveRule("futureReservedWord", 4);
			LeaveRule_futureReservedWord();
		}
		DebugLocation(403, 1);
		} finally { DebugExitRule(GrammarFileName, "futureReservedWord"); }
		return retval;

	}
	// $ANTLR end "futureReservedWord"

	partial void EnterRule_identifierAllowedKeyword();
	partial void LeaveRule_identifierAllowedKeyword();
	// $ANTLR start "identifierAllowedKeyword"
	// TypeScript.g3:434:1: identifierAllowedKeyword : ( ANY | CONSTRUCTOR | DECLARE | GET | SET | MODULE | REQUIRE | NUMBER | STRING | TYPE | FINAL | THROWS );
	[GrammarRule("identifierAllowedKeyword")]
	private AstParserRuleReturnScope<object, IToken> identifierAllowedKeyword()
	{
		EnterRule_identifierAllowedKeyword();
		EnterRule("identifierAllowedKeyword", 5);
		TraceIn("identifierAllowedKeyword", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set13 = default(IToken);

		object set13_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "identifierAllowedKeyword");
		DebugLocation(434, 4);
		try
		{
			// TypeScript.g3:435:5: ( ANY | CONSTRUCTOR | DECLARE | GET | SET | MODULE | REQUIRE | NUMBER | STRING | TYPE | FINAL | THROWS )
			DebugEnterAlt(1);
			// TypeScript.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(435, 5);

			set13=(IToken)input.LT(1);
			if (input.LA(1)==ANY||input.LA(1)==CONSTRUCTOR||input.LA(1)==DECLARE||input.LA(1)==FINAL||input.LA(1)==GET||input.LA(1)==MODULE||input.LA(1)==NUMBER||input.LA(1)==REQUIRE||input.LA(1)==SET||input.LA(1)==STRING||input.LA(1)==THROWS||input.LA(1)==TYPE)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set13));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifierAllowedKeyword", 5);
			LeaveRule("identifierAllowedKeyword", 5);
			LeaveRule_identifierAllowedKeyword();
		}
		DebugLocation(447, 4);
		} finally { DebugExitRule(GrammarFileName, "identifierAllowedKeyword"); }
		return retval;

	}
	// $ANTLR end "identifierAllowedKeyword"

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();
	// $ANTLR start "identifier"
	// TypeScript.g3:463:1: identifier : ( identifierAllowedKeyword | Identifier );
	[GrammarRule("identifier")]
	private AstParserRuleReturnScope<object, IToken> identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 6);
		TraceIn("identifier", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken Identifier15 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifierAllowedKeyword14 = default(AstParserRuleReturnScope<object, IToken>);

		object Identifier15_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(463, 4);
		try
		{
			// TypeScript.g3:464:5: ( identifierAllowedKeyword | Identifier )
			int alt3=2;
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==ANY||LA3_1==CONSTRUCTOR||LA3_1==DECLARE||LA3_1==FINAL||LA3_1==GET||LA3_1==MODULE||LA3_1==NUMBER||LA3_1==REQUIRE||LA3_1==SET||LA3_1==STRING||LA3_1==THROWS||LA3_1==TYPE))
			{
				alt3 = 1;
			}
			else if ((LA3_1==Identifier))
			{
				alt3 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:464:7: identifierAllowedKeyword
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(464, 7);
				PushFollow(Follow._identifierAllowedKeyword_in_identifier3532);
				identifierAllowedKeyword14=identifierAllowedKeyword();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifierAllowedKeyword14.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:465:7: Identifier
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(465, 7);
				Identifier15=(IToken)Match(input,Identifier,Follow._Identifier_in_identifier3540); if (state.failed) return retval;
				if (state.backtracking == 0) {
				Identifier15_tree = (object)adaptor.Create(Identifier15);
				adaptor.AddChild(root_0, Identifier15_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifier", 6);
			LeaveRule("identifier", 6);
			LeaveRule_identifier();
		}
		DebugLocation(466, 4);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return retval;

	}
	// $ANTLR end "identifier"

	partial void EnterRule_punctuator();
	partial void LeaveRule_punctuator();
	// $ANTLR start "punctuator"
	// TypeScript.g3:472:1: punctuator : ( LBRACE | RBRACE | LPAREN | RPAREN | LBRACK | RBRACK | DOT | SEMIC | COMMA | LT | GT | LTE | GTE | EQ | NEQ | SAME | NSAME | ADD | SUB | MUL | MOD | INC | DEC | SHL | SHR | SHU | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | ADDASS | SUBASS | MULASS | MODASS | SHLASS | SHRASS | SHUASS | ANDASS | ORASS | XORASS | DIV | DIVASS );
	[GrammarRule("punctuator")]
	private AstParserRuleReturnScope<object, IToken> punctuator()
	{
		EnterRule_punctuator();
		EnterRule("punctuator", 7);
		TraceIn("punctuator", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set16 = default(IToken);

		object set16_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "punctuator");
		DebugLocation(472, 1);
		try
		{
			// TypeScript.g3:473:2: ( LBRACE | RBRACE | LPAREN | RPAREN | LBRACK | RBRACK | DOT | SEMIC | COMMA | LT | GT | LTE | GTE | EQ | NEQ | SAME | NSAME | ADD | SUB | MUL | MOD | INC | DEC | SHL | SHR | SHU | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | ADDASS | SUBASS | MULASS | MODASS | SHLASS | SHRASS | SHUASS | ANDASS | ORASS | XORASS | DIV | DIVASS )
			DebugEnterAlt(1);
			// TypeScript.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(473, 2);

			set16=(IToken)input.LT(1);
			if ((input.LA(1)>=ADD && input.LA(1)<=ADDASS)||(input.LA(1)>=AND && input.LA(1)<=ANDASS)||input.LA(1)==ASSIGN||(input.LA(1)>=COLON && input.LA(1)<=COMMA)||input.LA(1)==DEC||(input.LA(1)>=DIV && input.LA(1)<=DIVASS)||input.LA(1)==DOT||input.LA(1)==EQ||(input.LA(1)>=GT && input.LA(1)<=GTE)||input.LA(1)==INC||input.LA(1)==INV||(input.LA(1)>=LAND && input.LA(1)<=LBRACK)||(input.LA(1)>=LOR && input.LA(1)<=LPAREN)||(input.LA(1)>=LT && input.LA(1)<=LTE)||(input.LA(1)>=MOD && input.LA(1)<=MODASS)||(input.LA(1)>=MUL && input.LA(1)<=MULASS)||input.LA(1)==NEQ||(input.LA(1)>=NOT && input.LA(1)<=NSAME)||(input.LA(1)>=OR && input.LA(1)<=ORASS)||(input.LA(1)>=QUE && input.LA(1)<=RBRACK)||input.LA(1)==RPAREN||(input.LA(1)>=SAME && input.LA(1)<=SEMIC)||(input.LA(1)>=SHL && input.LA(1)<=SHLASS)||(input.LA(1)>=SHR && input.LA(1)<=SHUASS)||(input.LA(1)>=SUB && input.LA(1)<=SUBASS)||(input.LA(1)>=XOR && input.LA(1)<=XORASS))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set16));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("punctuator", 7);
			LeaveRule("punctuator", 7);
			LeaveRule_punctuator();
		}
		DebugLocation(521, 1);
		} finally { DebugExitRule(GrammarFileName, "punctuator"); }
		return retval;

	}
	// $ANTLR end "punctuator"

	partial void EnterRule_literal();
	partial void LeaveRule_literal();
	// $ANTLR start "literal"
	// TypeScript.g3:527:1: literal : ( NULL | booleanLiteral | numericLiteral | StringLiteral | RegularExpressionLiteral );
	[GrammarRule("literal")]
	private AstParserRuleReturnScope<object, IToken> literal()
	{
		EnterRule_literal();
		EnterRule("literal", 8);
		TraceIn("literal", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NULL17 = default(IToken);
		IToken StringLiteral20 = default(IToken);
		IToken RegularExpressionLiteral21 = default(IToken);
		AstParserRuleReturnScope<object, IToken> booleanLiteral18 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> numericLiteral19 = default(AstParserRuleReturnScope<object, IToken>);

		object NULL17_tree = default(object);
		object StringLiteral20_tree = default(object);
		object RegularExpressionLiteral21_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "literal");
		DebugLocation(527, 1);
		try
		{
			// TypeScript.g3:528:2: ( NULL | booleanLiteral | numericLiteral | StringLiteral | RegularExpressionLiteral )
			int alt4=5;
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case NULL:
				{
				alt4 = 1;
				}
				break;
			case FALSE:
			case TRUE:
				{
				alt4 = 2;
				}
				break;
			case DecimalLiteral:
			case HexIntegerLiteral:
			case OctalIntegerLiteral:
				{
				alt4 = 3;
				}
				break;
			case StringLiteral:
				{
				alt4 = 4;
				}
				break;
			case RegularExpressionLiteral:
				{
				alt4 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:528:4: NULL
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(528, 4);
				NULL17=(IToken)Match(input,NULL,Follow._NULL_in_literal3808); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NULL17_tree = (object)adaptor.Create(NULL17);
				adaptor.AddChild(root_0, NULL17_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:529:4: booleanLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(529, 4);
				PushFollow(Follow._booleanLiteral_in_literal3813);
				booleanLiteral18=booleanLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, booleanLiteral18.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:530:4: numericLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(530, 4);
				PushFollow(Follow._numericLiteral_in_literal3818);
				numericLiteral19=numericLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, numericLiteral19.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:531:4: StringLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(531, 4);
				StringLiteral20=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_literal3823); if (state.failed) return retval;
				if (state.backtracking == 0) {
				StringLiteral20_tree = (object)adaptor.Create(StringLiteral20);
				adaptor.AddChild(root_0, StringLiteral20_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:532:4: RegularExpressionLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(532, 4);
				RegularExpressionLiteral21=(IToken)Match(input,RegularExpressionLiteral,Follow._RegularExpressionLiteral_in_literal3828); if (state.failed) return retval;
				if (state.backtracking == 0) {
				RegularExpressionLiteral21_tree = (object)adaptor.Create(RegularExpressionLiteral21);
				adaptor.AddChild(root_0, RegularExpressionLiteral21_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("literal", 8);
			LeaveRule("literal", 8);
			LeaveRule_literal();
		}
		DebugLocation(533, 1);
		} finally { DebugExitRule(GrammarFileName, "literal"); }
		return retval;

	}
	// $ANTLR end "literal"

	partial void EnterRule_booleanLiteral();
	partial void LeaveRule_booleanLiteral();
	// $ANTLR start "booleanLiteral"
	// TypeScript.g3:535:1: booleanLiteral : ( TRUE | FALSE );
	[GrammarRule("booleanLiteral")]
	private AstParserRuleReturnScope<object, IToken> booleanLiteral()
	{
		EnterRule_booleanLiteral();
		EnterRule("booleanLiteral", 9);
		TraceIn("booleanLiteral", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set22 = default(IToken);

		object set22_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "booleanLiteral");
		DebugLocation(535, 1);
		try
		{
			// TypeScript.g3:536:2: ( TRUE | FALSE )
			DebugEnterAlt(1);
			// TypeScript.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(536, 2);

			set22=(IToken)input.LT(1);
			if (input.LA(1)==FALSE||input.LA(1)==TRUE)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set22));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("booleanLiteral", 9);
			LeaveRule("booleanLiteral", 9);
			LeaveRule_booleanLiteral();
		}
		DebugLocation(538, 1);
		} finally { DebugExitRule(GrammarFileName, "booleanLiteral"); }
		return retval;

	}
	// $ANTLR end "booleanLiteral"

	partial void EnterRule_numericLiteral();
	partial void LeaveRule_numericLiteral();
	// $ANTLR start "numericLiteral"
	// TypeScript.g3:582:1: numericLiteral : ( DecimalLiteral | OctalIntegerLiteral | HexIntegerLiteral );
	[GrammarRule("numericLiteral")]
	private AstParserRuleReturnScope<object, IToken> numericLiteral()
	{
		EnterRule_numericLiteral();
		EnterRule("numericLiteral", 10);
		TraceIn("numericLiteral", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set23 = default(IToken);

		object set23_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "numericLiteral");
		DebugLocation(582, 1);
		try
		{
			// TypeScript.g3:583:2: ( DecimalLiteral | OctalIntegerLiteral | HexIntegerLiteral )
			DebugEnterAlt(1);
			// TypeScript.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(583, 2);

			set23=(IToken)input.LT(1);
			if (input.LA(1)==DecimalLiteral||input.LA(1)==HexIntegerLiteral||input.LA(1)==OctalIntegerLiteral)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set23));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("numericLiteral", 10);
			LeaveRule("numericLiteral", 10);
			LeaveRule_numericLiteral();
		}
		DebugLocation(586, 1);
		} finally { DebugExitRule(GrammarFileName, "numericLiteral"); }
		return retval;

	}
	// $ANTLR end "numericLiteral"

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();
	// $ANTLR start "primaryExpression"
	// TypeScript.g3:670:1: primaryExpression : ( THIS | identifier | literal | arrayLiteral | objectLiteral |lpar= LPAREN expression RPAREN -> ^( PAREXPR[$lpar, \"PAREXPR\"] expression ) );
	[GrammarRule("primaryExpression")]
	private AstParserRuleReturnScope<object, IToken> primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 11);
		TraceIn("primaryExpression", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken lpar = default(IToken);
		IToken THIS24 = default(IToken);
		IToken RPAREN30 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier25 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> literal26 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arrayLiteral27 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> objectLiteral28 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression29 = default(AstParserRuleReturnScope<object, IToken>);

		object lpar_tree = default(object);
		object THIS24_tree = default(object);
		object RPAREN30_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(670, 1);
		try
		{
			// TypeScript.g3:671:2: ( THIS | identifier | literal | arrayLiteral | objectLiteral |lpar= LPAREN expression RPAREN -> ^( PAREXPR[$lpar, \"PAREXPR\"] expression ) )
			int alt5=6;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case THIS:
				{
				alt5 = 1;
				}
				break;
			case ANY:
			case CONSTRUCTOR:
			case DECLARE:
			case FINAL:
			case GET:
			case Identifier:
			case MODULE:
			case NUMBER:
			case REQUIRE:
			case SET:
			case STRING:
			case THROWS:
			case TYPE:
				{
				alt5 = 2;
				}
				break;
			case DecimalLiteral:
			case FALSE:
			case HexIntegerLiteral:
			case NULL:
			case OctalIntegerLiteral:
			case RegularExpressionLiteral:
			case StringLiteral:
			case TRUE:
				{
				alt5 = 3;
				}
				break;
			case LBRACK:
				{
				alt5 = 4;
				}
				break;
			case LBRACE:
				{
				alt5 = 5;
				}
				break;
			case LPAREN:
				{
				alt5 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:671:4: THIS
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(671, 4);
				THIS24=(IToken)Match(input,THIS,Follow._THIS_in_primaryExpression4441); if (state.failed) return retval;
				if (state.backtracking == 0) {
				THIS24_tree = (object)adaptor.Create(THIS24);
				adaptor.AddChild(root_0, THIS24_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:672:4: identifier
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(672, 4);
				PushFollow(Follow._identifier_in_primaryExpression4446);
				identifier25=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifier25.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:673:4: literal
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(673, 4);
				PushFollow(Follow._literal_in_primaryExpression4451);
				literal26=literal();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, literal26.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:674:4: arrayLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(674, 4);
				PushFollow(Follow._arrayLiteral_in_primaryExpression4456);
				arrayLiteral27=arrayLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, arrayLiteral27.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:675:4: objectLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(675, 4);
				PushFollow(Follow._objectLiteral_in_primaryExpression4461);
				objectLiteral28=objectLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, objectLiteral28.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScript.g3:676:4: lpar= LPAREN expression RPAREN
				{
				DebugLocation(676, 8);
				lpar=(IToken)Match(input,LPAREN,Follow._LPAREN_in_primaryExpression4468); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(lpar);

				DebugLocation(676, 16);
				PushFollow(Follow._expression_in_primaryExpression4470);
				expression29=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression29.Tree);
				DebugLocation(676, 27);
				RPAREN30=(IToken)Match(input,RPAREN,Follow._RPAREN_in_primaryExpression4472); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN30);



				{
				// AST REWRITE
				// elements: expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 676:34: -> ^( PAREXPR[$lpar, \"PAREXPR\"] expression )
				{
					DebugLocation(676, 37);
					// TypeScript.g3:676:37: ^( PAREXPR[$lpar, \"PAREXPR\"] expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(676, 40);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PAREXPR, lpar, "PAREXPR"), root_1);

					DebugLocation(676, 66);
					adaptor.AddChild(root_1, stream_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpression", 11);
			LeaveRule("primaryExpression", 11);
			LeaveRule_primaryExpression();
		}
		DebugLocation(677, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"

	partial void EnterRule_arrayLiteral();
	partial void LeaveRule_arrayLiteral();
	// $ANTLR start "arrayLiteral"
	// TypeScript.g3:679:1: arrayLiteral : lb= LBRACK ( arrayItem ( COMMA arrayItem )* )? RBRACK -> ^( ARRAY[$lb, \"ARRAY\"] ( arrayItem )* ) ;
	[GrammarRule("arrayLiteral")]
	private AstParserRuleReturnScope<object, IToken> arrayLiteral()
	{
		EnterRule_arrayLiteral();
		EnterRule("arrayLiteral", 12);
		TraceIn("arrayLiteral", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken lb = default(IToken);
		IToken COMMA32 = default(IToken);
		IToken RBRACK34 = default(IToken);
		AstParserRuleReturnScope<object, IToken> arrayItem31 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arrayItem33 = default(AstParserRuleReturnScope<object, IToken>);

		object lb_tree = default(object);
		object COMMA32_tree = default(object);
		object RBRACK34_tree = default(object);
		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
		RewriteRuleSubtreeStream stream_arrayItem=new RewriteRuleSubtreeStream(adaptor,"rule arrayItem");
		try { DebugEnterRule(GrammarFileName, "arrayLiteral");
		DebugLocation(679, 1);
		try
		{
			// TypeScript.g3:680:2: (lb= LBRACK ( arrayItem ( COMMA arrayItem )* )? RBRACK -> ^( ARRAY[$lb, \"ARRAY\"] ( arrayItem )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:680:4: lb= LBRACK ( arrayItem ( COMMA arrayItem )* )? RBRACK
			{
			DebugLocation(680, 6);
			lb=(IToken)Match(input,LBRACK,Follow._LBRACK_in_arrayLiteral4496); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACK.Add(lb);

			DebugLocation(680, 14);
			// TypeScript.g3:680:14: ( arrayItem ( COMMA arrayItem )* )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==ADD||LA7_1==ANY||LA7_1==COMMA||LA7_1==CONSTRUCTOR||(LA7_1>=DEC && LA7_1<=DECLARE)||LA7_1==DELETE||LA7_1==DecimalLiteral||LA7_1==FALSE||LA7_1==FINAL||LA7_1==FUNCTION||LA7_1==GET||LA7_1==HexIntegerLiteral||LA7_1==INC||LA7_1==INV||LA7_1==Identifier||(LA7_1>=LBRACE && LA7_1<=LBRACK)||LA7_1==LPAREN||LA7_1==MODULE||(LA7_1>=NEW && LA7_1<=NOT)||(LA7_1>=NULL && LA7_1<=NUMBER)||LA7_1==OctalIntegerLiteral||LA7_1==REQUIRE||LA7_1==RegularExpressionLiteral||LA7_1==SET||(LA7_1>=STRING && LA7_1<=SUB)||LA7_1==StringLiteral||LA7_1==THIS||LA7_1==THROWS||LA7_1==TRUE||(LA7_1>=TYPE && LA7_1<=TYPEOF)||LA7_1==VOID))
			{
				alt7 = 1;
			}
			else if ((LA7_1==RBRACK))
			{
				int LA7_2 = input.LA(2);

				if ((( input.LA(1) == COMMA )))
				{
					alt7 = 1;
				}
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:680:16: arrayItem ( COMMA arrayItem )*
				{
				DebugLocation(680, 16);
				PushFollow(Follow._arrayItem_in_arrayLiteral4500);
				arrayItem31=arrayItem();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_arrayItem.Add(arrayItem31.Tree);
				DebugLocation(680, 26);
				// TypeScript.g3:680:26: ( COMMA arrayItem )*
				try { DebugEnterSubRule(6);
				while (true)
				{
					int alt6=2;
					try { DebugEnterDecision(6, false);
					int LA6_1 = input.LA(1);

					if ((LA6_1==COMMA))
					{
						alt6 = 1;
					}


					} finally { DebugExitDecision(6); }
					switch ( alt6 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScript.g3:680:28: COMMA arrayItem
						{
						DebugLocation(680, 28);
						COMMA32=(IToken)Match(input,COMMA,Follow._COMMA_in_arrayLiteral4504); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA32);

						DebugLocation(680, 34);
						PushFollow(Follow._arrayItem_in_arrayLiteral4506);
						arrayItem33=arrayItem();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_arrayItem.Add(arrayItem33.Tree);

						}
						break;

					default:
						goto loop6;
					}
				}

				loop6:
					;

				} finally { DebugExitSubRule(6); }


				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(680, 50);
			RBRACK34=(IToken)Match(input,RBRACK,Follow._RBRACK_in_arrayLiteral4514); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACK.Add(RBRACK34);



			{
			// AST REWRITE
			// elements: arrayItem
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 681:2: -> ^( ARRAY[$lb, \"ARRAY\"] ( arrayItem )* )
			{
				DebugLocation(681, 5);
				// TypeScript.g3:681:5: ^( ARRAY[$lb, \"ARRAY\"] ( arrayItem )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(681, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY, lb, "ARRAY"), root_1);

				DebugLocation(681, 28);
				// TypeScript.g3:681:28: ( arrayItem )*
				while ( stream_arrayItem.HasNext )
				{
					DebugLocation(681, 28);
					adaptor.AddChild(root_1, stream_arrayItem.NextTree());

				}
				stream_arrayItem.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayLiteral", 12);
			LeaveRule("arrayLiteral", 12);
			LeaveRule_arrayLiteral();
		}
		DebugLocation(682, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayLiteral"); }
		return retval;

	}
	// $ANTLR end "arrayLiteral"

	partial void EnterRule_arrayItem();
	partial void LeaveRule_arrayItem();
	// $ANTLR start "arrayItem"
	// TypeScript.g3:684:1: arrayItem : (expr= assignmentExpression |{...}?) -> ^( ITEM ( $expr)? ) ;
	[GrammarRule("arrayItem")]
	private AstParserRuleReturnScope<object, IToken> arrayItem()
	{
		EnterRule_arrayItem();
		EnterRule("arrayItem", 13);
		TraceIn("arrayItem", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> expr = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "arrayItem");
		DebugLocation(684, 1);
		try
		{
			// TypeScript.g3:685:2: ( (expr= assignmentExpression |{...}?) -> ^( ITEM ( $expr)? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:685:4: (expr= assignmentExpression |{...}?)
			{
			DebugLocation(685, 4);
			// TypeScript.g3:685:4: (expr= assignmentExpression |{...}?)
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==ADD||LA8_1==ANY||LA8_1==CONSTRUCTOR||(LA8_1>=DEC && LA8_1<=DECLARE)||LA8_1==DELETE||LA8_1==DecimalLiteral||LA8_1==FALSE||LA8_1==FINAL||LA8_1==FUNCTION||LA8_1==GET||LA8_1==HexIntegerLiteral||LA8_1==INC||LA8_1==INV||LA8_1==Identifier||(LA8_1>=LBRACE && LA8_1<=LBRACK)||LA8_1==LPAREN||LA8_1==MODULE||(LA8_1>=NEW && LA8_1<=NOT)||(LA8_1>=NULL && LA8_1<=NUMBER)||LA8_1==OctalIntegerLiteral||LA8_1==REQUIRE||LA8_1==RegularExpressionLiteral||LA8_1==SET||(LA8_1>=STRING && LA8_1<=SUB)||LA8_1==StringLiteral||LA8_1==THIS||LA8_1==THROWS||LA8_1==TRUE||(LA8_1>=TYPE && LA8_1<=TYPEOF)||LA8_1==VOID))
			{
				alt8 = 1;
			}
			else if ((LA8_1==COMMA||LA8_1==RBRACK))
			{
				alt8 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:685:6: expr= assignmentExpression
				{
				DebugLocation(685, 10);
				PushFollow(Follow._assignmentExpression_in_arrayItem4542);
				expr=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpression.Add(expr.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:685:34: {...}?
				{
				DebugLocation(685, 34);
				if (!(( input.LA(1) == COMMA )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "arrayItem", " input.LA(1) == COMMA ");
				}

				}
				break;

			}
			} finally { DebugExitSubRule(8); }



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: expr, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 686:2: -> ^( ITEM ( $expr)? )
			{
				DebugLocation(686, 5);
				// TypeScript.g3:686:5: ^( ITEM ( $expr)? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(686, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ITEM, "ITEM"), root_1);

				DebugLocation(686, 14);
				// TypeScript.g3:686:14: ( $expr)?
				if (stream_expr.HasNext)
				{
					DebugLocation(686, 14);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayItem", 13);
			LeaveRule("arrayItem", 13);
			LeaveRule_arrayItem();
		}
		DebugLocation(687, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayItem"); }
		return retval;

	}
	// $ANTLR end "arrayItem"

	partial void EnterRule_objectLiteral();
	partial void LeaveRule_objectLiteral();
	// $ANTLR start "objectLiteral"
	// TypeScript.g3:689:1: objectLiteral : lb= LBRACE ( nameValuePair ( COMMA nameValuePair )* )? RBRACE -> ^( OBJECT[$lb, \"OBJECT\"] ( nameValuePair )* ) ;
	[GrammarRule("objectLiteral")]
	private AstParserRuleReturnScope<object, IToken> objectLiteral()
	{
		EnterRule_objectLiteral();
		EnterRule("objectLiteral", 14);
		TraceIn("objectLiteral", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken lb = default(IToken);
		IToken COMMA36 = default(IToken);
		IToken RBRACE38 = default(IToken);
		AstParserRuleReturnScope<object, IToken> nameValuePair35 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> nameValuePair37 = default(AstParserRuleReturnScope<object, IToken>);

		object lb_tree = default(object);
		object COMMA36_tree = default(object);
		object RBRACE38_tree = default(object);
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_nameValuePair=new RewriteRuleSubtreeStream(adaptor,"rule nameValuePair");
		try { DebugEnterRule(GrammarFileName, "objectLiteral");
		DebugLocation(689, 1);
		try
		{
			// TypeScript.g3:690:2: (lb= LBRACE ( nameValuePair ( COMMA nameValuePair )* )? RBRACE -> ^( OBJECT[$lb, \"OBJECT\"] ( nameValuePair )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:690:4: lb= LBRACE ( nameValuePair ( COMMA nameValuePair )* )? RBRACE
			{
			DebugLocation(690, 6);
			lb=(IToken)Match(input,LBRACE,Follow._LBRACE_in_objectLiteral4574); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACE.Add(lb);

			DebugLocation(690, 14);
			// TypeScript.g3:690:14: ( nameValuePair ( COMMA nameValuePair )* )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==ANY||LA10_1==CONSTRUCTOR||LA10_1==DECLARE||LA10_1==DecimalLiteral||LA10_1==FINAL||LA10_1==GET||LA10_1==HexIntegerLiteral||LA10_1==Identifier||LA10_1==MODULE||LA10_1==NUMBER||LA10_1==OctalIntegerLiteral||LA10_1==REQUIRE||LA10_1==SET||LA10_1==STRING||LA10_1==StringLiteral||LA10_1==THROWS||LA10_1==TYPE))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:690:16: nameValuePair ( COMMA nameValuePair )*
				{
				DebugLocation(690, 16);
				PushFollow(Follow._nameValuePair_in_objectLiteral4578);
				nameValuePair35=nameValuePair();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_nameValuePair.Add(nameValuePair35.Tree);
				DebugLocation(690, 30);
				// TypeScript.g3:690:30: ( COMMA nameValuePair )*
				try { DebugEnterSubRule(9);
				while (true)
				{
					int alt9=2;
					try { DebugEnterDecision(9, false);
					int LA9_1 = input.LA(1);

					if ((LA9_1==COMMA))
					{
						alt9 = 1;
					}


					} finally { DebugExitDecision(9); }
					switch ( alt9 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScript.g3:690:32: COMMA nameValuePair
						{
						DebugLocation(690, 32);
						COMMA36=(IToken)Match(input,COMMA,Follow._COMMA_in_objectLiteral4582); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA36);

						DebugLocation(690, 38);
						PushFollow(Follow._nameValuePair_in_objectLiteral4584);
						nameValuePair37=nameValuePair();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_nameValuePair.Add(nameValuePair37.Tree);

						}
						break;

					default:
						goto loop9;
					}
				}

				loop9:
					;

				} finally { DebugExitSubRule(9); }


				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(690, 58);
			RBRACE38=(IToken)Match(input,RBRACE,Follow._RBRACE_in_objectLiteral4592); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACE.Add(RBRACE38);



			{
			// AST REWRITE
			// elements: nameValuePair
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 691:2: -> ^( OBJECT[$lb, \"OBJECT\"] ( nameValuePair )* )
			{
				DebugLocation(691, 5);
				// TypeScript.g3:691:5: ^( OBJECT[$lb, \"OBJECT\"] ( nameValuePair )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(691, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(OBJECT, lb, "OBJECT"), root_1);

				DebugLocation(691, 30);
				// TypeScript.g3:691:30: ( nameValuePair )*
				while ( stream_nameValuePair.HasNext )
				{
					DebugLocation(691, 30);
					adaptor.AddChild(root_1, stream_nameValuePair.NextTree());

				}
				stream_nameValuePair.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("objectLiteral", 14);
			LeaveRule("objectLiteral", 14);
			LeaveRule_objectLiteral();
		}
		DebugLocation(692, 1);
		} finally { DebugExitRule(GrammarFileName, "objectLiteral"); }
		return retval;

	}
	// $ANTLR end "objectLiteral"

	partial void EnterRule_nameValuePair();
	partial void LeaveRule_nameValuePair();
	// $ANTLR start "nameValuePair"
	// TypeScript.g3:694:1: nameValuePair : propertyName COLON assignmentExpression -> ^( NAMEDVALUE propertyName assignmentExpression ) ;
	[GrammarRule("nameValuePair")]
	private AstParserRuleReturnScope<object, IToken> nameValuePair()
	{
		EnterRule_nameValuePair();
		EnterRule("nameValuePair", 15);
		TraceIn("nameValuePair", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COLON40 = default(IToken);
		AstParserRuleReturnScope<object, IToken> propertyName39 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression41 = default(AstParserRuleReturnScope<object, IToken>);

		object COLON40_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_propertyName=new RewriteRuleSubtreeStream(adaptor,"rule propertyName");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "nameValuePair");
		DebugLocation(694, 1);
		try
		{
			// TypeScript.g3:695:2: ( propertyName COLON assignmentExpression -> ^( NAMEDVALUE propertyName assignmentExpression ) )
			DebugEnterAlt(1);
			// TypeScript.g3:695:4: propertyName COLON assignmentExpression
			{
			DebugLocation(695, 4);
			PushFollow(Follow._propertyName_in_nameValuePair4617);
			propertyName39=propertyName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_propertyName.Add(propertyName39.Tree);
			DebugLocation(695, 17);
			COLON40=(IToken)Match(input,COLON,Follow._COLON_in_nameValuePair4619); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON40);

			DebugLocation(695, 23);
			PushFollow(Follow._assignmentExpression_in_nameValuePair4621);
			assignmentExpression41=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression41.Tree);


			{
			// AST REWRITE
			// elements: propertyName, assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 696:2: -> ^( NAMEDVALUE propertyName assignmentExpression )
			{
				DebugLocation(696, 5);
				// TypeScript.g3:696:5: ^( NAMEDVALUE propertyName assignmentExpression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(696, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAMEDVALUE, "NAMEDVALUE"), root_1);

				DebugLocation(696, 19);
				adaptor.AddChild(root_1, stream_propertyName.NextTree());
				DebugLocation(696, 32);
				adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nameValuePair", 15);
			LeaveRule("nameValuePair", 15);
			LeaveRule_nameValuePair();
		}
		DebugLocation(697, 1);
		} finally { DebugExitRule(GrammarFileName, "nameValuePair"); }
		return retval;

	}
	// $ANTLR end "nameValuePair"

	partial void EnterRule_propertyName();
	partial void LeaveRule_propertyName();
	// $ANTLR start "propertyName"
	// TypeScript.g3:699:1: propertyName : ( identifier | StringLiteral | numericLiteral );
	[GrammarRule("propertyName")]
	private AstParserRuleReturnScope<object, IToken> propertyName()
	{
		EnterRule_propertyName();
		EnterRule("propertyName", 16);
		TraceIn("propertyName", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken StringLiteral43 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier42 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> numericLiteral44 = default(AstParserRuleReturnScope<object, IToken>);

		object StringLiteral43_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "propertyName");
		DebugLocation(699, 1);
		try
		{
			// TypeScript.g3:700:2: ( identifier | StringLiteral | numericLiteral )
			int alt11=3;
			try { DebugEnterDecision(11, false);
			switch (input.LA(1))
			{
			case ANY:
			case CONSTRUCTOR:
			case DECLARE:
			case FINAL:
			case GET:
			case Identifier:
			case MODULE:
			case NUMBER:
			case REQUIRE:
			case SET:
			case STRING:
			case THROWS:
			case TYPE:
				{
				alt11 = 1;
				}
				break;
			case StringLiteral:
				{
				alt11 = 2;
				}
				break;
			case DecimalLiteral:
			case HexIntegerLiteral:
			case OctalIntegerLiteral:
				{
				alt11 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:700:4: identifier
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(700, 4);
				PushFollow(Follow._identifier_in_propertyName4645);
				identifier42=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifier42.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:701:4: StringLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(701, 4);
				StringLiteral43=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_propertyName4650); if (state.failed) return retval;
				if (state.backtracking == 0) {
				StringLiteral43_tree = (object)adaptor.Create(StringLiteral43);
				adaptor.AddChild(root_0, StringLiteral43_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:702:4: numericLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(702, 4);
				PushFollow(Follow._numericLiteral_in_propertyName4655);
				numericLiteral44=numericLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, numericLiteral44.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyName", 16);
			LeaveRule("propertyName", 16);
			LeaveRule_propertyName();
		}
		DebugLocation(703, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyName"); }
		return retval;

	}
	// $ANTLR end "propertyName"

	partial void EnterRule_memberExpression();
	partial void LeaveRule_memberExpression();
	// $ANTLR start "memberExpression"
	// TypeScript.g3:714:1: memberExpression : ( primaryExpression | functionExpression | newExpression );
	[GrammarRule("memberExpression")]
	private AstParserRuleReturnScope<object, IToken> memberExpression()
	{
		EnterRule_memberExpression();
		EnterRule("memberExpression", 17);
		TraceIn("memberExpression", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> primaryExpression45 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionExpression46 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> newExpression47 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "memberExpression");
		DebugLocation(714, 1);
		try
		{
			// TypeScript.g3:715:2: ( primaryExpression | functionExpression | newExpression )
			int alt12=3;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case ANY:
			case CONSTRUCTOR:
			case DECLARE:
			case DecimalLiteral:
			case FALSE:
			case FINAL:
			case GET:
			case HexIntegerLiteral:
			case Identifier:
			case LBRACE:
			case LBRACK:
			case LPAREN:
			case MODULE:
			case NULL:
			case NUMBER:
			case OctalIntegerLiteral:
			case REQUIRE:
			case RegularExpressionLiteral:
			case SET:
			case STRING:
			case StringLiteral:
			case THIS:
			case THROWS:
			case TRUE:
			case TYPE:
				{
				alt12 = 1;
				}
				break;
			case FUNCTION:
				{
				alt12 = 2;
				}
				break;
			case NEW:
				{
				alt12 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:715:4: primaryExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(715, 4);
				PushFollow(Follow._primaryExpression_in_memberExpression4673);
				primaryExpression45=primaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, primaryExpression45.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:716:4: functionExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(716, 4);
				PushFollow(Follow._functionExpression_in_memberExpression4678);
				functionExpression46=functionExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, functionExpression46.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:717:4: newExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(717, 4);
				PushFollow(Follow._newExpression_in_memberExpression4683);
				newExpression47=newExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, newExpression47.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("memberExpression", 17);
			LeaveRule("memberExpression", 17);
			LeaveRule_memberExpression();
		}
		DebugLocation(718, 1);
		} finally { DebugExitRule(GrammarFileName, "memberExpression"); }
		return retval;

	}
	// $ANTLR end "memberExpression"

	partial void EnterRule_newExpression();
	partial void LeaveRule_newExpression();
	// $ANTLR start "newExpression"
	// TypeScript.g3:720:1: newExpression : NEW ^ primaryExpression ;
	[GrammarRule("newExpression")]
	private AstParserRuleReturnScope<object, IToken> newExpression()
	{
		EnterRule_newExpression();
		EnterRule("newExpression", 18);
		TraceIn("newExpression", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NEW48 = default(IToken);
		AstParserRuleReturnScope<object, IToken> primaryExpression49 = default(AstParserRuleReturnScope<object, IToken>);

		object NEW48_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "newExpression");
		DebugLocation(720, 1);
		try
		{
			// TypeScript.g3:721:2: ( NEW ^ primaryExpression )
			DebugEnterAlt(1);
			// TypeScript.g3:721:4: NEW ^ primaryExpression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(721, 7);
			NEW48=(IToken)Match(input,NEW,Follow._NEW_in_newExpression4694); if (state.failed) return retval;
			if (state.backtracking == 0) {
			NEW48_tree = (object)adaptor.Create(NEW48);
			root_0 = (object)adaptor.BecomeRoot(NEW48_tree, root_0);
			}
			DebugLocation(721, 9);
			PushFollow(Follow._primaryExpression_in_newExpression4697);
			primaryExpression49=primaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, primaryExpression49.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("newExpression", 18);
			LeaveRule("newExpression", 18);
			LeaveRule_newExpression();
		}
		DebugLocation(722, 1);
		} finally { DebugExitRule(GrammarFileName, "newExpression"); }
		return retval;

	}
	// $ANTLR end "newExpression"

	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();
	// $ANTLR start "arguments"
	// TypeScript.g3:725:1: arguments : LPAREN ( assignmentExpression ( COMMA assignmentExpression )* )? RPAREN -> ^( ARGS ( assignmentExpression )* ) ;
	[GrammarRule("arguments")]
	private AstParserRuleReturnScope<object, IToken> arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 19);
		TraceIn("arguments", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN50 = default(IToken);
		IToken COMMA52 = default(IToken);
		IToken RPAREN54 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assignmentExpression51 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression53 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN50_tree = default(object);
		object COMMA52_tree = default(object);
		object RPAREN54_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(725, 1);
		try
		{
			// TypeScript.g3:726:2: ( LPAREN ( assignmentExpression ( COMMA assignmentExpression )* )? RPAREN -> ^( ARGS ( assignmentExpression )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:726:4: LPAREN ( assignmentExpression ( COMMA assignmentExpression )* )? RPAREN
			{
			DebugLocation(726, 4);
			LPAREN50=(IToken)Match(input,LPAREN,Follow._LPAREN_in_arguments4710); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN50);

			DebugLocation(726, 11);
			// TypeScript.g3:726:11: ( assignmentExpression ( COMMA assignmentExpression )* )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_1 = input.LA(1);

			if ((LA14_1==ADD||LA14_1==ANY||LA14_1==CONSTRUCTOR||(LA14_1>=DEC && LA14_1<=DECLARE)||LA14_1==DELETE||LA14_1==DecimalLiteral||LA14_1==FALSE||LA14_1==FINAL||LA14_1==FUNCTION||LA14_1==GET||LA14_1==HexIntegerLiteral||LA14_1==INC||LA14_1==INV||LA14_1==Identifier||(LA14_1>=LBRACE && LA14_1<=LBRACK)||LA14_1==LPAREN||LA14_1==MODULE||(LA14_1>=NEW && LA14_1<=NOT)||(LA14_1>=NULL && LA14_1<=NUMBER)||LA14_1==OctalIntegerLiteral||LA14_1==REQUIRE||LA14_1==RegularExpressionLiteral||LA14_1==SET||(LA14_1>=STRING && LA14_1<=SUB)||LA14_1==StringLiteral||LA14_1==THIS||LA14_1==THROWS||LA14_1==TRUE||(LA14_1>=TYPE && LA14_1<=TYPEOF)||LA14_1==VOID))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:726:13: assignmentExpression ( COMMA assignmentExpression )*
				{
				DebugLocation(726, 13);
				PushFollow(Follow._assignmentExpression_in_arguments4714);
				assignmentExpression51=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression51.Tree);
				DebugLocation(726, 34);
				// TypeScript.g3:726:34: ( COMMA assignmentExpression )*
				try { DebugEnterSubRule(13);
				while (true)
				{
					int alt13=2;
					try { DebugEnterDecision(13, false);
					int LA13_1 = input.LA(1);

					if ((LA13_1==COMMA))
					{
						alt13 = 1;
					}


					} finally { DebugExitDecision(13); }
					switch ( alt13 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScript.g3:726:36: COMMA assignmentExpression
						{
						DebugLocation(726, 36);
						COMMA52=(IToken)Match(input,COMMA,Follow._COMMA_in_arguments4718); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA52);

						DebugLocation(726, 42);
						PushFollow(Follow._assignmentExpression_in_arguments4720);
						assignmentExpression53=assignmentExpression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression53.Tree);

						}
						break;

					default:
						goto loop13;
					}
				}

				loop13:
					;

				} finally { DebugExitSubRule(13); }


				}
				break;

			}
			} finally { DebugExitSubRule(14); }

			DebugLocation(726, 69);
			RPAREN54=(IToken)Match(input,RPAREN,Follow._RPAREN_in_arguments4728); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN54);



			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 727:2: -> ^( ARGS ( assignmentExpression )* )
			{
				DebugLocation(727, 5);
				// TypeScript.g3:727:5: ^( ARGS ( assignmentExpression )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(727, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARGS, "ARGS"), root_1);

				DebugLocation(727, 13);
				// TypeScript.g3:727:13: ( assignmentExpression )*
				while ( stream_assignmentExpression.HasNext )
				{
					DebugLocation(727, 13);
					adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				}
				stream_assignmentExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arguments", 19);
			LeaveRule("arguments", 19);
			LeaveRule_arguments();
		}
		DebugLocation(728, 1);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return retval;

	}
	// $ANTLR end "arguments"

	partial void EnterRule_leftHandSideExpression();
	partial void LeaveRule_leftHandSideExpression();
	// $ANTLR start "leftHandSideExpression"
	// TypeScript.g3:730:1: leftHandSideExpression : ( memberExpression -> memberExpression ) ( arguments -> ^( CALL $leftHandSideExpression arguments ) | LBRACK expression RBRACK -> ^( BYINDEX $leftHandSideExpression expression ) | DOT identifier -> ^( BYFIELD $leftHandSideExpression identifier ) )* ;
	[GrammarRule("leftHandSideExpression")]
	private AstParserRuleReturnScope<object, IToken> leftHandSideExpression()
	{
		EnterRule_leftHandSideExpression();
		EnterRule("leftHandSideExpression", 20);
		TraceIn("leftHandSideExpression", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LBRACK57 = default(IToken);
		IToken RBRACK59 = default(IToken);
		IToken DOT60 = default(IToken);
		AstParserRuleReturnScope<object, IToken> memberExpression55 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arguments56 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression58 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> identifier61 = default(AstParserRuleReturnScope<object, IToken>);

		object LBRACK57_tree = default(object);
		object RBRACK59_tree = default(object);
		object DOT60_tree = default(object);
		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_memberExpression=new RewriteRuleSubtreeStream(adaptor,"rule memberExpression");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "leftHandSideExpression");
		DebugLocation(730, 1);
		try
		{
			// TypeScript.g3:731:2: ( ( memberExpression -> memberExpression ) ( arguments -> ^( CALL $leftHandSideExpression arguments ) | LBRACK expression RBRACK -> ^( BYINDEX $leftHandSideExpression expression ) | DOT identifier -> ^( BYFIELD $leftHandSideExpression identifier ) )* )
			DebugEnterAlt(1);
			// TypeScript.g3:732:2: ( memberExpression -> memberExpression ) ( arguments -> ^( CALL $leftHandSideExpression arguments ) | LBRACK expression RBRACK -> ^( BYINDEX $leftHandSideExpression expression ) | DOT identifier -> ^( BYFIELD $leftHandSideExpression identifier ) )*
			{
			DebugLocation(732, 2);
			// TypeScript.g3:732:2: ( memberExpression -> memberExpression )
			DebugEnterAlt(1);
			// TypeScript.g3:733:3: memberExpression
			{
			DebugLocation(733, 3);
			PushFollow(Follow._memberExpression_in_leftHandSideExpression4757);
			memberExpression55=memberExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_memberExpression.Add(memberExpression55.Tree);


			{
			// AST REWRITE
			// elements: memberExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 733:22: -> memberExpression
			{
				DebugLocation(733, 25);
				adaptor.AddChild(root_0, stream_memberExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(735, 2);
			// TypeScript.g3:735:2: ( arguments -> ^( CALL $leftHandSideExpression arguments ) | LBRACK expression RBRACK -> ^( BYINDEX $leftHandSideExpression expression ) | DOT identifier -> ^( BYFIELD $leftHandSideExpression identifier ) )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=4;
				try { DebugEnterDecision(15, false);
				switch (input.LA(1))
				{
				case LPAREN:
					{
					alt15 = 1;
					}
					break;
				case LBRACK:
					{
					alt15 = 2;
					}
					break;
				case DOT:
					{
					alt15 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:736:3: arguments
					{
					DebugLocation(736, 3);
					PushFollow(Follow._arguments_in_leftHandSideExpression4773);
					arguments56=arguments();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_arguments.Add(arguments56.Tree);


					{
					// AST REWRITE
					// elements: leftHandSideExpression, arguments
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 736:15: -> ^( CALL $leftHandSideExpression arguments )
					{
						DebugLocation(736, 18);
						// TypeScript.g3:736:18: ^( CALL $leftHandSideExpression arguments )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(736, 21);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

						DebugLocation(736, 27);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(736, 50);
						adaptor.AddChild(root_1, stream_arguments.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// TypeScript.g3:737:5: LBRACK expression RBRACK
					{
					DebugLocation(737, 5);
					LBRACK57=(IToken)Match(input,LBRACK,Follow._LBRACK_in_leftHandSideExpression4794); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LBRACK.Add(LBRACK57);

					DebugLocation(737, 12);
					PushFollow(Follow._expression_in_leftHandSideExpression4796);
					expression58=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression58.Tree);
					DebugLocation(737, 23);
					RBRACK59=(IToken)Match(input,RBRACK,Follow._RBRACK_in_leftHandSideExpression4798); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_RBRACK.Add(RBRACK59);



					{
					// AST REWRITE
					// elements: leftHandSideExpression, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 737:30: -> ^( BYINDEX $leftHandSideExpression expression )
					{
						DebugLocation(737, 33);
						// TypeScript.g3:737:33: ^( BYINDEX $leftHandSideExpression expression )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(737, 36);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BYINDEX, "BYINDEX"), root_1);

						DebugLocation(737, 45);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(737, 68);
						adaptor.AddChild(root_1, stream_expression.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// TypeScript.g3:738:5: DOT identifier
					{
					DebugLocation(738, 5);
					DOT60=(IToken)Match(input,DOT,Follow._DOT_in_leftHandSideExpression4817); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_DOT.Add(DOT60);

					DebugLocation(738, 9);
					PushFollow(Follow._identifier_in_leftHandSideExpression4819);
					identifier61=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_identifier.Add(identifier61.Tree);


					{
					// AST REWRITE
					// elements: leftHandSideExpression, identifier
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 738:21: -> ^( BYFIELD $leftHandSideExpression identifier )
					{
						DebugLocation(738, 24);
						// TypeScript.g3:738:24: ^( BYFIELD $leftHandSideExpression identifier )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(738, 27);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BYFIELD, "BYFIELD"), root_1);

						DebugLocation(738, 36);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(738, 59);
						adaptor.AddChild(root_1, stream_identifier.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("leftHandSideExpression", 20);
			LeaveRule("leftHandSideExpression", 20);
			LeaveRule_leftHandSideExpression();
		}
		DebugLocation(740, 1);
		} finally { DebugExitRule(GrammarFileName, "leftHandSideExpression"); }
		return retval;

	}
	// $ANTLR end "leftHandSideExpression"

	partial void EnterRule_postfixExpression();
	partial void LeaveRule_postfixExpression();
	// $ANTLR start "postfixExpression"
	// TypeScript.g3:752:1: postfixExpression : leftHandSideExpression ( postfixOperator ^)? ;
	[GrammarRule("postfixExpression")]
	private AstParserRuleReturnScope<object, IToken> postfixExpression()
	{
		EnterRule_postfixExpression();
		EnterRule("postfixExpression", 21);
		TraceIn("postfixExpression", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> leftHandSideExpression62 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> postfixOperator63 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "postfixExpression");
		DebugLocation(752, 1);
		try
		{
			// TypeScript.g3:753:2: ( leftHandSideExpression ( postfixOperator ^)? )
			DebugEnterAlt(1);
			// TypeScript.g3:753:4: leftHandSideExpression ( postfixOperator ^)?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(753, 4);
			PushFollow(Follow._leftHandSideExpression_in_postfixExpression4854);
			leftHandSideExpression62=leftHandSideExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, leftHandSideExpression62.Tree);
			DebugLocation(753, 27);
			if (state.backtracking == 0)
			{
				 if (input.LA(1) == INC || input.LA(1) == DEC) PromoteEOL(null); 
			}
			DebugLocation(753, 95);
			// TypeScript.g3:753:95: ( postfixOperator ^)?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==DEC||LA16_1==INC))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:753:97: postfixOperator ^
				{
				DebugLocation(753, 112);
				PushFollow(Follow._postfixOperator_in_postfixExpression4860);
				postfixOperator63=postfixOperator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot(postfixOperator63.Tree, root_0);

				}
				break;

			}
			} finally { DebugExitSubRule(16); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("postfixExpression", 21);
			LeaveRule("postfixExpression", 21);
			LeaveRule_postfixExpression();
		}
		DebugLocation(754, 1);
		} finally { DebugExitRule(GrammarFileName, "postfixExpression"); }
		return retval;

	}
	// $ANTLR end "postfixExpression"

	partial void EnterRule_postfixOperator();
	partial void LeaveRule_postfixOperator();
	// $ANTLR start "postfixOperator"
	// TypeScript.g3:756:1: postfixOperator : (op= INC |op= DEC );
	[GrammarRule("postfixOperator")]
	private AstParserRuleReturnScope<object, IToken> postfixOperator()
	{
		EnterRule_postfixOperator();
		EnterRule("postfixOperator", 22);
		TraceIn("postfixOperator", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken op = default(IToken);

		object op_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "postfixOperator");
		DebugLocation(756, 1);
		try
		{
			// TypeScript.g3:757:2: (op= INC |op= DEC )
			int alt17=2;
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if ((LA17_1==INC))
			{
				alt17 = 1;
			}
			else if ((LA17_1==DEC))
			{
				alt17 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:757:4: op= INC
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(757, 6);
				op=(IToken)Match(input,INC,Follow._INC_in_postfixOperator4878); if (state.failed) return retval;
				if (state.backtracking == 0) {
				op_tree = (object)adaptor.Create(op);
				adaptor.AddChild(root_0, op_tree);
				}
				DebugLocation(757, 11);
				if (state.backtracking == 0)
				{
					 op.Type = PINC; 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:758:4: op= DEC
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(758, 6);
				op=(IToken)Match(input,DEC,Follow._DEC_in_postfixOperator4887); if (state.failed) return retval;
				if (state.backtracking == 0) {
				op_tree = (object)adaptor.Create(op);
				adaptor.AddChild(root_0, op_tree);
				}
				DebugLocation(758, 11);
				if (state.backtracking == 0)
				{
					 op.Type = PDEC; 
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("postfixOperator", 22);
			LeaveRule("postfixOperator", 22);
			LeaveRule_postfixOperator();
		}
		DebugLocation(759, 1);
		} finally { DebugExitRule(GrammarFileName, "postfixOperator"); }
		return retval;

	}
	// $ANTLR end "postfixOperator"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();
	// $ANTLR start "unaryExpression"
	// TypeScript.g3:765:1: unaryExpression : ( postfixExpression | unaryOperator ^ unaryExpression );
	[GrammarRule("unaryExpression")]
	private AstParserRuleReturnScope<object, IToken> unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 23);
		TraceIn("unaryExpression", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> postfixExpression64 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> unaryOperator65 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> unaryExpression66 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(765, 1);
		try
		{
			// TypeScript.g3:766:2: ( postfixExpression | unaryOperator ^ unaryExpression )
			int alt18=2;
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==ANY||LA18_1==CONSTRUCTOR||LA18_1==DECLARE||LA18_1==DecimalLiteral||LA18_1==FALSE||LA18_1==FINAL||LA18_1==FUNCTION||LA18_1==GET||LA18_1==HexIntegerLiteral||LA18_1==Identifier||(LA18_1>=LBRACE && LA18_1<=LBRACK)||LA18_1==LPAREN||LA18_1==MODULE||LA18_1==NEW||(LA18_1>=NULL && LA18_1<=NUMBER)||LA18_1==OctalIntegerLiteral||LA18_1==REQUIRE||LA18_1==RegularExpressionLiteral||LA18_1==SET||LA18_1==STRING||LA18_1==StringLiteral||LA18_1==THIS||LA18_1==THROWS||LA18_1==TRUE||LA18_1==TYPE))
			{
				alt18 = 1;
			}
			else if ((LA18_1==ADD||LA18_1==DEC||LA18_1==DELETE||LA18_1==INC||LA18_1==INV||LA18_1==NOT||LA18_1==SUB||LA18_1==TYPEOF||LA18_1==VOID))
			{
				alt18 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 18, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:766:4: postfixExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(766, 4);
				PushFollow(Follow._postfixExpression_in_unaryExpression4904);
				postfixExpression64=postfixExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, postfixExpression64.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:767:4: unaryOperator ^ unaryExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(767, 17);
				PushFollow(Follow._unaryOperator_in_unaryExpression4909);
				unaryOperator65=unaryOperator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot(unaryOperator65.Tree, root_0);
				DebugLocation(767, 19);
				PushFollow(Follow._unaryExpression_in_unaryExpression4912);
				unaryExpression66=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression66.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 23);
			LeaveRule("unaryExpression", 23);
			LeaveRule_unaryExpression();
		}
		DebugLocation(768, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_unaryOperator();
	partial void LeaveRule_unaryOperator();
	// $ANTLR start "unaryOperator"
	// TypeScript.g3:770:1: unaryOperator : ( DELETE | VOID | TYPEOF | INC | DEC |op= ADD |op= SUB | INV | NOT );
	[GrammarRule("unaryOperator")]
	private AstParserRuleReturnScope<object, IToken> unaryOperator()
	{
		EnterRule_unaryOperator();
		EnterRule("unaryOperator", 24);
		TraceIn("unaryOperator", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken op = default(IToken);
		IToken DELETE67 = default(IToken);
		IToken VOID68 = default(IToken);
		IToken TYPEOF69 = default(IToken);
		IToken INC70 = default(IToken);
		IToken DEC71 = default(IToken);
		IToken INV72 = default(IToken);
		IToken NOT73 = default(IToken);

		object op_tree = default(object);
		object DELETE67_tree = default(object);
		object VOID68_tree = default(object);
		object TYPEOF69_tree = default(object);
		object INC70_tree = default(object);
		object DEC71_tree = default(object);
		object INV72_tree = default(object);
		object NOT73_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "unaryOperator");
		DebugLocation(770, 1);
		try
		{
			// TypeScript.g3:771:2: ( DELETE | VOID | TYPEOF | INC | DEC |op= ADD |op= SUB | INV | NOT )
			int alt19=9;
			try { DebugEnterDecision(19, false);
			switch (input.LA(1))
			{
			case DELETE:
				{
				alt19 = 1;
				}
				break;
			case VOID:
				{
				alt19 = 2;
				}
				break;
			case TYPEOF:
				{
				alt19 = 3;
				}
				break;
			case INC:
				{
				alt19 = 4;
				}
				break;
			case DEC:
				{
				alt19 = 5;
				}
				break;
			case ADD:
				{
				alt19 = 6;
				}
				break;
			case SUB:
				{
				alt19 = 7;
				}
				break;
			case INV:
				{
				alt19 = 8;
				}
				break;
			case NOT:
				{
				alt19 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 19, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:771:4: DELETE
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(771, 4);
				DELETE67=(IToken)Match(input,DELETE,Follow._DELETE_in_unaryOperator4924); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DELETE67_tree = (object)adaptor.Create(DELETE67);
				adaptor.AddChild(root_0, DELETE67_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:772:4: VOID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(772, 4);
				VOID68=(IToken)Match(input,VOID,Follow._VOID_in_unaryOperator4929); if (state.failed) return retval;
				if (state.backtracking == 0) {
				VOID68_tree = (object)adaptor.Create(VOID68);
				adaptor.AddChild(root_0, VOID68_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:773:4: TYPEOF
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(773, 4);
				TYPEOF69=(IToken)Match(input,TYPEOF,Follow._TYPEOF_in_unaryOperator4934); if (state.failed) return retval;
				if (state.backtracking == 0) {
				TYPEOF69_tree = (object)adaptor.Create(TYPEOF69);
				adaptor.AddChild(root_0, TYPEOF69_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:774:4: INC
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(774, 4);
				INC70=(IToken)Match(input,INC,Follow._INC_in_unaryOperator4939); if (state.failed) return retval;
				if (state.backtracking == 0) {
				INC70_tree = (object)adaptor.Create(INC70);
				adaptor.AddChild(root_0, INC70_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:775:4: DEC
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(775, 4);
				DEC71=(IToken)Match(input,DEC,Follow._DEC_in_unaryOperator4944); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DEC71_tree = (object)adaptor.Create(DEC71);
				adaptor.AddChild(root_0, DEC71_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScript.g3:776:4: op= ADD
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(776, 6);
				op=(IToken)Match(input,ADD,Follow._ADD_in_unaryOperator4951); if (state.failed) return retval;
				if (state.backtracking == 0) {
				op_tree = (object)adaptor.Create(op);
				adaptor.AddChild(root_0, op_tree);
				}
				DebugLocation(776, 11);
				if (state.backtracking == 0)
				{
					 op.Type = POS; 
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// TypeScript.g3:777:4: op= SUB
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(777, 6);
				op=(IToken)Match(input,SUB,Follow._SUB_in_unaryOperator4960); if (state.failed) return retval;
				if (state.backtracking == 0) {
				op_tree = (object)adaptor.Create(op);
				adaptor.AddChild(root_0, op_tree);
				}
				DebugLocation(777, 11);
				if (state.backtracking == 0)
				{
					 op.Type = NEG; 
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// TypeScript.g3:778:4: INV
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(778, 4);
				INV72=(IToken)Match(input,INV,Follow._INV_in_unaryOperator4967); if (state.failed) return retval;
				if (state.backtracking == 0) {
				INV72_tree = (object)adaptor.Create(INV72);
				adaptor.AddChild(root_0, INV72_tree);
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// TypeScript.g3:779:4: NOT
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(779, 4);
				NOT73=(IToken)Match(input,NOT,Follow._NOT_in_unaryOperator4972); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NOT73_tree = (object)adaptor.Create(NOT73);
				adaptor.AddChild(root_0, NOT73_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryOperator", 24);
			LeaveRule("unaryOperator", 24);
			LeaveRule_unaryOperator();
		}
		DebugLocation(780, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryOperator"); }
		return retval;

	}
	// $ANTLR end "unaryOperator"

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();
	// $ANTLR start "multiplicativeExpression"
	// TypeScript.g3:786:1: multiplicativeExpression : unaryExpression ( ( MUL | DIV | MOD ) ^ unaryExpression )* ;
	[GrammarRule("multiplicativeExpression")]
	private AstParserRuleReturnScope<object, IToken> multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 25);
		TraceIn("multiplicativeExpression", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set75 = default(IToken);
		AstParserRuleReturnScope<object, IToken> unaryExpression74 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> unaryExpression76 = default(AstParserRuleReturnScope<object, IToken>);

		object set75_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(786, 1);
		try
		{
			// TypeScript.g3:787:2: ( unaryExpression ( ( MUL | DIV | MOD ) ^ unaryExpression )* )
			DebugEnterAlt(1);
			// TypeScript.g3:787:4: unaryExpression ( ( MUL | DIV | MOD ) ^ unaryExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(787, 4);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression4987);
			unaryExpression74=unaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression74.Tree);
			DebugLocation(787, 20);
			// TypeScript.g3:787:20: ( ( MUL | DIV | MOD ) ^ unaryExpression )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1==DIV||LA20_1==MOD||LA20_1==MUL))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:787:22: ( MUL | DIV | MOD ) ^ unaryExpression
					{
					DebugLocation(787, 41);

					set75=(IToken)input.LT(1);
					set75=(IToken)input.LT(1);
					if (input.LA(1)==DIV||input.LA(1)==MOD||input.LA(1)==MUL)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set75), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(787, 43);
					PushFollow(Follow._unaryExpression_in_multiplicativeExpression5006);
					unaryExpression76=unaryExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression76.Tree);

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeExpression", 25);
			LeaveRule("multiplicativeExpression", 25);
			LeaveRule_multiplicativeExpression();
		}
		DebugLocation(788, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();
	// $ANTLR start "additiveExpression"
	// TypeScript.g3:794:1: additiveExpression : multiplicativeExpression ( ( ADD | SUB ) ^ multiplicativeExpression )* ;
	[GrammarRule("additiveExpression")]
	private AstParserRuleReturnScope<object, IToken> additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 26);
		TraceIn("additiveExpression", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set78 = default(IToken);
		AstParserRuleReturnScope<object, IToken> multiplicativeExpression77 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> multiplicativeExpression79 = default(AstParserRuleReturnScope<object, IToken>);

		object set78_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(794, 1);
		try
		{
			// TypeScript.g3:795:2: ( multiplicativeExpression ( ( ADD | SUB ) ^ multiplicativeExpression )* )
			DebugEnterAlt(1);
			// TypeScript.g3:795:4: multiplicativeExpression ( ( ADD | SUB ) ^ multiplicativeExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(795, 4);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression5024);
			multiplicativeExpression77=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression77.Tree);
			DebugLocation(795, 29);
			// TypeScript.g3:795:29: ( ( ADD | SUB ) ^ multiplicativeExpression )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_1 = input.LA(1);

				if ((LA21_1==ADD||LA21_1==SUB))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:795:31: ( ADD | SUB ) ^ multiplicativeExpression
					{
					DebugLocation(795, 44);

					set78=(IToken)input.LT(1);
					set78=(IToken)input.LT(1);
					if (input.LA(1)==ADD||input.LA(1)==SUB)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set78), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(795, 46);
					PushFollow(Follow._multiplicativeExpression_in_additiveExpression5039);
					multiplicativeExpression79=multiplicativeExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression79.Tree);

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 26);
			LeaveRule("additiveExpression", 26);
			LeaveRule_additiveExpression();
		}
		DebugLocation(796, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	partial void EnterRule_shiftExpression();
	partial void LeaveRule_shiftExpression();
	// $ANTLR start "shiftExpression"
	// TypeScript.g3:802:1: shiftExpression : additiveExpression ( ( SHL | SHR | SHU ) ^ additiveExpression )* ;
	[GrammarRule("shiftExpression")]
	private AstParserRuleReturnScope<object, IToken> shiftExpression()
	{
		EnterRule_shiftExpression();
		EnterRule("shiftExpression", 27);
		TraceIn("shiftExpression", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set81 = default(IToken);
		AstParserRuleReturnScope<object, IToken> additiveExpression80 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> additiveExpression82 = default(AstParserRuleReturnScope<object, IToken>);

		object set81_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "shiftExpression");
		DebugLocation(802, 1);
		try
		{
			// TypeScript.g3:803:2: ( additiveExpression ( ( SHL | SHR | SHU ) ^ additiveExpression )* )
			DebugEnterAlt(1);
			// TypeScript.g3:803:4: additiveExpression ( ( SHL | SHR | SHU ) ^ additiveExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(803, 4);
			PushFollow(Follow._additiveExpression_in_shiftExpression5058);
			additiveExpression80=additiveExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, additiveExpression80.Tree);
			DebugLocation(803, 23);
			// TypeScript.g3:803:23: ( ( SHL | SHR | SHU ) ^ additiveExpression )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1==SHL||LA22_1==SHR||LA22_1==SHU))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:803:25: ( SHL | SHR | SHU ) ^ additiveExpression
					{
					DebugLocation(803, 44);

					set81=(IToken)input.LT(1);
					set81=(IToken)input.LT(1);
					if (input.LA(1)==SHL||input.LA(1)==SHR||input.LA(1)==SHU)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set81), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(803, 46);
					PushFollow(Follow._additiveExpression_in_shiftExpression5077);
					additiveExpression82=additiveExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, additiveExpression82.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shiftExpression", 27);
			LeaveRule("shiftExpression", 27);
			LeaveRule_shiftExpression();
		}
		DebugLocation(804, 1);
		} finally { DebugExitRule(GrammarFileName, "shiftExpression"); }
		return retval;

	}
	// $ANTLR end "shiftExpression"

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();
	// $ANTLR start "relationalExpression"
	// TypeScript.g3:810:1: relationalExpression : shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) ^ shiftExpression )* ;
	[GrammarRule("relationalExpression")]
	private AstParserRuleReturnScope<object, IToken> relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 28);
		TraceIn("relationalExpression", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set84 = default(IToken);
		AstParserRuleReturnScope<object, IToken> shiftExpression83 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> shiftExpression85 = default(AstParserRuleReturnScope<object, IToken>);

		object set84_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(810, 1);
		try
		{
			// TypeScript.g3:811:2: ( shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) ^ shiftExpression )* )
			DebugEnterAlt(1);
			// TypeScript.g3:811:4: shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) ^ shiftExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(811, 4);
			PushFollow(Follow._shiftExpression_in_relationalExpression5096);
			shiftExpression83=shiftExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression83.Tree);
			DebugLocation(811, 20);
			// TypeScript.g3:811:20: ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) ^ shiftExpression )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if (((LA23_1>=GT && LA23_1<=GTE)||LA23_1==IN||LA23_1==INSTANCEOF||(LA23_1>=LT && LA23_1<=LTE)))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:811:22: ( LT | GT | LTE | GTE | INSTANCEOF | IN ) ^ shiftExpression
					{
					DebugLocation(811, 63);

					set84=(IToken)input.LT(1);
					set84=(IToken)input.LT(1);
					if ((input.LA(1)>=GT && input.LA(1)<=GTE)||input.LA(1)==IN||input.LA(1)==INSTANCEOF||(input.LA(1)>=LT && input.LA(1)<=LTE))
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set84), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(811, 65);
					PushFollow(Follow._shiftExpression_in_relationalExpression5127);
					shiftExpression85=shiftExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression85.Tree);

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 28);
			LeaveRule("relationalExpression", 28);
			LeaveRule_relationalExpression();
		}
		DebugLocation(812, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	partial void EnterRule_relationalExpressionNoIn();
	partial void LeaveRule_relationalExpressionNoIn();
	// $ANTLR start "relationalExpressionNoIn"
	// TypeScript.g3:814:1: relationalExpressionNoIn : shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF ) ^ shiftExpression )* ;
	[GrammarRule("relationalExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> relationalExpressionNoIn()
	{
		EnterRule_relationalExpressionNoIn();
		EnterRule("relationalExpressionNoIn", 29);
		TraceIn("relationalExpressionNoIn", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set87 = default(IToken);
		AstParserRuleReturnScope<object, IToken> shiftExpression86 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> shiftExpression88 = default(AstParserRuleReturnScope<object, IToken>);

		object set87_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "relationalExpressionNoIn");
		DebugLocation(814, 1);
		try
		{
			// TypeScript.g3:815:2: ( shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF ) ^ shiftExpression )* )
			DebugEnterAlt(1);
			// TypeScript.g3:815:4: shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF ) ^ shiftExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(815, 4);
			PushFollow(Follow._shiftExpression_in_relationalExpressionNoIn5141);
			shiftExpression86=shiftExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression86.Tree);
			DebugLocation(815, 20);
			// TypeScript.g3:815:20: ( ( LT | GT | LTE | GTE | INSTANCEOF ) ^ shiftExpression )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if (((LA24_1>=GT && LA24_1<=GTE)||LA24_1==INSTANCEOF||(LA24_1>=LT && LA24_1<=LTE)))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:815:22: ( LT | GT | LTE | GTE | INSTANCEOF ) ^ shiftExpression
					{
					DebugLocation(815, 58);

					set87=(IToken)input.LT(1);
					set87=(IToken)input.LT(1);
					if ((input.LA(1)>=GT && input.LA(1)<=GTE)||input.LA(1)==INSTANCEOF||(input.LA(1)>=LT && input.LA(1)<=LTE))
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set87), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(815, 60);
					PushFollow(Follow._shiftExpression_in_relationalExpressionNoIn5168);
					shiftExpression88=shiftExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression88.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpressionNoIn", 29);
			LeaveRule("relationalExpressionNoIn", 29);
			LeaveRule_relationalExpressionNoIn();
		}
		DebugLocation(816, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "relationalExpressionNoIn"

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();
	// $ANTLR start "equalityExpression"
	// TypeScript.g3:822:1: equalityExpression : relationalExpression ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpression )* ;
	[GrammarRule("equalityExpression")]
	private AstParserRuleReturnScope<object, IToken> equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 30);
		TraceIn("equalityExpression", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set90 = default(IToken);
		AstParserRuleReturnScope<object, IToken> relationalExpression89 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> relationalExpression91 = default(AstParserRuleReturnScope<object, IToken>);

		object set90_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(822, 1);
		try
		{
			// TypeScript.g3:823:2: ( relationalExpression ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpression )* )
			DebugEnterAlt(1);
			// TypeScript.g3:823:4: relationalExpression ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(823, 4);
			PushFollow(Follow._relationalExpression_in_equalityExpression5187);
			relationalExpression89=relationalExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpression89.Tree);
			DebugLocation(823, 25);
			// TypeScript.g3:823:25: ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpression )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_1 = input.LA(1);

				if ((LA25_1==EQ||LA25_1==NEQ||LA25_1==NSAME||LA25_1==SAME))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:823:27: ( EQ | NEQ | SAME | NSAME ) ^ relationalExpression
					{
					DebugLocation(823, 54);

					set90=(IToken)input.LT(1);
					set90=(IToken)input.LT(1);
					if (input.LA(1)==EQ||input.LA(1)==NEQ||input.LA(1)==NSAME||input.LA(1)==SAME)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set90), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(823, 56);
					PushFollow(Follow._relationalExpression_in_equalityExpression5210);
					relationalExpression91=relationalExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpression91.Tree);

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 30);
			LeaveRule("equalityExpression", 30);
			LeaveRule_equalityExpression();
		}
		DebugLocation(824, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	partial void EnterRule_equalityExpressionNoIn();
	partial void LeaveRule_equalityExpressionNoIn();
	// $ANTLR start "equalityExpressionNoIn"
	// TypeScript.g3:826:1: equalityExpressionNoIn : relationalExpressionNoIn ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpressionNoIn )* ;
	[GrammarRule("equalityExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> equalityExpressionNoIn()
	{
		EnterRule_equalityExpressionNoIn();
		EnterRule("equalityExpressionNoIn", 31);
		TraceIn("equalityExpressionNoIn", 31);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set93 = default(IToken);
		AstParserRuleReturnScope<object, IToken> relationalExpressionNoIn92 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> relationalExpressionNoIn94 = default(AstParserRuleReturnScope<object, IToken>);

		object set93_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "equalityExpressionNoIn");
		DebugLocation(826, 1);
		try
		{
			// TypeScript.g3:827:2: ( relationalExpressionNoIn ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpressionNoIn )* )
			DebugEnterAlt(1);
			// TypeScript.g3:827:4: relationalExpressionNoIn ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(827, 4);
			PushFollow(Follow._relationalExpressionNoIn_in_equalityExpressionNoIn5224);
			relationalExpressionNoIn92=relationalExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpressionNoIn92.Tree);
			DebugLocation(827, 29);
			// TypeScript.g3:827:29: ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpressionNoIn )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_1 = input.LA(1);

				if ((LA26_1==EQ||LA26_1==NEQ||LA26_1==NSAME||LA26_1==SAME))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:827:31: ( EQ | NEQ | SAME | NSAME ) ^ relationalExpressionNoIn
					{
					DebugLocation(827, 58);

					set93=(IToken)input.LT(1);
					set93=(IToken)input.LT(1);
					if (input.LA(1)==EQ||input.LA(1)==NEQ||input.LA(1)==NSAME||input.LA(1)==SAME)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set93), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(827, 60);
					PushFollow(Follow._relationalExpressionNoIn_in_equalityExpressionNoIn5247);
					relationalExpressionNoIn94=relationalExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpressionNoIn94.Tree);

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpressionNoIn", 31);
			LeaveRule("equalityExpressionNoIn", 31);
			LeaveRule_equalityExpressionNoIn();
		}
		DebugLocation(828, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "equalityExpressionNoIn"

	partial void EnterRule_bitwiseANDExpression();
	partial void LeaveRule_bitwiseANDExpression();
	// $ANTLR start "bitwiseANDExpression"
	// TypeScript.g3:834:1: bitwiseANDExpression : equalityExpression ( AND ^ equalityExpression )* ;
	[GrammarRule("bitwiseANDExpression")]
	private AstParserRuleReturnScope<object, IToken> bitwiseANDExpression()
	{
		EnterRule_bitwiseANDExpression();
		EnterRule("bitwiseANDExpression", 32);
		TraceIn("bitwiseANDExpression", 32);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND96 = default(IToken);
		AstParserRuleReturnScope<object, IToken> equalityExpression95 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> equalityExpression97 = default(AstParserRuleReturnScope<object, IToken>);

		object AND96_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseANDExpression");
		DebugLocation(834, 1);
		try
		{
			// TypeScript.g3:835:2: ( equalityExpression ( AND ^ equalityExpression )* )
			DebugEnterAlt(1);
			// TypeScript.g3:835:4: equalityExpression ( AND ^ equalityExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(835, 4);
			PushFollow(Follow._equalityExpression_in_bitwiseANDExpression5267);
			equalityExpression95=equalityExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpression95.Tree);
			DebugLocation(835, 23);
			// TypeScript.g3:835:23: ( AND ^ equalityExpression )*
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_1 = input.LA(1);

				if ((LA27_1==AND))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch ( alt27 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:835:25: AND ^ equalityExpression
					{
					DebugLocation(835, 28);
					AND96=(IToken)Match(input,AND,Follow._AND_in_bitwiseANDExpression5271); if (state.failed) return retval;
					if (state.backtracking == 0) {
					AND96_tree = (object)adaptor.Create(AND96);
					root_0 = (object)adaptor.BecomeRoot(AND96_tree, root_0);
					}
					DebugLocation(835, 30);
					PushFollow(Follow._equalityExpression_in_bitwiseANDExpression5274);
					equalityExpression97=equalityExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpression97.Tree);

					}
					break;

				default:
					goto loop27;
				}
			}

			loop27:
				;

			} finally { DebugExitSubRule(27); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseANDExpression", 32);
			LeaveRule("bitwiseANDExpression", 32);
			LeaveRule_bitwiseANDExpression();
		}
		DebugLocation(836, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseANDExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseANDExpression"

	partial void EnterRule_bitwiseANDExpressionNoIn();
	partial void LeaveRule_bitwiseANDExpressionNoIn();
	// $ANTLR start "bitwiseANDExpressionNoIn"
	// TypeScript.g3:838:1: bitwiseANDExpressionNoIn : equalityExpressionNoIn ( AND ^ equalityExpressionNoIn )* ;
	[GrammarRule("bitwiseANDExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> bitwiseANDExpressionNoIn()
	{
		EnterRule_bitwiseANDExpressionNoIn();
		EnterRule("bitwiseANDExpressionNoIn", 33);
		TraceIn("bitwiseANDExpressionNoIn", 33);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND99 = default(IToken);
		AstParserRuleReturnScope<object, IToken> equalityExpressionNoIn98 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> equalityExpressionNoIn100 = default(AstParserRuleReturnScope<object, IToken>);

		object AND99_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseANDExpressionNoIn");
		DebugLocation(838, 1);
		try
		{
			// TypeScript.g3:839:2: ( equalityExpressionNoIn ( AND ^ equalityExpressionNoIn )* )
			DebugEnterAlt(1);
			// TypeScript.g3:839:4: equalityExpressionNoIn ( AND ^ equalityExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(839, 4);
			PushFollow(Follow._equalityExpressionNoIn_in_bitwiseANDExpressionNoIn5288);
			equalityExpressionNoIn98=equalityExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpressionNoIn98.Tree);
			DebugLocation(839, 27);
			// TypeScript.g3:839:27: ( AND ^ equalityExpressionNoIn )*
			try { DebugEnterSubRule(28);
			while (true)
			{
				int alt28=2;
				try { DebugEnterDecision(28, false);
				int LA28_1 = input.LA(1);

				if ((LA28_1==AND))
				{
					alt28 = 1;
				}


				} finally { DebugExitDecision(28); }
				switch ( alt28 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:839:29: AND ^ equalityExpressionNoIn
					{
					DebugLocation(839, 32);
					AND99=(IToken)Match(input,AND,Follow._AND_in_bitwiseANDExpressionNoIn5292); if (state.failed) return retval;
					if (state.backtracking == 0) {
					AND99_tree = (object)adaptor.Create(AND99);
					root_0 = (object)adaptor.BecomeRoot(AND99_tree, root_0);
					}
					DebugLocation(839, 34);
					PushFollow(Follow._equalityExpressionNoIn_in_bitwiseANDExpressionNoIn5295);
					equalityExpressionNoIn100=equalityExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpressionNoIn100.Tree);

					}
					break;

				default:
					goto loop28;
				}
			}

			loop28:
				;

			} finally { DebugExitSubRule(28); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseANDExpressionNoIn", 33);
			LeaveRule("bitwiseANDExpressionNoIn", 33);
			LeaveRule_bitwiseANDExpressionNoIn();
		}
		DebugLocation(840, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseANDExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseANDExpressionNoIn"

	partial void EnterRule_bitwiseXORExpression();
	partial void LeaveRule_bitwiseXORExpression();
	// $ANTLR start "bitwiseXORExpression"
	// TypeScript.g3:842:1: bitwiseXORExpression : bitwiseANDExpression ( XOR ^ bitwiseANDExpression )* ;
	[GrammarRule("bitwiseXORExpression")]
	private AstParserRuleReturnScope<object, IToken> bitwiseXORExpression()
	{
		EnterRule_bitwiseXORExpression();
		EnterRule("bitwiseXORExpression", 34);
		TraceIn("bitwiseXORExpression", 34);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken XOR102 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseANDExpression101 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseANDExpression103 = default(AstParserRuleReturnScope<object, IToken>);

		object XOR102_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseXORExpression");
		DebugLocation(842, 1);
		try
		{
			// TypeScript.g3:843:2: ( bitwiseANDExpression ( XOR ^ bitwiseANDExpression )* )
			DebugEnterAlt(1);
			// TypeScript.g3:843:4: bitwiseANDExpression ( XOR ^ bitwiseANDExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(843, 4);
			PushFollow(Follow._bitwiseANDExpression_in_bitwiseXORExpression5311);
			bitwiseANDExpression101=bitwiseANDExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseANDExpression101.Tree);
			DebugLocation(843, 25);
			// TypeScript.g3:843:25: ( XOR ^ bitwiseANDExpression )*
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=2;
				try { DebugEnterDecision(29, false);
				int LA29_1 = input.LA(1);

				if ((LA29_1==XOR))
				{
					alt29 = 1;
				}


				} finally { DebugExitDecision(29); }
				switch ( alt29 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:843:27: XOR ^ bitwiseANDExpression
					{
					DebugLocation(843, 30);
					XOR102=(IToken)Match(input,XOR,Follow._XOR_in_bitwiseXORExpression5315); if (state.failed) return retval;
					if (state.backtracking == 0) {
					XOR102_tree = (object)adaptor.Create(XOR102);
					root_0 = (object)adaptor.BecomeRoot(XOR102_tree, root_0);
					}
					DebugLocation(843, 32);
					PushFollow(Follow._bitwiseANDExpression_in_bitwiseXORExpression5318);
					bitwiseANDExpression103=bitwiseANDExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseANDExpression103.Tree);

					}
					break;

				default:
					goto loop29;
				}
			}

			loop29:
				;

			} finally { DebugExitSubRule(29); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXORExpression", 34);
			LeaveRule("bitwiseXORExpression", 34);
			LeaveRule_bitwiseXORExpression();
		}
		DebugLocation(844, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXORExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseXORExpression"

	partial void EnterRule_bitwiseXORExpressionNoIn();
	partial void LeaveRule_bitwiseXORExpressionNoIn();
	// $ANTLR start "bitwiseXORExpressionNoIn"
	// TypeScript.g3:846:1: bitwiseXORExpressionNoIn : bitwiseANDExpressionNoIn ( XOR ^ bitwiseANDExpressionNoIn )* ;
	[GrammarRule("bitwiseXORExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> bitwiseXORExpressionNoIn()
	{
		EnterRule_bitwiseXORExpressionNoIn();
		EnterRule("bitwiseXORExpressionNoIn", 35);
		TraceIn("bitwiseXORExpressionNoIn", 35);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken XOR105 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseANDExpressionNoIn104 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseANDExpressionNoIn106 = default(AstParserRuleReturnScope<object, IToken>);

		object XOR105_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseXORExpressionNoIn");
		DebugLocation(846, 1);
		try
		{
			// TypeScript.g3:847:2: ( bitwiseANDExpressionNoIn ( XOR ^ bitwiseANDExpressionNoIn )* )
			DebugEnterAlt(1);
			// TypeScript.g3:847:4: bitwiseANDExpressionNoIn ( XOR ^ bitwiseANDExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(847, 4);
			PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn5334);
			bitwiseANDExpressionNoIn104=bitwiseANDExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseANDExpressionNoIn104.Tree);
			DebugLocation(847, 29);
			// TypeScript.g3:847:29: ( XOR ^ bitwiseANDExpressionNoIn )*
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				int LA30_1 = input.LA(1);

				if ((LA30_1==XOR))
				{
					alt30 = 1;
				}


				} finally { DebugExitDecision(30); }
				switch ( alt30 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:847:31: XOR ^ bitwiseANDExpressionNoIn
					{
					DebugLocation(847, 34);
					XOR105=(IToken)Match(input,XOR,Follow._XOR_in_bitwiseXORExpressionNoIn5338); if (state.failed) return retval;
					if (state.backtracking == 0) {
					XOR105_tree = (object)adaptor.Create(XOR105);
					root_0 = (object)adaptor.BecomeRoot(XOR105_tree, root_0);
					}
					DebugLocation(847, 36);
					PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn5341);
					bitwiseANDExpressionNoIn106=bitwiseANDExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseANDExpressionNoIn106.Tree);

					}
					break;

				default:
					goto loop30;
				}
			}

			loop30:
				;

			} finally { DebugExitSubRule(30); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXORExpressionNoIn", 35);
			LeaveRule("bitwiseXORExpressionNoIn", 35);
			LeaveRule_bitwiseXORExpressionNoIn();
		}
		DebugLocation(848, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseXORExpressionNoIn"

	partial void EnterRule_bitwiseORExpression();
	partial void LeaveRule_bitwiseORExpression();
	// $ANTLR start "bitwiseORExpression"
	// TypeScript.g3:850:1: bitwiseORExpression : bitwiseXORExpression ( OR ^ bitwiseXORExpression )* ;
	[GrammarRule("bitwiseORExpression")]
	private AstParserRuleReturnScope<object, IToken> bitwiseORExpression()
	{
		EnterRule_bitwiseORExpression();
		EnterRule("bitwiseORExpression", 36);
		TraceIn("bitwiseORExpression", 36);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR108 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseXORExpression107 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseXORExpression109 = default(AstParserRuleReturnScope<object, IToken>);

		object OR108_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseORExpression");
		DebugLocation(850, 1);
		try
		{
			// TypeScript.g3:851:2: ( bitwiseXORExpression ( OR ^ bitwiseXORExpression )* )
			DebugEnterAlt(1);
			// TypeScript.g3:851:4: bitwiseXORExpression ( OR ^ bitwiseXORExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(851, 4);
			PushFollow(Follow._bitwiseXORExpression_in_bitwiseORExpression5356);
			bitwiseXORExpression107=bitwiseXORExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXORExpression107.Tree);
			DebugLocation(851, 25);
			// TypeScript.g3:851:25: ( OR ^ bitwiseXORExpression )*
			try { DebugEnterSubRule(31);
			while (true)
			{
				int alt31=2;
				try { DebugEnterDecision(31, false);
				int LA31_1 = input.LA(1);

				if ((LA31_1==OR))
				{
					alt31 = 1;
				}


				} finally { DebugExitDecision(31); }
				switch ( alt31 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:851:27: OR ^ bitwiseXORExpression
					{
					DebugLocation(851, 29);
					OR108=(IToken)Match(input,OR,Follow._OR_in_bitwiseORExpression5360); if (state.failed) return retval;
					if (state.backtracking == 0) {
					OR108_tree = (object)adaptor.Create(OR108);
					root_0 = (object)adaptor.BecomeRoot(OR108_tree, root_0);
					}
					DebugLocation(851, 31);
					PushFollow(Follow._bitwiseXORExpression_in_bitwiseORExpression5363);
					bitwiseXORExpression109=bitwiseXORExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXORExpression109.Tree);

					}
					break;

				default:
					goto loop31;
				}
			}

			loop31:
				;

			} finally { DebugExitSubRule(31); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseORExpression", 36);
			LeaveRule("bitwiseORExpression", 36);
			LeaveRule_bitwiseORExpression();
		}
		DebugLocation(852, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseORExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseORExpression"

	partial void EnterRule_bitwiseORExpressionNoIn();
	partial void LeaveRule_bitwiseORExpressionNoIn();
	// $ANTLR start "bitwiseORExpressionNoIn"
	// TypeScript.g3:854:1: bitwiseORExpressionNoIn : bitwiseXORExpressionNoIn ( OR ^ bitwiseXORExpressionNoIn )* ;
	[GrammarRule("bitwiseORExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> bitwiseORExpressionNoIn()
	{
		EnterRule_bitwiseORExpressionNoIn();
		EnterRule("bitwiseORExpressionNoIn", 37);
		TraceIn("bitwiseORExpressionNoIn", 37);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR111 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseXORExpressionNoIn110 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseXORExpressionNoIn112 = default(AstParserRuleReturnScope<object, IToken>);

		object OR111_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseORExpressionNoIn");
		DebugLocation(854, 1);
		try
		{
			// TypeScript.g3:855:2: ( bitwiseXORExpressionNoIn ( OR ^ bitwiseXORExpressionNoIn )* )
			DebugEnterAlt(1);
			// TypeScript.g3:855:4: bitwiseXORExpressionNoIn ( OR ^ bitwiseXORExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(855, 4);
			PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn5378);
			bitwiseXORExpressionNoIn110=bitwiseXORExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXORExpressionNoIn110.Tree);
			DebugLocation(855, 29);
			// TypeScript.g3:855:29: ( OR ^ bitwiseXORExpressionNoIn )*
			try { DebugEnterSubRule(32);
			while (true)
			{
				int alt32=2;
				try { DebugEnterDecision(32, false);
				int LA32_1 = input.LA(1);

				if ((LA32_1==OR))
				{
					alt32 = 1;
				}


				} finally { DebugExitDecision(32); }
				switch ( alt32 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:855:31: OR ^ bitwiseXORExpressionNoIn
					{
					DebugLocation(855, 33);
					OR111=(IToken)Match(input,OR,Follow._OR_in_bitwiseORExpressionNoIn5382); if (state.failed) return retval;
					if (state.backtracking == 0) {
					OR111_tree = (object)adaptor.Create(OR111);
					root_0 = (object)adaptor.BecomeRoot(OR111_tree, root_0);
					}
					DebugLocation(855, 35);
					PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn5385);
					bitwiseXORExpressionNoIn112=bitwiseXORExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXORExpressionNoIn112.Tree);

					}
					break;

				default:
					goto loop32;
				}
			}

			loop32:
				;

			} finally { DebugExitSubRule(32); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseORExpressionNoIn", 37);
			LeaveRule("bitwiseORExpressionNoIn", 37);
			LeaveRule_bitwiseORExpressionNoIn();
		}
		DebugLocation(856, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseORExpressionNoIn"

	partial void EnterRule_logicalANDExpression();
	partial void LeaveRule_logicalANDExpression();
	// $ANTLR start "logicalANDExpression"
	// TypeScript.g3:862:1: logicalANDExpression : bitwiseORExpression ( LAND ^ bitwiseORExpression )* ;
	[GrammarRule("logicalANDExpression")]
	private AstParserRuleReturnScope<object, IToken> logicalANDExpression()
	{
		EnterRule_logicalANDExpression();
		EnterRule("logicalANDExpression", 38);
		TraceIn("logicalANDExpression", 38);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LAND114 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseORExpression113 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseORExpression115 = default(AstParserRuleReturnScope<object, IToken>);

		object LAND114_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logicalANDExpression");
		DebugLocation(862, 1);
		try
		{
			// TypeScript.g3:863:2: ( bitwiseORExpression ( LAND ^ bitwiseORExpression )* )
			DebugEnterAlt(1);
			// TypeScript.g3:863:4: bitwiseORExpression ( LAND ^ bitwiseORExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(863, 4);
			PushFollow(Follow._bitwiseORExpression_in_logicalANDExpression5404);
			bitwiseORExpression113=bitwiseORExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseORExpression113.Tree);
			DebugLocation(863, 24);
			// TypeScript.g3:863:24: ( LAND ^ bitwiseORExpression )*
			try { DebugEnterSubRule(33);
			while (true)
			{
				int alt33=2;
				try { DebugEnterDecision(33, false);
				int LA33_1 = input.LA(1);

				if ((LA33_1==LAND))
				{
					alt33 = 1;
				}


				} finally { DebugExitDecision(33); }
				switch ( alt33 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:863:26: LAND ^ bitwiseORExpression
					{
					DebugLocation(863, 30);
					LAND114=(IToken)Match(input,LAND,Follow._LAND_in_logicalANDExpression5408); if (state.failed) return retval;
					if (state.backtracking == 0) {
					LAND114_tree = (object)adaptor.Create(LAND114);
					root_0 = (object)adaptor.BecomeRoot(LAND114_tree, root_0);
					}
					DebugLocation(863, 32);
					PushFollow(Follow._bitwiseORExpression_in_logicalANDExpression5411);
					bitwiseORExpression115=bitwiseORExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseORExpression115.Tree);

					}
					break;

				default:
					goto loop33;
				}
			}

			loop33:
				;

			} finally { DebugExitSubRule(33); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalANDExpression", 38);
			LeaveRule("logicalANDExpression", 38);
			LeaveRule_logicalANDExpression();
		}
		DebugLocation(864, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalANDExpression"); }
		return retval;

	}
	// $ANTLR end "logicalANDExpression"

	partial void EnterRule_logicalANDExpressionNoIn();
	partial void LeaveRule_logicalANDExpressionNoIn();
	// $ANTLR start "logicalANDExpressionNoIn"
	// TypeScript.g3:866:1: logicalANDExpressionNoIn : bitwiseORExpressionNoIn ( LAND ^ bitwiseORExpressionNoIn )* ;
	[GrammarRule("logicalANDExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> logicalANDExpressionNoIn()
	{
		EnterRule_logicalANDExpressionNoIn();
		EnterRule("logicalANDExpressionNoIn", 39);
		TraceIn("logicalANDExpressionNoIn", 39);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LAND117 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseORExpressionNoIn116 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseORExpressionNoIn118 = default(AstParserRuleReturnScope<object, IToken>);

		object LAND117_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logicalANDExpressionNoIn");
		DebugLocation(866, 1);
		try
		{
			// TypeScript.g3:867:2: ( bitwiseORExpressionNoIn ( LAND ^ bitwiseORExpressionNoIn )* )
			DebugEnterAlt(1);
			// TypeScript.g3:867:4: bitwiseORExpressionNoIn ( LAND ^ bitwiseORExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(867, 4);
			PushFollow(Follow._bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn5425);
			bitwiseORExpressionNoIn116=bitwiseORExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseORExpressionNoIn116.Tree);
			DebugLocation(867, 28);
			// TypeScript.g3:867:28: ( LAND ^ bitwiseORExpressionNoIn )*
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				int LA34_1 = input.LA(1);

				if ((LA34_1==LAND))
				{
					alt34 = 1;
				}


				} finally { DebugExitDecision(34); }
				switch ( alt34 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:867:30: LAND ^ bitwiseORExpressionNoIn
					{
					DebugLocation(867, 34);
					LAND117=(IToken)Match(input,LAND,Follow._LAND_in_logicalANDExpressionNoIn5429); if (state.failed) return retval;
					if (state.backtracking == 0) {
					LAND117_tree = (object)adaptor.Create(LAND117);
					root_0 = (object)adaptor.BecomeRoot(LAND117_tree, root_0);
					}
					DebugLocation(867, 36);
					PushFollow(Follow._bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn5432);
					bitwiseORExpressionNoIn118=bitwiseORExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseORExpressionNoIn118.Tree);

					}
					break;

				default:
					goto loop34;
				}
			}

			loop34:
				;

			} finally { DebugExitSubRule(34); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalANDExpressionNoIn", 39);
			LeaveRule("logicalANDExpressionNoIn", 39);
			LeaveRule_logicalANDExpressionNoIn();
		}
		DebugLocation(868, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalANDExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "logicalANDExpressionNoIn"

	partial void EnterRule_logicalORExpression();
	partial void LeaveRule_logicalORExpression();
	// $ANTLR start "logicalORExpression"
	// TypeScript.g3:870:1: logicalORExpression : logicalANDExpression ( LOR ^ logicalANDExpression )* ;
	[GrammarRule("logicalORExpression")]
	private AstParserRuleReturnScope<object, IToken> logicalORExpression()
	{
		EnterRule_logicalORExpression();
		EnterRule("logicalORExpression", 40);
		TraceIn("logicalORExpression", 40);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LOR120 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logicalANDExpression119 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logicalANDExpression121 = default(AstParserRuleReturnScope<object, IToken>);

		object LOR120_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logicalORExpression");
		DebugLocation(870, 1);
		try
		{
			// TypeScript.g3:871:2: ( logicalANDExpression ( LOR ^ logicalANDExpression )* )
			DebugEnterAlt(1);
			// TypeScript.g3:871:4: logicalANDExpression ( LOR ^ logicalANDExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(871, 4);
			PushFollow(Follow._logicalANDExpression_in_logicalORExpression5447);
			logicalANDExpression119=logicalANDExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, logicalANDExpression119.Tree);
			DebugLocation(871, 25);
			// TypeScript.g3:871:25: ( LOR ^ logicalANDExpression )*
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=2;
				try { DebugEnterDecision(35, false);
				int LA35_1 = input.LA(1);

				if ((LA35_1==LOR))
				{
					alt35 = 1;
				}


				} finally { DebugExitDecision(35); }
				switch ( alt35 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:871:27: LOR ^ logicalANDExpression
					{
					DebugLocation(871, 30);
					LOR120=(IToken)Match(input,LOR,Follow._LOR_in_logicalORExpression5451); if (state.failed) return retval;
					if (state.backtracking == 0) {
					LOR120_tree = (object)adaptor.Create(LOR120);
					root_0 = (object)adaptor.BecomeRoot(LOR120_tree, root_0);
					}
					DebugLocation(871, 32);
					PushFollow(Follow._logicalANDExpression_in_logicalORExpression5454);
					logicalANDExpression121=logicalANDExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, logicalANDExpression121.Tree);

					}
					break;

				default:
					goto loop35;
				}
			}

			loop35:
				;

			} finally { DebugExitSubRule(35); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalORExpression", 40);
			LeaveRule("logicalORExpression", 40);
			LeaveRule_logicalORExpression();
		}
		DebugLocation(872, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalORExpression"); }
		return retval;

	}
	// $ANTLR end "logicalORExpression"

	partial void EnterRule_logicalORExpressionNoIn();
	partial void LeaveRule_logicalORExpressionNoIn();
	// $ANTLR start "logicalORExpressionNoIn"
	// TypeScript.g3:874:1: logicalORExpressionNoIn : logicalANDExpressionNoIn ( LOR ^ logicalANDExpressionNoIn )* ;
	[GrammarRule("logicalORExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> logicalORExpressionNoIn()
	{
		EnterRule_logicalORExpressionNoIn();
		EnterRule("logicalORExpressionNoIn", 41);
		TraceIn("logicalORExpressionNoIn", 41);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LOR123 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logicalANDExpressionNoIn122 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logicalANDExpressionNoIn124 = default(AstParserRuleReturnScope<object, IToken>);

		object LOR123_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logicalORExpressionNoIn");
		DebugLocation(874, 1);
		try
		{
			// TypeScript.g3:875:2: ( logicalANDExpressionNoIn ( LOR ^ logicalANDExpressionNoIn )* )
			DebugEnterAlt(1);
			// TypeScript.g3:875:4: logicalANDExpressionNoIn ( LOR ^ logicalANDExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(875, 4);
			PushFollow(Follow._logicalANDExpressionNoIn_in_logicalORExpressionNoIn5469);
			logicalANDExpressionNoIn122=logicalANDExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, logicalANDExpressionNoIn122.Tree);
			DebugLocation(875, 29);
			// TypeScript.g3:875:29: ( LOR ^ logicalANDExpressionNoIn )*
			try { DebugEnterSubRule(36);
			while (true)
			{
				int alt36=2;
				try { DebugEnterDecision(36, false);
				int LA36_1 = input.LA(1);

				if ((LA36_1==LOR))
				{
					alt36 = 1;
				}


				} finally { DebugExitDecision(36); }
				switch ( alt36 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:875:31: LOR ^ logicalANDExpressionNoIn
					{
					DebugLocation(875, 34);
					LOR123=(IToken)Match(input,LOR,Follow._LOR_in_logicalORExpressionNoIn5473); if (state.failed) return retval;
					if (state.backtracking == 0) {
					LOR123_tree = (object)adaptor.Create(LOR123);
					root_0 = (object)adaptor.BecomeRoot(LOR123_tree, root_0);
					}
					DebugLocation(875, 36);
					PushFollow(Follow._logicalANDExpressionNoIn_in_logicalORExpressionNoIn5476);
					logicalANDExpressionNoIn124=logicalANDExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, logicalANDExpressionNoIn124.Tree);

					}
					break;

				default:
					goto loop36;
				}
			}

			loop36:
				;

			} finally { DebugExitSubRule(36); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalORExpressionNoIn", 41);
			LeaveRule("logicalORExpressionNoIn", 41);
			LeaveRule_logicalORExpressionNoIn();
		}
		DebugLocation(876, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "logicalORExpressionNoIn"

	partial void EnterRule_conditionalExpression();
	partial void LeaveRule_conditionalExpression();
	// $ANTLR start "conditionalExpression"
	// TypeScript.g3:882:1: conditionalExpression : logicalORExpression ( QUE ^ assignmentExpression COLON ! assignmentExpression )? ;
	[GrammarRule("conditionalExpression")]
	private AstParserRuleReturnScope<object, IToken> conditionalExpression()
	{
		EnterRule_conditionalExpression();
		EnterRule("conditionalExpression", 42);
		TraceIn("conditionalExpression", 42);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken QUE126 = default(IToken);
		IToken COLON128 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logicalORExpression125 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression127 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression129 = default(AstParserRuleReturnScope<object, IToken>);

		object QUE126_tree = default(object);
		object COLON128_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "conditionalExpression");
		DebugLocation(882, 1);
		try
		{
			// TypeScript.g3:883:2: ( logicalORExpression ( QUE ^ assignmentExpression COLON ! assignmentExpression )? )
			DebugEnterAlt(1);
			// TypeScript.g3:883:4: logicalORExpression ( QUE ^ assignmentExpression COLON ! assignmentExpression )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(883, 4);
			PushFollow(Follow._logicalORExpression_in_conditionalExpression5495);
			logicalORExpression125=logicalORExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, logicalORExpression125.Tree);
			DebugLocation(883, 24);
			// TypeScript.g3:883:24: ( QUE ^ assignmentExpression COLON ! assignmentExpression )?
			int alt37=2;
			try { DebugEnterSubRule(37);
			try { DebugEnterDecision(37, false);
			int LA37_1 = input.LA(1);

			if ((LA37_1==QUE))
			{
				alt37 = 1;
			}
			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:883:26: QUE ^ assignmentExpression COLON ! assignmentExpression
				{
				DebugLocation(883, 29);
				QUE126=(IToken)Match(input,QUE,Follow._QUE_in_conditionalExpression5499); if (state.failed) return retval;
				if (state.backtracking == 0) {
				QUE126_tree = (object)adaptor.Create(QUE126);
				root_0 = (object)adaptor.BecomeRoot(QUE126_tree, root_0);
				}
				DebugLocation(883, 31);
				PushFollow(Follow._assignmentExpression_in_conditionalExpression5502);
				assignmentExpression127=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression127.Tree);
				DebugLocation(883, 57);
				COLON128=(IToken)Match(input,COLON,Follow._COLON_in_conditionalExpression5504); if (state.failed) return retval;
				DebugLocation(883, 59);
				PushFollow(Follow._assignmentExpression_in_conditionalExpression5507);
				assignmentExpression129=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression129.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(37); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalExpression", 42);
			LeaveRule("conditionalExpression", 42);
			LeaveRule_conditionalExpression();
		}
		DebugLocation(884, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpression"); }
		return retval;

	}
	// $ANTLR end "conditionalExpression"

	partial void EnterRule_conditionalExpressionNoIn();
	partial void LeaveRule_conditionalExpressionNoIn();
	// $ANTLR start "conditionalExpressionNoIn"
	// TypeScript.g3:886:1: conditionalExpressionNoIn : logicalORExpressionNoIn ( QUE ^ assignmentExpressionNoIn COLON ! assignmentExpressionNoIn )? ;
	[GrammarRule("conditionalExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> conditionalExpressionNoIn()
	{
		EnterRule_conditionalExpressionNoIn();
		EnterRule("conditionalExpressionNoIn", 43);
		TraceIn("conditionalExpressionNoIn", 43);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken QUE131 = default(IToken);
		IToken COLON133 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logicalORExpressionNoIn130 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn132 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn134 = default(AstParserRuleReturnScope<object, IToken>);

		object QUE131_tree = default(object);
		object COLON133_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "conditionalExpressionNoIn");
		DebugLocation(886, 1);
		try
		{
			// TypeScript.g3:887:2: ( logicalORExpressionNoIn ( QUE ^ assignmentExpressionNoIn COLON ! assignmentExpressionNoIn )? )
			DebugEnterAlt(1);
			// TypeScript.g3:887:4: logicalORExpressionNoIn ( QUE ^ assignmentExpressionNoIn COLON ! assignmentExpressionNoIn )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(887, 4);
			PushFollow(Follow._logicalORExpressionNoIn_in_conditionalExpressionNoIn5521);
			logicalORExpressionNoIn130=logicalORExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, logicalORExpressionNoIn130.Tree);
			DebugLocation(887, 28);
			// TypeScript.g3:887:28: ( QUE ^ assignmentExpressionNoIn COLON ! assignmentExpressionNoIn )?
			int alt38=2;
			try { DebugEnterSubRule(38);
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1==QUE))
			{
				alt38 = 1;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:887:30: QUE ^ assignmentExpressionNoIn COLON ! assignmentExpressionNoIn
				{
				DebugLocation(887, 33);
				QUE131=(IToken)Match(input,QUE,Follow._QUE_in_conditionalExpressionNoIn5525); if (state.failed) return retval;
				if (state.backtracking == 0) {
				QUE131_tree = (object)adaptor.Create(QUE131);
				root_0 = (object)adaptor.BecomeRoot(QUE131_tree, root_0);
				}
				DebugLocation(887, 35);
				PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn5528);
				assignmentExpressionNoIn132=assignmentExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn132.Tree);
				DebugLocation(887, 65);
				COLON133=(IToken)Match(input,COLON,Follow._COLON_in_conditionalExpressionNoIn5530); if (state.failed) return retval;
				DebugLocation(887, 67);
				PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn5533);
				assignmentExpressionNoIn134=assignmentExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn134.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(38); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalExpressionNoIn", 43);
			LeaveRule("conditionalExpressionNoIn", 43);
			LeaveRule_conditionalExpressionNoIn();
		}
		DebugLocation(888, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "conditionalExpressionNoIn"

	partial void EnterRule_assignmentExpression();
	partial void LeaveRule_assignmentExpression();
	// $ANTLR start "assignmentExpression"
	// TypeScript.g3:916:1: assignmentExpression options {backtrack=true; } : lhs= conditionalExpression ({...}? assignmentOperator ^ assignmentExpression )? ;
	[GrammarRule("assignmentExpression")]
	private AstParserRuleReturnScope<object, IToken> assignmentExpression()
	{
		EnterRule_assignmentExpression();
		EnterRule("assignmentExpression", 44);
		TraceIn("assignmentExpression", 44);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> lhs = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentOperator135 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression136 = default(AstParserRuleReturnScope<object, IToken>);


			bool? isLhs = null;

		try { DebugEnterRule(GrammarFileName, "assignmentExpression");
		DebugLocation(916, 1);
		try
		{
			// TypeScript.g3:925:2: (lhs= conditionalExpression ({...}? assignmentOperator ^ assignmentExpression )? )
			DebugEnterAlt(1);
			// TypeScript.g3:925:4: lhs= conditionalExpression ({...}? assignmentOperator ^ assignmentExpression )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(925, 7);
			PushFollow(Follow._conditionalExpression_in_assignmentExpression5574);
			lhs=conditionalExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, lhs.Tree);
			DebugLocation(926, 2);
			// TypeScript.g3:926:2: ({...}? assignmentOperator ^ assignmentExpression )?
			int alt39=2;
			try { DebugEnterSubRule(39);
			try { DebugEnterDecision(39, false);
			int LA39_1 = input.LA(1);

			if ((LA39_1==ADDASS||LA39_1==ANDASS||LA39_1==ASSIGN||LA39_1==DIVASS||LA39_1==MODASS||LA39_1==MULASS||LA39_1==ORASS||LA39_1==SHLASS||LA39_1==SHRASS||LA39_1==SHUASS||LA39_1==SUBASS||LA39_1==XORASS))
			{
				int LA39_2 = input.LA(2);

				if ((( IsLeftHandSideAssign(lhs, ref isLhs) )))
				{
					alt39 = 1;
				}
			}
			} finally { DebugExitDecision(39); }
			switch (alt39)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:926:4: {...}? assignmentOperator ^ assignmentExpression
				{
				DebugLocation(926, 4);
				if (!(( IsLeftHandSideAssign(lhs, ref isLhs) )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "assignmentExpression", " IsLeftHandSideAssign(lhs, ref isLhs) ");
				}
				DebugLocation(926, 64);
				PushFollow(Follow._assignmentOperator_in_assignmentExpression5581);
				assignmentOperator135=assignmentOperator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot(assignmentOperator135.Tree, root_0);
				DebugLocation(926, 66);
				PushFollow(Follow._assignmentExpression_in_assignmentExpression5584);
				assignmentExpression136=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression136.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(39); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentExpression", 44);
			LeaveRule("assignmentExpression", 44);
			LeaveRule_assignmentExpression();
		}
		DebugLocation(927, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpression"); }
		return retval;

	}
	// $ANTLR end "assignmentExpression"

	partial void EnterRule_assignmentOperator();
	partial void LeaveRule_assignmentOperator();
	// $ANTLR start "assignmentOperator"
	// TypeScript.g3:929:1: assignmentOperator : ( ASSIGN | MULASS | DIVASS | MODASS | ADDASS | SUBASS | SHLASS | SHRASS | SHUASS | ANDASS | XORASS | ORASS );
	[GrammarRule("assignmentOperator")]
	private AstParserRuleReturnScope<object, IToken> assignmentOperator()
	{
		EnterRule_assignmentOperator();
		EnterRule("assignmentOperator", 45);
		TraceIn("assignmentOperator", 45);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set137 = default(IToken);

		object set137_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "assignmentOperator");
		DebugLocation(929, 1);
		try
		{
			// TypeScript.g3:930:2: ( ASSIGN | MULASS | DIVASS | MODASS | ADDASS | SUBASS | SHLASS | SHRASS | SHUASS | ANDASS | XORASS | ORASS )
			DebugEnterAlt(1);
			// TypeScript.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(930, 2);

			set137=(IToken)input.LT(1);
			if (input.LA(1)==ADDASS||input.LA(1)==ANDASS||input.LA(1)==ASSIGN||input.LA(1)==DIVASS||input.LA(1)==MODASS||input.LA(1)==MULASS||input.LA(1)==ORASS||input.LA(1)==SHLASS||input.LA(1)==SHRASS||input.LA(1)==SHUASS||input.LA(1)==SUBASS||input.LA(1)==XORASS)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set137));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentOperator", 45);
			LeaveRule("assignmentOperator", 45);
			LeaveRule_assignmentOperator();
		}
		DebugLocation(931, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentOperator"); }
		return retval;

	}
	// $ANTLR end "assignmentOperator"

	partial void EnterRule_assignmentExpressionNoIn();
	partial void LeaveRule_assignmentExpressionNoIn();
	// $ANTLR start "assignmentExpressionNoIn"
	// TypeScript.g3:933:1: assignmentExpressionNoIn : lhs= conditionalExpressionNoIn ({...}? assignmentOperator ^ assignmentExpressionNoIn )? ;
	[GrammarRule("assignmentExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn()
	{
		EnterRule_assignmentExpressionNoIn();
		EnterRule("assignmentExpressionNoIn", 46);
		TraceIn("assignmentExpressionNoIn", 46);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> lhs = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentOperator138 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn139 = default(AstParserRuleReturnScope<object, IToken>);


			bool? isLhs = null;

		try { DebugEnterRule(GrammarFileName, "assignmentExpressionNoIn");
		DebugLocation(933, 1);
		try
		{
			// TypeScript.g3:938:2: (lhs= conditionalExpressionNoIn ({...}? assignmentOperator ^ assignmentExpressionNoIn )? )
			DebugEnterAlt(1);
			// TypeScript.g3:938:4: lhs= conditionalExpressionNoIn ({...}? assignmentOperator ^ assignmentExpressionNoIn )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(938, 7);
			PushFollow(Follow._conditionalExpressionNoIn_in_assignmentExpressionNoIn5661);
			lhs=conditionalExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, lhs.Tree);
			DebugLocation(939, 2);
			// TypeScript.g3:939:2: ({...}? assignmentOperator ^ assignmentExpressionNoIn )?
			int alt40=2;
			try { DebugEnterSubRule(40);
			try { DebugEnterDecision(40, false);
			int LA40_1 = input.LA(1);

			if ((LA40_1==ADDASS||LA40_1==ANDASS||LA40_1==ASSIGN||LA40_1==DIVASS||LA40_1==MODASS||LA40_1==MULASS||LA40_1==ORASS||LA40_1==SHLASS||LA40_1==SHRASS||LA40_1==SHUASS||LA40_1==SUBASS||LA40_1==XORASS))
			{
				int LA40_2 = input.LA(2);

				if ((( IsLeftHandSideAssign(lhs, ref isLhs) )))
				{
					alt40 = 1;
				}
			}
			} finally { DebugExitDecision(40); }
			switch (alt40)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:939:4: {...}? assignmentOperator ^ assignmentExpressionNoIn
				{
				DebugLocation(939, 4);
				if (!(( IsLeftHandSideAssign(lhs, ref isLhs) )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "assignmentExpressionNoIn", " IsLeftHandSideAssign(lhs, ref isLhs) ");
				}
				DebugLocation(939, 64);
				PushFollow(Follow._assignmentOperator_in_assignmentExpressionNoIn5668);
				assignmentOperator138=assignmentOperator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot(assignmentOperator138.Tree, root_0);
				DebugLocation(939, 66);
				PushFollow(Follow._assignmentExpressionNoIn_in_assignmentExpressionNoIn5671);
				assignmentExpressionNoIn139=assignmentExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn139.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(40); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentExpressionNoIn", 46);
			LeaveRule("assignmentExpressionNoIn", 46);
			LeaveRule_assignmentExpressionNoIn();
		}
		DebugLocation(940, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "assignmentExpressionNoIn"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// TypeScript.g3:946:8: public expression :exprs+= assignmentExpression ( COMMA exprs+= assignmentExpression )* -> { $exprs.Count > 1 }? ^( CEXPR ( $exprs)+ ) -> $exprs;
	[GrammarRule("expression")]
	public AstParserRuleReturnScope<object, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 47);
		TraceIn("expression", 47);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA140 = default(IToken);
		List<object> list_exprs = null;
		AstParserRuleReturnScope<object, IToken> exprs = default(AstParserRuleReturnScope<object, IToken>);
		object COMMA140_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(946, 1);
		try
		{
			// TypeScript.g3:947:2: (exprs+= assignmentExpression ( COMMA exprs+= assignmentExpression )* -> { $exprs.Count > 1 }? ^( CEXPR ( $exprs)+ ) -> $exprs)
			DebugEnterAlt(1);
			// TypeScript.g3:947:4: exprs+= assignmentExpression ( COMMA exprs+= assignmentExpression )*
			{
			DebugLocation(947, 9);
			PushFollow(Follow._assignmentExpression_in_expression5695);
			exprs=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(exprs.Tree);
			if (list_exprs==null) list_exprs=new List<object>();
			list_exprs.Add(exprs.Tree);

			DebugLocation(947, 32);
			// TypeScript.g3:947:32: ( COMMA exprs+= assignmentExpression )*
			try { DebugEnterSubRule(41);
			while (true)
			{
				int alt41=2;
				try { DebugEnterDecision(41, false);
				int LA41_1 = input.LA(1);

				if ((LA41_1==COMMA))
				{
					alt41 = 1;
				}


				} finally { DebugExitDecision(41); }
				switch ( alt41 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:947:34: COMMA exprs+= assignmentExpression
					{
					DebugLocation(947, 34);
					COMMA140=(IToken)Match(input,COMMA,Follow._COMMA_in_expression5699); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA140);

					DebugLocation(947, 45);
					PushFollow(Follow._assignmentExpression_in_expression5703);
					exprs=assignmentExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_assignmentExpression.Add(exprs.Tree);
					if (list_exprs==null) list_exprs=new List<object>();
					list_exprs.Add(exprs.Tree);


					}
					break;

				default:
					goto loop41;
				}
			}

			loop41:
				;

			} finally { DebugExitSubRule(41); }



			{
			// AST REWRITE
			// elements: exprs, exprs
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: exprs
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_exprs=new RewriteRuleSubtreeStream(adaptor,"token exprs",list_exprs);
			root_0 = (object)adaptor.Nil();
			// 948:2: -> { $exprs.Count > 1 }? ^( CEXPR ( $exprs)+ )
			if ( list_exprs.Count > 1 )
			{
				DebugLocation(948, 27);
				// TypeScript.g3:948:27: ^( CEXPR ( $exprs)+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(948, 30);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CEXPR, "CEXPR"), root_1);

				DebugLocation(948, 37);
				if (!(stream_exprs.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_exprs.HasNext )
				{
					DebugLocation(948, 37);
					adaptor.AddChild(root_1, stream_exprs.NextTree());

				}
				stream_exprs.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 949:2: -> $exprs
			{
				DebugLocation(949, 6);
				adaptor.AddChild(root_0, stream_exprs.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 47);
			LeaveRule("expression", 47);
			LeaveRule_expression();
		}
		DebugLocation(950, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_expressionNoIn();
	partial void LeaveRule_expressionNoIn();
	// $ANTLR start "expressionNoIn"
	// TypeScript.g3:952:1: expressionNoIn :exprs+= assignmentExpressionNoIn ( COMMA exprs+= assignmentExpressionNoIn )* -> { $exprs.Count > 1 }? ^( CEXPR ( $exprs)+ ) -> $exprs;
	[GrammarRule("expressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> expressionNoIn()
	{
		EnterRule_expressionNoIn();
		EnterRule("expressionNoIn", 48);
		TraceIn("expressionNoIn", 48);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA141 = default(IToken);
		List<object> list_exprs = null;
		AstParserRuleReturnScope<object, IToken> exprs = default(AstParserRuleReturnScope<object, IToken>);
		object COMMA141_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_assignmentExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "expressionNoIn");
		DebugLocation(952, 1);
		try
		{
			// TypeScript.g3:953:2: (exprs+= assignmentExpressionNoIn ( COMMA exprs+= assignmentExpressionNoIn )* -> { $exprs.Count > 1 }? ^( CEXPR ( $exprs)+ ) -> $exprs)
			DebugEnterAlt(1);
			// TypeScript.g3:953:4: exprs+= assignmentExpressionNoIn ( COMMA exprs+= assignmentExpressionNoIn )*
			{
			DebugLocation(953, 9);
			PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn5740);
			exprs=assignmentExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(exprs.Tree);
			if (list_exprs==null) list_exprs=new List<object>();
			list_exprs.Add(exprs.Tree);

			DebugLocation(953, 36);
			// TypeScript.g3:953:36: ( COMMA exprs+= assignmentExpressionNoIn )*
			try { DebugEnterSubRule(42);
			while (true)
			{
				int alt42=2;
				try { DebugEnterDecision(42, false);
				int LA42_1 = input.LA(1);

				if ((LA42_1==COMMA))
				{
					alt42 = 1;
				}


				} finally { DebugExitDecision(42); }
				switch ( alt42 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:953:38: COMMA exprs+= assignmentExpressionNoIn
					{
					DebugLocation(953, 38);
					COMMA141=(IToken)Match(input,COMMA,Follow._COMMA_in_expressionNoIn5744); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA141);

					DebugLocation(953, 49);
					PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn5748);
					exprs=assignmentExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(exprs.Tree);
					if (list_exprs==null) list_exprs=new List<object>();
					list_exprs.Add(exprs.Tree);


					}
					break;

				default:
					goto loop42;
				}
			}

			loop42:
				;

			} finally { DebugExitSubRule(42); }



			{
			// AST REWRITE
			// elements: exprs, exprs
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: exprs
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_exprs=new RewriteRuleSubtreeStream(adaptor,"token exprs",list_exprs);
			root_0 = (object)adaptor.Nil();
			// 954:2: -> { $exprs.Count > 1 }? ^( CEXPR ( $exprs)+ )
			if ( list_exprs.Count > 1 )
			{
				DebugLocation(954, 27);
				// TypeScript.g3:954:27: ^( CEXPR ( $exprs)+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(954, 30);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CEXPR, "CEXPR"), root_1);

				DebugLocation(954, 37);
				if (!(stream_exprs.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_exprs.HasNext )
				{
					DebugLocation(954, 37);
					adaptor.AddChild(root_1, stream_exprs.NextTree());

				}
				stream_exprs.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 955:2: -> $exprs
			{
				DebugLocation(955, 6);
				adaptor.AddChild(root_0, stream_exprs.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionNoIn", 48);
			LeaveRule("expressionNoIn", 48);
			LeaveRule_expressionNoIn();
		}
		DebugLocation(956, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionNoIn"); }
		return retval;

	}
	// $ANTLR end "expressionNoIn"

	partial void EnterRule_semic();
	partial void LeaveRule_semic();
	// $ANTLR start "semic"
	// TypeScript.g3:980:1: semic : ( SEMIC | EOF | RBRACE | EOL | MultiLineComment );
	[GrammarRule("semic")]
	private AstParserRuleReturnScope<object, IToken> semic()
	{
		EnterRule_semic();
		EnterRule("semic", 49);
		TraceIn("semic", 49);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMIC142 = default(IToken);
		IToken EOF143 = default(IToken);
		IToken RBRACE144 = default(IToken);
		IToken EOL145 = default(IToken);
		IToken MultiLineComment146 = default(IToken);

		object SEMIC142_tree = default(object);
		object EOF143_tree = default(object);
		object RBRACE144_tree = default(object);
		object EOL145_tree = default(object);
		object MultiLineComment146_tree = default(object);

			// Mark current position so we can unconsume a RBRACE.
			int marker = input.Mark();
			// Promote EOL if appropriate	
			PromoteEOL(retval);

		try { DebugEnterRule(GrammarFileName, "semic");
		DebugLocation(980, 1);
		try
		{
			// TypeScript.g3:988:2: ( SEMIC | EOF | RBRACE | EOL | MultiLineComment )
			int alt43=5;
			try { DebugEnterDecision(43, false);
			switch (input.LA(1))
			{
			case SEMIC:
				{
				alt43 = 1;
				}
				break;
			case EOF:
				{
				alt43 = 2;
				}
				break;
			case RBRACE:
				{
				alt43 = 3;
				}
				break;
			case EOL:
				{
				alt43 = 4;
				}
				break;
			case MultiLineComment:
				{
				alt43 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 43, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(43); }
			switch (alt43)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:988:4: SEMIC
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(988, 4);
				SEMIC142=(IToken)Match(input,SEMIC,Follow._SEMIC_in_semic5799); if (state.failed) return retval;
				if (state.backtracking == 0) {
				SEMIC142_tree = (object)adaptor.Create(SEMIC142);
				adaptor.AddChild(root_0, SEMIC142_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:989:4: EOF
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(989, 4);
				EOF143=(IToken)Match(input,EOF,Follow._EOF_in_semic5804); if (state.failed) return retval;
				if (state.backtracking == 0) {
				EOF143_tree = (object)adaptor.Create(EOF143);
				adaptor.AddChild(root_0, EOF143_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:990:4: RBRACE
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(990, 4);
				RBRACE144=(IToken)Match(input,RBRACE,Follow._RBRACE_in_semic5809); if (state.failed) return retval;
				if (state.backtracking == 0) {
				RBRACE144_tree = (object)adaptor.Create(RBRACE144);
				adaptor.AddChild(root_0, RBRACE144_tree);
				}
				DebugLocation(990, 11);
				if (state.backtracking == 0)
				{
					 input.Rewind(marker); 
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:991:4: EOL
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(991, 4);
				EOL145=(IToken)Match(input,EOL,Follow._EOL_in_semic5816); if (state.failed) return retval;
				if (state.backtracking == 0) {
				EOL145_tree = (object)adaptor.Create(EOL145);
				adaptor.AddChild(root_0, EOL145_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:991:10: MultiLineComment
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(991, 10);
				MultiLineComment146=(IToken)Match(input,MultiLineComment,Follow._MultiLineComment_in_semic5820); if (state.failed) return retval;
				if (state.backtracking == 0) {
				MultiLineComment146_tree = (object)adaptor.Create(MultiLineComment146);
				adaptor.AddChild(root_0, MultiLineComment146_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("semic", 49);
			LeaveRule("semic", 49);
			LeaveRule_semic();
		}
		DebugLocation(992, 1);
		} finally { DebugExitRule(GrammarFileName, "semic"); }
		return retval;

	}
	// $ANTLR end "semic"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// TypeScript.g3:999:1: statement options {k=1; } : ({...}? block | statementTail );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<object, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 50);
		TraceIn("statement", 50);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> block147 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statementTail148 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(999, 1);
		try
		{
			// TypeScript.g3:1004:2: ({...}? block | statementTail )
			int alt44=2;
			try { DebugEnterDecision(44, false);
			int LA44_1 = input.LA(1);

			if ((LA44_1==LBRACE))
			{
				int LA44_2 = input.LA(2);

				if ((( input.LA(1) == LBRACE )))
				{
					alt44 = 1;
				}
				else if ((true))
				{
					alt44 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 44, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA44_1==ADD||LA44_1==ANY||LA44_1==BREAK||LA44_1==CONSTRUCTOR||LA44_1==CONTINUE||(LA44_1>=DEC && LA44_1<=DECLARE)||LA44_1==DELETE||LA44_1==DO||LA44_1==DecimalLiteral||LA44_1==FALSE||LA44_1==FINAL||LA44_1==FOR||LA44_1==FUNCTION||LA44_1==GET||(LA44_1>=HexIntegerLiteral && LA44_1<=IF)||LA44_1==INC||LA44_1==INV||LA44_1==Identifier||LA44_1==LBRACK||LA44_1==LPAREN||LA44_1==MODULE||(LA44_1>=NEW && LA44_1<=NOT)||(LA44_1>=NULL && LA44_1<=NUMBER)||LA44_1==OctalIntegerLiteral||(LA44_1>=REQUIRE && LA44_1<=RETURN)||LA44_1==RegularExpressionLiteral||(LA44_1>=SEMIC && LA44_1<=SET)||(LA44_1>=STRING && LA44_1<=SUB)||LA44_1==SWITCH||LA44_1==StringLiteral||(LA44_1>=THIS && LA44_1<=THROWS)||(LA44_1>=TRUE && LA44_1<=TRY)||(LA44_1>=TYPE && LA44_1<=TYPEOF)||LA44_1==VAR||LA44_1==VOID||(LA44_1>=WHILE && LA44_1<=WITH)))
			{
				alt44 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 44, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(44); }
			switch (alt44)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1004:4: {...}? block
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1004, 4);
				if (!(( input.LA(1) == LBRACE )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "statement", " input.LA(1) == LBRACE ");
				}
				DebugLocation(1004, 31);
				PushFollow(Follow._block_in_statement5849);
				block147=block();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, block147.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1005:4: statementTail
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1005, 4);
				PushFollow(Follow._statementTail_in_statement5854);
				statementTail148=statementTail();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statementTail148.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 50);
			LeaveRule("statement", 50);
			LeaveRule_statement();
		}
		DebugLocation(1006, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_statementTail();
	partial void LeaveRule_statementTail();
	// $ANTLR start "statementTail"
	// TypeScript.g3:1008:1: statementTail : ( variableStatement | emptyStatement | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement );
	[GrammarRule("statementTail")]
	private AstParserRuleReturnScope<object, IToken> statementTail()
	{
		EnterRule_statementTail();
		EnterRule("statementTail", 51);
		TraceIn("statementTail", 51);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> variableStatement149 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> emptyStatement150 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expressionStatement151 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ifStatement152 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> iterationStatement153 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> continueStatement154 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> breakStatement155 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> returnStatement156 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> withStatement157 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> labelledStatement158 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> switchStatement159 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> throwStatement160 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> tryStatement161 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "statementTail");
		DebugLocation(1008, 1);
		try
		{
			// TypeScript.g3:1009:2: ( variableStatement | emptyStatement | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement )
			int alt45=13;
			try { DebugEnterDecision(45, false);
			try
			{
				alt45 = dfa45.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1009:4: variableStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1009, 4);
				PushFollow(Follow._variableStatement_in_statementTail5866);
				variableStatement149=variableStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableStatement149.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1010:4: emptyStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1010, 4);
				PushFollow(Follow._emptyStatement_in_statementTail5871);
				emptyStatement150=emptyStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, emptyStatement150.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:1011:4: expressionStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1011, 4);
				PushFollow(Follow._expressionStatement_in_statementTail5876);
				expressionStatement151=expressionStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expressionStatement151.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:1012:4: ifStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1012, 4);
				PushFollow(Follow._ifStatement_in_statementTail5881);
				ifStatement152=ifStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifStatement152.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:1013:4: iterationStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1013, 4);
				PushFollow(Follow._iterationStatement_in_statementTail5886);
				iterationStatement153=iterationStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, iterationStatement153.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScript.g3:1014:4: continueStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1014, 4);
				PushFollow(Follow._continueStatement_in_statementTail5891);
				continueStatement154=continueStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, continueStatement154.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// TypeScript.g3:1015:4: breakStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1015, 4);
				PushFollow(Follow._breakStatement_in_statementTail5896);
				breakStatement155=breakStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, breakStatement155.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// TypeScript.g3:1016:4: returnStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1016, 4);
				PushFollow(Follow._returnStatement_in_statementTail5901);
				returnStatement156=returnStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, returnStatement156.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// TypeScript.g3:1017:4: withStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1017, 4);
				PushFollow(Follow._withStatement_in_statementTail5906);
				withStatement157=withStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, withStatement157.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// TypeScript.g3:1018:4: labelledStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1018, 4);
				PushFollow(Follow._labelledStatement_in_statementTail5911);
				labelledStatement158=labelledStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, labelledStatement158.Tree);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// TypeScript.g3:1019:4: switchStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1019, 4);
				PushFollow(Follow._switchStatement_in_statementTail5916);
				switchStatement159=switchStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, switchStatement159.Tree);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// TypeScript.g3:1020:4: throwStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1020, 4);
				PushFollow(Follow._throwStatement_in_statementTail5921);
				throwStatement160=throwStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, throwStatement160.Tree);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// TypeScript.g3:1021:4: tryStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1021, 4);
				PushFollow(Follow._tryStatement_in_statementTail5926);
				tryStatement161=tryStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, tryStatement161.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statementTail", 51);
			LeaveRule("statementTail", 51);
			LeaveRule_statementTail();
		}
		DebugLocation(1022, 1);
		} finally { DebugExitRule(GrammarFileName, "statementTail"); }
		return retval;

	}
	// $ANTLR end "statementTail"

	partial void EnterRule_block();
	partial void LeaveRule_block();
	// $ANTLR start "block"
	// TypeScript.g3:1026:1: block : lb= LBRACE ( statement )* RBRACE -> ^( BLOCK[$lb, \"BLOCK\"] ( statement )* ) ;
	[GrammarRule("block")]
	private AstParserRuleReturnScope<object, IToken> block()
	{
		EnterRule_block();
		EnterRule("block", 52);
		TraceIn("block", 52);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken lb = default(IToken);
		IToken RBRACE163 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement162 = default(AstParserRuleReturnScope<object, IToken>);

		object lb_tree = default(object);
		object RBRACE163_tree = default(object);
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(1026, 1);
		try
		{
			// TypeScript.g3:1027:2: (lb= LBRACE ( statement )* RBRACE -> ^( BLOCK[$lb, \"BLOCK\"] ( statement )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1027:4: lb= LBRACE ( statement )* RBRACE
			{
			DebugLocation(1027, 6);
			lb=(IToken)Match(input,LBRACE,Follow._LBRACE_in_block5941); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACE.Add(lb);

			DebugLocation(1027, 14);
			// TypeScript.g3:1027:14: ( statement )*
			try { DebugEnterSubRule(46);
			while (true)
			{
				int alt46=2;
				try { DebugEnterDecision(46, false);
				int LA46_1 = input.LA(1);

				if ((LA46_1==ADD||LA46_1==ANY||LA46_1==BREAK||LA46_1==CONSTRUCTOR||LA46_1==CONTINUE||(LA46_1>=DEC && LA46_1<=DECLARE)||LA46_1==DELETE||LA46_1==DO||LA46_1==DecimalLiteral||LA46_1==FALSE||LA46_1==FINAL||LA46_1==FOR||LA46_1==FUNCTION||LA46_1==GET||(LA46_1>=HexIntegerLiteral && LA46_1<=IF)||LA46_1==INC||LA46_1==INV||LA46_1==Identifier||(LA46_1>=LBRACE && LA46_1<=LBRACK)||LA46_1==LPAREN||LA46_1==MODULE||(LA46_1>=NEW && LA46_1<=NOT)||(LA46_1>=NULL && LA46_1<=NUMBER)||LA46_1==OctalIntegerLiteral||(LA46_1>=REQUIRE && LA46_1<=RETURN)||LA46_1==RegularExpressionLiteral||(LA46_1>=SEMIC && LA46_1<=SET)||(LA46_1>=STRING && LA46_1<=SUB)||LA46_1==SWITCH||LA46_1==StringLiteral||(LA46_1>=THIS && LA46_1<=THROWS)||(LA46_1>=TRUE && LA46_1<=TRY)||(LA46_1>=TYPE && LA46_1<=TYPEOF)||LA46_1==VAR||LA46_1==VOID||(LA46_1>=WHILE && LA46_1<=WITH)))
				{
					alt46 = 1;
				}


				} finally { DebugExitDecision(46); }
				switch ( alt46 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1027:14: statement
					{
					DebugLocation(1027, 14);
					PushFollow(Follow._statement_in_block5943);
					statement162=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement162.Tree);

					}
					break;

				default:
					goto loop46;
				}
			}

			loop46:
				;

			} finally { DebugExitSubRule(46); }

			DebugLocation(1027, 25);
			RBRACE163=(IToken)Match(input,RBRACE,Follow._RBRACE_in_block5946); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACE.Add(RBRACE163);



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1028:2: -> ^( BLOCK[$lb, \"BLOCK\"] ( statement )* )
			{
				DebugLocation(1028, 5);
				// TypeScript.g3:1028:5: ^( BLOCK[$lb, \"BLOCK\"] ( statement )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1028, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BLOCK, lb, "BLOCK"), root_1);

				DebugLocation(1028, 28);
				// TypeScript.g3:1028:28: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(1028, 28);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("block", 52);
			LeaveRule("block", 52);
			LeaveRule_block();
		}
		DebugLocation(1029, 1);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return retval;

	}
	// $ANTLR end "block"

	partial void EnterRule_variableStatement();
	partial void LeaveRule_variableStatement();
	// $ANTLR start "variableStatement"
	// TypeScript.g3:1035:1: variableStatement : VAR variableDeclaration ( COMMA variableDeclaration )* semic -> ^( VAR ( variableDeclaration )+ ) ;
	[GrammarRule("variableStatement")]
	private AstParserRuleReturnScope<object, IToken> variableStatement()
	{
		EnterRule_variableStatement();
		EnterRule("variableStatement", 53);
		TraceIn("variableStatement", 53);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken VAR164 = default(IToken);
		IToken COMMA166 = default(IToken);
		AstParserRuleReturnScope<object, IToken> variableDeclaration165 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableDeclaration167 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic168 = default(AstParserRuleReturnScope<object, IToken>);

		object VAR164_tree = default(object);
		object COMMA166_tree = default(object);
		RewriteRuleITokenStream stream_VAR=new RewriteRuleITokenStream(adaptor,"token VAR");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_variableDeclaration=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclaration");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		try { DebugEnterRule(GrammarFileName, "variableStatement");
		DebugLocation(1035, 1);
		try
		{
			// TypeScript.g3:1036:2: ( VAR variableDeclaration ( COMMA variableDeclaration )* semic -> ^( VAR ( variableDeclaration )+ ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1036:4: VAR variableDeclaration ( COMMA variableDeclaration )* semic
			{
			DebugLocation(1036, 4);
			VAR164=(IToken)Match(input,VAR,Follow._VAR_in_variableStatement5975); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_VAR.Add(VAR164);

			DebugLocation(1036, 8);
			PushFollow(Follow._variableDeclaration_in_variableStatement5977);
			variableDeclaration165=variableDeclaration();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclaration.Add(variableDeclaration165.Tree);
			DebugLocation(1036, 28);
			// TypeScript.g3:1036:28: ( COMMA variableDeclaration )*
			try { DebugEnterSubRule(47);
			while (true)
			{
				int alt47=2;
				try { DebugEnterDecision(47, false);
				int LA47_1 = input.LA(1);

				if ((LA47_1==COMMA))
				{
					alt47 = 1;
				}


				} finally { DebugExitDecision(47); }
				switch ( alt47 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1036:30: COMMA variableDeclaration
					{
					DebugLocation(1036, 30);
					COMMA166=(IToken)Match(input,COMMA,Follow._COMMA_in_variableStatement5981); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA166);

					DebugLocation(1036, 36);
					PushFollow(Follow._variableDeclaration_in_variableStatement5983);
					variableDeclaration167=variableDeclaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_variableDeclaration.Add(variableDeclaration167.Tree);

					}
					break;

				default:
					goto loop47;
				}
			}

			loop47:
				;

			} finally { DebugExitSubRule(47); }

			DebugLocation(1036, 59);
			PushFollow(Follow._semic_in_variableStatement5988);
			semic168=semic();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semic.Add(semic168.Tree);


			{
			// AST REWRITE
			// elements: VAR, variableDeclaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1037:2: -> ^( VAR ( variableDeclaration )+ )
			{
				DebugLocation(1037, 5);
				// TypeScript.g3:1037:5: ^( VAR ( variableDeclaration )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1037, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_VAR.NextNode(), root_1);

				DebugLocation(1037, 12);
				if (!(stream_variableDeclaration.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_variableDeclaration.HasNext )
				{
					DebugLocation(1037, 12);
					adaptor.AddChild(root_1, stream_variableDeclaration.NextTree());

				}
				stream_variableDeclaration.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableStatement", 53);
			LeaveRule("variableStatement", 53);
			LeaveRule_variableStatement();
		}
		DebugLocation(1038, 1);
		} finally { DebugExitRule(GrammarFileName, "variableStatement"); }
		return retval;

	}
	// $ANTLR end "variableStatement"

	partial void EnterRule_variableDeclaration();
	partial void LeaveRule_variableDeclaration();
	// $ANTLR start "variableDeclaration"
	// TypeScript.g3:1040:1: variableDeclaration : identifier ( typeAnnotation )? ( ASSIGN assignmentExpression )? ;
	[GrammarRule("variableDeclaration")]
	private AstParserRuleReturnScope<object, IToken> variableDeclaration()
	{
		EnterRule_variableDeclaration();
		EnterRule("variableDeclaration", 54);
		TraceIn("variableDeclaration", 54);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASSIGN171 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier169 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation170 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression172 = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN171_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "variableDeclaration");
		DebugLocation(1040, 1);
		try
		{
			// TypeScript.g3:1041:2: ( identifier ( typeAnnotation )? ( ASSIGN assignmentExpression )? )
			DebugEnterAlt(1);
			// TypeScript.g3:1041:4: identifier ( typeAnnotation )? ( ASSIGN assignmentExpression )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1041, 4);
			PushFollow(Follow._identifier_in_variableDeclaration6011);
			identifier169=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, identifier169.Tree);
			DebugLocation(1041, 15);
			// TypeScript.g3:1041:15: ( typeAnnotation )?
			int alt48=2;
			try { DebugEnterSubRule(48);
			try { DebugEnterDecision(48, false);
			int LA48_1 = input.LA(1);

			if ((LA48_1==COLON))
			{
				alt48 = 1;
			}
			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1041:15: typeAnnotation
				{
				DebugLocation(1041, 15);
				PushFollow(Follow._typeAnnotation_in_variableDeclaration6013);
				typeAnnotation170=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, typeAnnotation170.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(48); }

			DebugLocation(1041, 31);
			// TypeScript.g3:1041:31: ( ASSIGN assignmentExpression )?
			int alt49=2;
			try { DebugEnterSubRule(49);
			try { DebugEnterDecision(49, false);
			int LA49_1 = input.LA(1);

			if ((LA49_1==ASSIGN))
			{
				alt49 = 1;
			}
			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1041:33: ASSIGN assignmentExpression
				{
				DebugLocation(1041, 33);
				ASSIGN171=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_variableDeclaration6018); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ASSIGN171_tree = (object)adaptor.Create(ASSIGN171);
				adaptor.AddChild(root_0, ASSIGN171_tree);
				}
				DebugLocation(1041, 40);
				PushFollow(Follow._assignmentExpression_in_variableDeclaration6020);
				assignmentExpression172=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression172.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(49); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclaration", 54);
			LeaveRule("variableDeclaration", 54);
			LeaveRule_variableDeclaration();
		}
		DebugLocation(1042, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclaration"); }
		return retval;

	}
	// $ANTLR end "variableDeclaration"

	partial void EnterRule_variableDeclarationNoIn();
	partial void LeaveRule_variableDeclarationNoIn();
	// $ANTLR start "variableDeclarationNoIn"
	// TypeScript.g3:1044:1: variableDeclarationNoIn : identifier ( typeAnnotation )? ( ASSIGN assignmentExpressionNoIn )? ;
	[GrammarRule("variableDeclarationNoIn")]
	private AstParserRuleReturnScope<object, IToken> variableDeclarationNoIn()
	{
		EnterRule_variableDeclarationNoIn();
		EnterRule("variableDeclarationNoIn", 55);
		TraceIn("variableDeclarationNoIn", 55);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASSIGN175 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier173 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation174 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn176 = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN175_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "variableDeclarationNoIn");
		DebugLocation(1044, 1);
		try
		{
			// TypeScript.g3:1045:2: ( identifier ( typeAnnotation )? ( ASSIGN assignmentExpressionNoIn )? )
			DebugEnterAlt(1);
			// TypeScript.g3:1045:4: identifier ( typeAnnotation )? ( ASSIGN assignmentExpressionNoIn )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1045, 4);
			PushFollow(Follow._identifier_in_variableDeclarationNoIn6035);
			identifier173=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, identifier173.Tree);
			DebugLocation(1045, 15);
			// TypeScript.g3:1045:15: ( typeAnnotation )?
			int alt50=2;
			try { DebugEnterSubRule(50);
			try { DebugEnterDecision(50, false);
			int LA50_1 = input.LA(1);

			if ((LA50_1==COLON))
			{
				alt50 = 1;
			}
			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1045:15: typeAnnotation
				{
				DebugLocation(1045, 15);
				PushFollow(Follow._typeAnnotation_in_variableDeclarationNoIn6037);
				typeAnnotation174=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, typeAnnotation174.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(50); }

			DebugLocation(1045, 31);
			// TypeScript.g3:1045:31: ( ASSIGN assignmentExpressionNoIn )?
			int alt51=2;
			try { DebugEnterSubRule(51);
			try { DebugEnterDecision(51, false);
			int LA51_1 = input.LA(1);

			if ((LA51_1==ASSIGN))
			{
				alt51 = 1;
			}
			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1045:33: ASSIGN assignmentExpressionNoIn
				{
				DebugLocation(1045, 33);
				ASSIGN175=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_variableDeclarationNoIn6042); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ASSIGN175_tree = (object)adaptor.Create(ASSIGN175);
				adaptor.AddChild(root_0, ASSIGN175_tree);
				}
				DebugLocation(1045, 40);
				PushFollow(Follow._assignmentExpressionNoIn_in_variableDeclarationNoIn6044);
				assignmentExpressionNoIn176=assignmentExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn176.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(51); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarationNoIn", 55);
			LeaveRule("variableDeclarationNoIn", 55);
			LeaveRule_variableDeclarationNoIn();
		}
		DebugLocation(1046, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationNoIn"); }
		return retval;

	}
	// $ANTLR end "variableDeclarationNoIn"

	partial void EnterRule_emptyStatement();
	partial void LeaveRule_emptyStatement();
	// $ANTLR start "emptyStatement"
	// TypeScript.g3:1052:1: emptyStatement : SEMIC ;
	[GrammarRule("emptyStatement")]
	private AstParserRuleReturnScope<object, IToken> emptyStatement()
	{
		EnterRule_emptyStatement();
		EnterRule("emptyStatement", 56);
		TraceIn("emptyStatement", 56);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMIC177 = default(IToken);

		object SEMIC177_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "emptyStatement");
		DebugLocation(1052, 1);
		try
		{
			// TypeScript.g3:1053:2: ( SEMIC )
			DebugEnterAlt(1);
			// TypeScript.g3:1053:4: SEMIC
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1053, 4);
			SEMIC177=(IToken)Match(input,SEMIC,Follow._SEMIC_in_emptyStatement6063); if (state.failed) return retval;
			if (state.backtracking == 0) {
			SEMIC177_tree = (object)adaptor.Create(SEMIC177);
			adaptor.AddChild(root_0, SEMIC177_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("emptyStatement", 56);
			LeaveRule("emptyStatement", 56);
			LeaveRule_emptyStatement();
		}
		DebugLocation(1054, 1);
		} finally { DebugExitRule(GrammarFileName, "emptyStatement"); }
		return retval;

	}
	// $ANTLR end "emptyStatement"

	partial void EnterRule_expressionStatement();
	partial void LeaveRule_expressionStatement();
	// $ANTLR start "expressionStatement"
	// TypeScript.g3:1066:1: expressionStatement : expression semic !;
	[GrammarRule("expressionStatement")]
	private AstParserRuleReturnScope<object, IToken> expressionStatement()
	{
		EnterRule_expressionStatement();
		EnterRule("expressionStatement", 57);
		TraceIn("expressionStatement", 57);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> expression178 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic179 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "expressionStatement");
		DebugLocation(1066, 1);
		try
		{
			// TypeScript.g3:1067:2: ( expression semic !)
			DebugEnterAlt(1);
			// TypeScript.g3:1067:4: expression semic !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1067, 4);
			PushFollow(Follow._expression_in_expressionStatement6081);
			expression178=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression178.Tree);
			DebugLocation(1067, 20);
			PushFollow(Follow._semic_in_expressionStatement6083);
			semic179=semic();
			PopFollow();
			if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionStatement", 57);
			LeaveRule("expressionStatement", 57);
			LeaveRule_expressionStatement();
		}
		DebugLocation(1068, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionStatement"); }
		return retval;

	}
	// $ANTLR end "expressionStatement"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();
	// $ANTLR start "ifStatement"
	// TypeScript.g3:1074:1: ifStatement : IF LPAREN expression RPAREN statement ({...}? ELSE statement )? -> ^( IF expression ( statement )+ ) ;
	[GrammarRule("ifStatement")]
	private AstParserRuleReturnScope<object, IToken> ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 58);
		TraceIn("ifStatement", 58);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IF180 = default(IToken);
		IToken LPAREN181 = default(IToken);
		IToken RPAREN183 = default(IToken);
		IToken ELSE185 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression182 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement184 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement186 = default(AstParserRuleReturnScope<object, IToken>);

		object IF180_tree = default(object);
		object LPAREN181_tree = default(object);
		object RPAREN183_tree = default(object);
		object ELSE185_tree = default(object);
		RewriteRuleITokenStream stream_IF=new RewriteRuleITokenStream(adaptor,"token IF");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(1074, 1);
		try
		{
			// TypeScript.g3:1076:2: ( IF LPAREN expression RPAREN statement ({...}? ELSE statement )? -> ^( IF expression ( statement )+ ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1076:4: IF LPAREN expression RPAREN statement ({...}? ELSE statement )?
			{
			DebugLocation(1076, 4);
			IF180=(IToken)Match(input,IF,Follow._IF_in_ifStatement6101); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IF.Add(IF180);

			DebugLocation(1076, 7);
			LPAREN181=(IToken)Match(input,LPAREN,Follow._LPAREN_in_ifStatement6103); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN181);

			DebugLocation(1076, 14);
			PushFollow(Follow._expression_in_ifStatement6105);
			expression182=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression182.Tree);
			DebugLocation(1076, 25);
			RPAREN183=(IToken)Match(input,RPAREN,Follow._RPAREN_in_ifStatement6107); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN183);

			DebugLocation(1076, 32);
			PushFollow(Follow._statement_in_ifStatement6109);
			statement184=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement184.Tree);
			DebugLocation(1076, 42);
			// TypeScript.g3:1076:42: ({...}? ELSE statement )?
			int alt52=2;
			try { DebugEnterSubRule(52);
			try { DebugEnterDecision(52, false);
			try
			{
				alt52 = dfa52.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(52); }
			switch (alt52)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1076:44: {...}? ELSE statement
				{
				DebugLocation(1076, 44);
				if (!(( input.LA(1) == ELSE )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "ifStatement", " input.LA(1) == ELSE ");
				}
				DebugLocation(1076, 69);
				ELSE185=(IToken)Match(input,ELSE,Follow._ELSE_in_ifStatement6115); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ELSE.Add(ELSE185);

				DebugLocation(1076, 74);
				PushFollow(Follow._statement_in_ifStatement6117);
				statement186=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statement.Add(statement186.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(52); }



			{
			// AST REWRITE
			// elements: IF, expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1077:2: -> ^( IF expression ( statement )+ )
			{
				DebugLocation(1077, 5);
				// TypeScript.g3:1077:5: ^( IF expression ( statement )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1077, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_IF.NextNode(), root_1);

				DebugLocation(1077, 11);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(1077, 22);
				if (!(stream_statement.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_statement.HasNext )
				{
					DebugLocation(1077, 22);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifStatement", 58);
			LeaveRule("ifStatement", 58);
			LeaveRule_ifStatement();
		}
		DebugLocation(1078, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return retval;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_iterationStatement();
	partial void LeaveRule_iterationStatement();
	// $ANTLR start "iterationStatement"
	// TypeScript.g3:1084:1: iterationStatement : ( doStatement | whileStatement | forStatement );
	[GrammarRule("iterationStatement")]
	private AstParserRuleReturnScope<object, IToken> iterationStatement()
	{
		EnterRule_iterationStatement();
		EnterRule("iterationStatement", 59);
		TraceIn("iterationStatement", 59);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> doStatement187 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> whileStatement188 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> forStatement189 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "iterationStatement");
		DebugLocation(1084, 1);
		try
		{
			// TypeScript.g3:1085:2: ( doStatement | whileStatement | forStatement )
			int alt53=3;
			try { DebugEnterDecision(53, false);
			switch (input.LA(1))
			{
			case DO:
				{
				alt53 = 1;
				}
				break;
			case WHILE:
				{
				alt53 = 2;
				}
				break;
			case FOR:
				{
				alt53 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 53, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(53); }
			switch (alt53)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1085:4: doStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1085, 4);
				PushFollow(Follow._doStatement_in_iterationStatement6150);
				doStatement187=doStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, doStatement187.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1086:4: whileStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1086, 4);
				PushFollow(Follow._whileStatement_in_iterationStatement6155);
				whileStatement188=whileStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, whileStatement188.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:1087:4: forStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1087, 4);
				PushFollow(Follow._forStatement_in_iterationStatement6160);
				forStatement189=forStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forStatement189.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("iterationStatement", 59);
			LeaveRule("iterationStatement", 59);
			LeaveRule_iterationStatement();
		}
		DebugLocation(1088, 1);
		} finally { DebugExitRule(GrammarFileName, "iterationStatement"); }
		return retval;

	}
	// $ANTLR end "iterationStatement"

	partial void EnterRule_doStatement();
	partial void LeaveRule_doStatement();
	// $ANTLR start "doStatement"
	// TypeScript.g3:1090:1: doStatement : DO statement WHILE LPAREN expression RPAREN semic -> ^( DO statement expression ) ;
	[GrammarRule("doStatement")]
	private AstParserRuleReturnScope<object, IToken> doStatement()
	{
		EnterRule_doStatement();
		EnterRule("doStatement", 60);
		TraceIn("doStatement", 60);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DO190 = default(IToken);
		IToken WHILE192 = default(IToken);
		IToken LPAREN193 = default(IToken);
		IToken RPAREN195 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement191 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression194 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic196 = default(AstParserRuleReturnScope<object, IToken>);

		object DO190_tree = default(object);
		object WHILE192_tree = default(object);
		object LPAREN193_tree = default(object);
		object RPAREN195_tree = default(object);
		RewriteRuleITokenStream stream_DO=new RewriteRuleITokenStream(adaptor,"token DO");
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		try { DebugEnterRule(GrammarFileName, "doStatement");
		DebugLocation(1090, 1);
		try
		{
			// TypeScript.g3:1091:2: ( DO statement WHILE LPAREN expression RPAREN semic -> ^( DO statement expression ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1091:4: DO statement WHILE LPAREN expression RPAREN semic
			{
			DebugLocation(1091, 4);
			DO190=(IToken)Match(input,DO,Follow._DO_in_doStatement6172); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DO.Add(DO190);

			DebugLocation(1091, 7);
			PushFollow(Follow._statement_in_doStatement6174);
			statement191=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement191.Tree);
			DebugLocation(1091, 17);
			WHILE192=(IToken)Match(input,WHILE,Follow._WHILE_in_doStatement6176); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WHILE.Add(WHILE192);

			DebugLocation(1091, 23);
			LPAREN193=(IToken)Match(input,LPAREN,Follow._LPAREN_in_doStatement6178); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN193);

			DebugLocation(1091, 30);
			PushFollow(Follow._expression_in_doStatement6180);
			expression194=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression194.Tree);
			DebugLocation(1091, 41);
			RPAREN195=(IToken)Match(input,RPAREN,Follow._RPAREN_in_doStatement6182); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN195);

			DebugLocation(1091, 48);
			PushFollow(Follow._semic_in_doStatement6184);
			semic196=semic();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semic.Add(semic196.Tree);


			{
			// AST REWRITE
			// elements: DO, statement, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1092:2: -> ^( DO statement expression )
			{
				DebugLocation(1092, 5);
				// TypeScript.g3:1092:5: ^( DO statement expression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1092, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_DO.NextNode(), root_1);

				DebugLocation(1092, 11);
				adaptor.AddChild(root_1, stream_statement.NextTree());
				DebugLocation(1092, 21);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("doStatement", 60);
			LeaveRule("doStatement", 60);
			LeaveRule_doStatement();
		}
		DebugLocation(1093, 1);
		} finally { DebugExitRule(GrammarFileName, "doStatement"); }
		return retval;

	}
	// $ANTLR end "doStatement"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();
	// $ANTLR start "whileStatement"
	// TypeScript.g3:1095:1: whileStatement : WHILE ^ LPAREN ! expression RPAREN ! statement ;
	[GrammarRule("whileStatement")]
	private AstParserRuleReturnScope<object, IToken> whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 61);
		TraceIn("whileStatement", 61);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WHILE197 = default(IToken);
		IToken LPAREN198 = default(IToken);
		IToken RPAREN200 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression199 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement201 = default(AstParserRuleReturnScope<object, IToken>);

		object WHILE197_tree = default(object);
		object LPAREN198_tree = default(object);
		object RPAREN200_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(1095, 1);
		try
		{
			// TypeScript.g3:1096:2: ( WHILE ^ LPAREN ! expression RPAREN ! statement )
			DebugEnterAlt(1);
			// TypeScript.g3:1096:4: WHILE ^ LPAREN ! expression RPAREN ! statement
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1096, 9);
			WHILE197=(IToken)Match(input,WHILE,Follow._WHILE_in_whileStatement6209); if (state.failed) return retval;
			if (state.backtracking == 0) {
			WHILE197_tree = (object)adaptor.Create(WHILE197);
			root_0 = (object)adaptor.BecomeRoot(WHILE197_tree, root_0);
			}
			DebugLocation(1096, 17);
			LPAREN198=(IToken)Match(input,LPAREN,Follow._LPAREN_in_whileStatement6212); if (state.failed) return retval;
			DebugLocation(1096, 19);
			PushFollow(Follow._expression_in_whileStatement6215);
			expression199=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression199.Tree);
			DebugLocation(1096, 36);
			RPAREN200=(IToken)Match(input,RPAREN,Follow._RPAREN_in_whileStatement6217); if (state.failed) return retval;
			DebugLocation(1096, 38);
			PushFollow(Follow._statement_in_whileStatement6220);
			statement201=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement201.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileStatement", 61);
			LeaveRule("whileStatement", 61);
			LeaveRule_whileStatement();
		}
		DebugLocation(1097, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return retval;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_forStatement();
	partial void LeaveRule_forStatement();
	// $ANTLR start "forStatement"
	// TypeScript.g3:1140:1: forStatement : FOR ^ LPAREN ! forControl RPAREN ! statement ;
	[GrammarRule("forStatement")]
	private AstParserRuleReturnScope<object, IToken> forStatement()
	{
		EnterRule_forStatement();
		EnterRule("forStatement", 62);
		TraceIn("forStatement", 62);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FOR202 = default(IToken);
		IToken LPAREN203 = default(IToken);
		IToken RPAREN205 = default(IToken);
		AstParserRuleReturnScope<object, IToken> forControl204 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement206 = default(AstParserRuleReturnScope<object, IToken>);

		object FOR202_tree = default(object);
		object LPAREN203_tree = default(object);
		object RPAREN205_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "forStatement");
		DebugLocation(1140, 1);
		try
		{
			// TypeScript.g3:1141:2: ( FOR ^ LPAREN ! forControl RPAREN ! statement )
			DebugEnterAlt(1);
			// TypeScript.g3:1141:4: FOR ^ LPAREN ! forControl RPAREN ! statement
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1141, 7);
			FOR202=(IToken)Match(input,FOR,Follow._FOR_in_forStatement6233); if (state.failed) return retval;
			if (state.backtracking == 0) {
			FOR202_tree = (object)adaptor.Create(FOR202);
			root_0 = (object)adaptor.BecomeRoot(FOR202_tree, root_0);
			}
			DebugLocation(1141, 15);
			LPAREN203=(IToken)Match(input,LPAREN,Follow._LPAREN_in_forStatement6236); if (state.failed) return retval;
			DebugLocation(1141, 17);
			PushFollow(Follow._forControl_in_forStatement6239);
			forControl204=forControl();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, forControl204.Tree);
			DebugLocation(1141, 34);
			RPAREN205=(IToken)Match(input,RPAREN,Follow._RPAREN_in_forStatement6241); if (state.failed) return retval;
			DebugLocation(1141, 36);
			PushFollow(Follow._statement_in_forStatement6244);
			statement206=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement206.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forStatement", 62);
			LeaveRule("forStatement", 62);
			LeaveRule_forStatement();
		}
		DebugLocation(1142, 1);
		} finally { DebugExitRule(GrammarFileName, "forStatement"); }
		return retval;

	}
	// $ANTLR end "forStatement"

	partial void EnterRule_forControl();
	partial void LeaveRule_forControl();
	// $ANTLR start "forControl"
	// TypeScript.g3:1144:1: forControl : ( forControlVar | forControlExpression | forControlSemic );
	[GrammarRule("forControl")]
	private AstParserRuleReturnScope<object, IToken> forControl()
	{
		EnterRule_forControl();
		EnterRule("forControl", 63);
		TraceIn("forControl", 63);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> forControlVar207 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> forControlExpression208 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> forControlSemic209 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "forControl");
		DebugLocation(1144, 1);
		try
		{
			// TypeScript.g3:1145:2: ( forControlVar | forControlExpression | forControlSemic )
			int alt54=3;
			try { DebugEnterDecision(54, false);
			switch (input.LA(1))
			{
			case VAR:
				{
				alt54 = 1;
				}
				break;
			case ADD:
			case ANY:
			case CONSTRUCTOR:
			case DEC:
			case DECLARE:
			case DELETE:
			case DecimalLiteral:
			case FALSE:
			case FINAL:
			case FUNCTION:
			case GET:
			case HexIntegerLiteral:
			case INC:
			case INV:
			case Identifier:
			case LBRACE:
			case LBRACK:
			case LPAREN:
			case MODULE:
			case NEW:
			case NOT:
			case NULL:
			case NUMBER:
			case OctalIntegerLiteral:
			case REQUIRE:
			case RegularExpressionLiteral:
			case SET:
			case STRING:
			case SUB:
			case StringLiteral:
			case THIS:
			case THROWS:
			case TRUE:
			case TYPE:
			case TYPEOF:
			case VOID:
				{
				alt54 = 2;
				}
				break;
			case SEMIC:
				{
				alt54 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 54, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(54); }
			switch (alt54)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1145:4: forControlVar
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1145, 4);
				PushFollow(Follow._forControlVar_in_forControl6255);
				forControlVar207=forControlVar();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forControlVar207.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1146:4: forControlExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1146, 4);
				PushFollow(Follow._forControlExpression_in_forControl6260);
				forControlExpression208=forControlExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forControlExpression208.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:1147:4: forControlSemic
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1147, 4);
				PushFollow(Follow._forControlSemic_in_forControl6265);
				forControlSemic209=forControlSemic();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forControlSemic209.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forControl", 63);
			LeaveRule("forControl", 63);
			LeaveRule_forControl();
		}
		DebugLocation(1148, 1);
		} finally { DebugExitRule(GrammarFileName, "forControl"); }
		return retval;

	}
	// $ANTLR end "forControl"

	partial void EnterRule_forControlVar();
	partial void LeaveRule_forControlVar();
	// $ANTLR start "forControlVar"
	// TypeScript.g3:1150:1: forControlVar : VAR variableDeclarationNoIn ( ( IN expression -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) ) ) | ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) ) ) ;
	[GrammarRule("forControlVar")]
	private AstParserRuleReturnScope<object, IToken> forControlVar()
	{
		EnterRule_forControlVar();
		EnterRule("forControlVar", 64);
		TraceIn("forControlVar", 64);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken VAR210 = default(IToken);
		IToken IN212 = default(IToken);
		IToken COMMA214 = default(IToken);
		IToken SEMIC216 = default(IToken);
		IToken SEMIC217 = default(IToken);
		AstParserRuleReturnScope<object, IToken> ex1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ex2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableDeclarationNoIn211 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression213 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableDeclarationNoIn215 = default(AstParserRuleReturnScope<object, IToken>);

		object VAR210_tree = default(object);
		object IN212_tree = default(object);
		object COMMA214_tree = default(object);
		object SEMIC216_tree = default(object);
		object SEMIC217_tree = default(object);
		RewriteRuleITokenStream stream_VAR=new RewriteRuleITokenStream(adaptor,"token VAR");
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_SEMIC=new RewriteRuleITokenStream(adaptor,"token SEMIC");
		RewriteRuleSubtreeStream stream_variableDeclarationNoIn=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarationNoIn");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "forControlVar");
		DebugLocation(1150, 1);
		try
		{
			// TypeScript.g3:1151:2: ( VAR variableDeclarationNoIn ( ( IN expression -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) ) ) | ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) ) ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1151:4: VAR variableDeclarationNoIn ( ( IN expression -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) ) ) | ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) ) )
			{
			DebugLocation(1151, 4);
			VAR210=(IToken)Match(input,VAR,Follow._VAR_in_forControlVar6276); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_VAR.Add(VAR210);

			DebugLocation(1151, 8);
			PushFollow(Follow._variableDeclarationNoIn_in_forControlVar6278);
			variableDeclarationNoIn211=variableDeclarationNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclarationNoIn.Add(variableDeclarationNoIn211.Tree);
			DebugLocation(1152, 2);
			// TypeScript.g3:1152:2: ( ( IN expression -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) ) ) | ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) ) )
			int alt58=2;
			try { DebugEnterSubRule(58);
			try { DebugEnterDecision(58, false);
			int LA58_1 = input.LA(1);

			if ((LA58_1==IN))
			{
				alt58 = 1;
			}
			else if ((LA58_1==COMMA||LA58_1==SEMIC))
			{
				alt58 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 58, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(58); }
			switch (alt58)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1153:3: ( IN expression -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) ) )
				{
				DebugLocation(1153, 3);
				// TypeScript.g3:1153:3: ( IN expression -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) ) )
				DebugEnterAlt(1);
				// TypeScript.g3:1154:4: IN expression
				{
				DebugLocation(1154, 4);
				IN212=(IToken)Match(input,IN,Follow._IN_in_forControlVar6290); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IN.Add(IN212);

				DebugLocation(1154, 7);
				PushFollow(Follow._expression_in_forControlVar6292);
				expression213=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression213.Tree);


				{
				// AST REWRITE
				// elements: VAR, variableDeclarationNoIn, expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1155:4: -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) )
				{
					DebugLocation(1155, 7);
					// TypeScript.g3:1155:7: ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1155, 10);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FORITER, "FORITER"), root_1);

					DebugLocation(1155, 18);
					// TypeScript.g3:1155:18: ^( VAR variableDeclarationNoIn )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1155, 21);
					root_2 = (object)adaptor.BecomeRoot(stream_VAR.NextNode(), root_2);

					DebugLocation(1155, 25);
					adaptor.AddChild(root_2, stream_variableDeclarationNoIn.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(1155, 51);
					// TypeScript.g3:1155:51: ^( EXPR expression )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1155, 54);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1155, 59);
					adaptor.AddChild(root_2, stream_expression.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1158:3: ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) )
				{
				DebugLocation(1158, 3);
				// TypeScript.g3:1158:3: ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) )
				DebugEnterAlt(1);
				// TypeScript.g3:1159:4: ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )?
				{
				DebugLocation(1159, 4);
				// TypeScript.g3:1159:4: ( COMMA variableDeclarationNoIn )*
				try { DebugEnterSubRule(55);
				while (true)
				{
					int alt55=2;
					try { DebugEnterDecision(55, false);
					int LA55_1 = input.LA(1);

					if ((LA55_1==COMMA))
					{
						alt55 = 1;
					}


					} finally { DebugExitDecision(55); }
					switch ( alt55 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScript.g3:1159:6: COMMA variableDeclarationNoIn
						{
						DebugLocation(1159, 6);
						COMMA214=(IToken)Match(input,COMMA,Follow._COMMA_in_forControlVar6338); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA214);

						DebugLocation(1159, 12);
						PushFollow(Follow._variableDeclarationNoIn_in_forControlVar6340);
						variableDeclarationNoIn215=variableDeclarationNoIn();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_variableDeclarationNoIn.Add(variableDeclarationNoIn215.Tree);

						}
						break;

					default:
						goto loop55;
					}
				}

				loop55:
					;

				} finally { DebugExitSubRule(55); }

				DebugLocation(1159, 39);
				SEMIC216=(IToken)Match(input,SEMIC,Follow._SEMIC_in_forControlVar6345); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMIC.Add(SEMIC216);

				DebugLocation(1159, 48);
				// TypeScript.g3:1159:48: (ex1= expression )?
				int alt56=2;
				try { DebugEnterSubRule(56);
				try { DebugEnterDecision(56, false);
				int LA56_1 = input.LA(1);

				if ((LA56_1==ADD||LA56_1==ANY||LA56_1==CONSTRUCTOR||(LA56_1>=DEC && LA56_1<=DECLARE)||LA56_1==DELETE||LA56_1==DecimalLiteral||LA56_1==FALSE||LA56_1==FINAL||LA56_1==FUNCTION||LA56_1==GET||LA56_1==HexIntegerLiteral||LA56_1==INC||LA56_1==INV||LA56_1==Identifier||(LA56_1>=LBRACE && LA56_1<=LBRACK)||LA56_1==LPAREN||LA56_1==MODULE||(LA56_1>=NEW && LA56_1<=NOT)||(LA56_1>=NULL && LA56_1<=NUMBER)||LA56_1==OctalIntegerLiteral||LA56_1==REQUIRE||LA56_1==RegularExpressionLiteral||LA56_1==SET||(LA56_1>=STRING && LA56_1<=SUB)||LA56_1==StringLiteral||LA56_1==THIS||LA56_1==THROWS||LA56_1==TRUE||(LA56_1>=TYPE && LA56_1<=TYPEOF)||LA56_1==VOID))
				{
					alt56 = 1;
				}
				} finally { DebugExitDecision(56); }
				switch (alt56)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1159:48: ex1= expression
					{
					DebugLocation(1159, 48);
					PushFollow(Follow._expression_in_forControlVar6349);
					ex1=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(ex1.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(56); }

				DebugLocation(1159, 61);
				SEMIC217=(IToken)Match(input,SEMIC,Follow._SEMIC_in_forControlVar6352); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMIC.Add(SEMIC217);

				DebugLocation(1159, 70);
				// TypeScript.g3:1159:70: (ex2= expression )?
				int alt57=2;
				try { DebugEnterSubRule(57);
				try { DebugEnterDecision(57, false);
				int LA57_1 = input.LA(1);

				if ((LA57_1==ADD||LA57_1==ANY||LA57_1==CONSTRUCTOR||(LA57_1>=DEC && LA57_1<=DECLARE)||LA57_1==DELETE||LA57_1==DecimalLiteral||LA57_1==FALSE||LA57_1==FINAL||LA57_1==FUNCTION||LA57_1==GET||LA57_1==HexIntegerLiteral||LA57_1==INC||LA57_1==INV||LA57_1==Identifier||(LA57_1>=LBRACE && LA57_1<=LBRACK)||LA57_1==LPAREN||LA57_1==MODULE||(LA57_1>=NEW && LA57_1<=NOT)||(LA57_1>=NULL && LA57_1<=NUMBER)||LA57_1==OctalIntegerLiteral||LA57_1==REQUIRE||LA57_1==RegularExpressionLiteral||LA57_1==SET||(LA57_1>=STRING && LA57_1<=SUB)||LA57_1==StringLiteral||LA57_1==THIS||LA57_1==THROWS||LA57_1==TRUE||(LA57_1>=TYPE && LA57_1<=TYPEOF)||LA57_1==VOID))
				{
					alt57 = 1;
				}
				} finally { DebugExitDecision(57); }
				switch (alt57)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1159:70: ex2= expression
					{
					DebugLocation(1159, 70);
					PushFollow(Follow._expression_in_forControlVar6356);
					ex2=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(ex2.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(57); }



				{
				// AST REWRITE
				// elements: VAR, variableDeclarationNoIn, ex1, ex2
				// token labels: 
				// rule labels: ex1, ex2, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ex1=new RewriteRuleSubtreeStream(adaptor,"rule ex1",ex1!=null?ex1.Tree:null);
				RewriteRuleSubtreeStream stream_ex2=new RewriteRuleSubtreeStream(adaptor,"rule ex2",ex2!=null?ex2.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1160:4: -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) )
				{
					DebugLocation(1160, 7);
					// TypeScript.g3:1160:7: ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1160, 10);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FORSTEP, "FORSTEP"), root_1);

					DebugLocation(1160, 18);
					// TypeScript.g3:1160:18: ^( VAR ( variableDeclarationNoIn )+ )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1160, 21);
					root_2 = (object)adaptor.BecomeRoot(stream_VAR.NextNode(), root_2);

					DebugLocation(1160, 25);
					if (!(stream_variableDeclarationNoIn.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_variableDeclarationNoIn.HasNext )
					{
						DebugLocation(1160, 25);
						adaptor.AddChild(root_2, stream_variableDeclarationNoIn.NextTree());

					}
					stream_variableDeclarationNoIn.Reset();

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(1160, 52);
					// TypeScript.g3:1160:52: ^( EXPR ( $ex1)? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1160, 55);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1160, 61);
					// TypeScript.g3:1160:61: ( $ex1)?
					if (stream_ex1.HasNext)
					{
						DebugLocation(1160, 61);
						adaptor.AddChild(root_2, stream_ex1.NextTree());

					}
					stream_ex1.Reset();

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(1160, 68);
					// TypeScript.g3:1160:68: ^( EXPR ( $ex2)? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1160, 71);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1160, 77);
					// TypeScript.g3:1160:77: ( $ex2)?
					if (stream_ex2.HasNext)
					{
						DebugLocation(1160, 77);
						adaptor.AddChild(root_2, stream_ex2.NextTree());

					}
					stream_ex2.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}


				}
				break;

			}
			} finally { DebugExitSubRule(58); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forControlVar", 64);
			LeaveRule("forControlVar", 64);
			LeaveRule_forControlVar();
		}
		DebugLocation(1163, 1);
		} finally { DebugExitRule(GrammarFileName, "forControlVar"); }
		return retval;

	}
	// $ANTLR end "forControlVar"

	partial void EnterRule_forControlExpression();
	partial void LeaveRule_forControlExpression();
	// $ANTLR start "forControlExpression"
	// TypeScript.g3:1165:1: forControlExpression : ex1= expressionNoIn ({...}? ( IN ex2= expression -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) ) ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) ) ) ) ;
	[GrammarRule("forControlExpression")]
	private AstParserRuleReturnScope<object, IToken> forControlExpression()
	{
		EnterRule_forControlExpression();
		EnterRule("forControlExpression", 65);
		TraceIn("forControlExpression", 65);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IN218 = default(IToken);
		IToken SEMIC219 = default(IToken);
		IToken SEMIC220 = default(IToken);
		AstParserRuleReturnScope<object, IToken> ex1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ex2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ex3 = default(AstParserRuleReturnScope<object, IToken>);

		object IN218_tree = default(object);
		object SEMIC219_tree = default(object);
		object SEMIC220_tree = default(object);
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_SEMIC=new RewriteRuleITokenStream(adaptor,"token SEMIC");
		RewriteRuleSubtreeStream stream_expressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule expressionNoIn");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

			bool? isLhs = null;

		try { DebugEnterRule(GrammarFileName, "forControlExpression");
		DebugLocation(1165, 1);
		try
		{
			// TypeScript.g3:1170:2: (ex1= expressionNoIn ({...}? ( IN ex2= expression -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) ) ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) ) ) ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1170:4: ex1= expressionNoIn ({...}? ( IN ex2= expression -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) ) ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) ) ) )
			{
			DebugLocation(1170, 7);
			PushFollow(Follow._expressionNoIn_in_forControlExpression6422);
			ex1=expressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expressionNoIn.Add(ex1.Tree);
			DebugLocation(1171, 2);
			// TypeScript.g3:1171:2: ({...}? ( IN ex2= expression -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) ) ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) ) ) )
			int alt61=2;
			try { DebugEnterSubRule(61);
			try { DebugEnterDecision(61, false);
			int LA61_1 = input.LA(1);

			if ((LA61_1==IN))
			{
				alt61 = 1;
			}
			else if ((LA61_1==SEMIC))
			{
				alt61 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 61, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(61); }
			switch (alt61)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1172:3: {...}? ( IN ex2= expression -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) ) )
				{
				DebugLocation(1172, 3);
				if (!(( IsLeftHandSideIn(ex1, ref isLhs) )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "forControlExpression", " IsLeftHandSideIn(ex1, ref isLhs) ");
				}
				DebugLocation(1172, 41);
				// TypeScript.g3:1172:41: ( IN ex2= expression -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) ) )
				DebugEnterAlt(1);
				// TypeScript.g3:1173:4: IN ex2= expression
				{
				DebugLocation(1173, 4);
				IN218=(IToken)Match(input,IN,Follow._IN_in_forControlExpression6437); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IN.Add(IN218);

				DebugLocation(1173, 10);
				PushFollow(Follow._expression_in_forControlExpression6441);
				ex2=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(ex2.Tree);


				{
				// AST REWRITE
				// elements: ex1, ex2
				// token labels: 
				// rule labels: ex1, ex2, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ex1=new RewriteRuleSubtreeStream(adaptor,"rule ex1",ex1!=null?ex1.Tree:null);
				RewriteRuleSubtreeStream stream_ex2=new RewriteRuleSubtreeStream(adaptor,"rule ex2",ex2!=null?ex2.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1174:4: -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) )
				{
					DebugLocation(1174, 7);
					// TypeScript.g3:1174:7: ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1174, 10);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FORITER, "FORITER"), root_1);

					DebugLocation(1174, 18);
					// TypeScript.g3:1174:18: ^( EXPR $ex1)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1174, 21);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1174, 27);
					adaptor.AddChild(root_2, stream_ex1.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(1174, 33);
					// TypeScript.g3:1174:33: ^( EXPR $ex2)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1174, 36);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1174, 42);
					adaptor.AddChild(root_2, stream_ex2.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1177:3: ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) ) )
				{
				DebugLocation(1177, 3);
				// TypeScript.g3:1177:3: ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) ) )
				DebugEnterAlt(1);
				// TypeScript.g3:1178:4: SEMIC (ex2= expression )? SEMIC (ex3= expression )?
				{
				DebugLocation(1178, 4);
				SEMIC219=(IToken)Match(input,SEMIC,Follow._SEMIC_in_forControlExpression6487); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMIC.Add(SEMIC219);

				DebugLocation(1178, 13);
				// TypeScript.g3:1178:13: (ex2= expression )?
				int alt59=2;
				try { DebugEnterSubRule(59);
				try { DebugEnterDecision(59, false);
				int LA59_1 = input.LA(1);

				if ((LA59_1==ADD||LA59_1==ANY||LA59_1==CONSTRUCTOR||(LA59_1>=DEC && LA59_1<=DECLARE)||LA59_1==DELETE||LA59_1==DecimalLiteral||LA59_1==FALSE||LA59_1==FINAL||LA59_1==FUNCTION||LA59_1==GET||LA59_1==HexIntegerLiteral||LA59_1==INC||LA59_1==INV||LA59_1==Identifier||(LA59_1>=LBRACE && LA59_1<=LBRACK)||LA59_1==LPAREN||LA59_1==MODULE||(LA59_1>=NEW && LA59_1<=NOT)||(LA59_1>=NULL && LA59_1<=NUMBER)||LA59_1==OctalIntegerLiteral||LA59_1==REQUIRE||LA59_1==RegularExpressionLiteral||LA59_1==SET||(LA59_1>=STRING && LA59_1<=SUB)||LA59_1==StringLiteral||LA59_1==THIS||LA59_1==THROWS||LA59_1==TRUE||(LA59_1>=TYPE && LA59_1<=TYPEOF)||LA59_1==VOID))
				{
					alt59 = 1;
				}
				} finally { DebugExitDecision(59); }
				switch (alt59)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1178:13: ex2= expression
					{
					DebugLocation(1178, 13);
					PushFollow(Follow._expression_in_forControlExpression6491);
					ex2=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(ex2.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(59); }

				DebugLocation(1178, 26);
				SEMIC220=(IToken)Match(input,SEMIC,Follow._SEMIC_in_forControlExpression6494); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMIC.Add(SEMIC220);

				DebugLocation(1178, 35);
				// TypeScript.g3:1178:35: (ex3= expression )?
				int alt60=2;
				try { DebugEnterSubRule(60);
				try { DebugEnterDecision(60, false);
				int LA60_1 = input.LA(1);

				if ((LA60_1==ADD||LA60_1==ANY||LA60_1==CONSTRUCTOR||(LA60_1>=DEC && LA60_1<=DECLARE)||LA60_1==DELETE||LA60_1==DecimalLiteral||LA60_1==FALSE||LA60_1==FINAL||LA60_1==FUNCTION||LA60_1==GET||LA60_1==HexIntegerLiteral||LA60_1==INC||LA60_1==INV||LA60_1==Identifier||(LA60_1>=LBRACE && LA60_1<=LBRACK)||LA60_1==LPAREN||LA60_1==MODULE||(LA60_1>=NEW && LA60_1<=NOT)||(LA60_1>=NULL && LA60_1<=NUMBER)||LA60_1==OctalIntegerLiteral||LA60_1==REQUIRE||LA60_1==RegularExpressionLiteral||LA60_1==SET||(LA60_1>=STRING && LA60_1<=SUB)||LA60_1==StringLiteral||LA60_1==THIS||LA60_1==THROWS||LA60_1==TRUE||(LA60_1>=TYPE && LA60_1<=TYPEOF)||LA60_1==VOID))
				{
					alt60 = 1;
				}
				} finally { DebugExitDecision(60); }
				switch (alt60)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1178:35: ex3= expression
					{
					DebugLocation(1178, 35);
					PushFollow(Follow._expression_in_forControlExpression6498);
					ex3=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(ex3.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(60); }



				{
				// AST REWRITE
				// elements: ex1, ex2, ex3
				// token labels: 
				// rule labels: ex1, ex2, ex3, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ex1=new RewriteRuleSubtreeStream(adaptor,"rule ex1",ex1!=null?ex1.Tree:null);
				RewriteRuleSubtreeStream stream_ex2=new RewriteRuleSubtreeStream(adaptor,"rule ex2",ex2!=null?ex2.Tree:null);
				RewriteRuleSubtreeStream stream_ex3=new RewriteRuleSubtreeStream(adaptor,"rule ex3",ex3!=null?ex3.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1179:4: -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) )
				{
					DebugLocation(1179, 7);
					// TypeScript.g3:1179:7: ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1179, 10);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FORSTEP, "FORSTEP"), root_1);

					DebugLocation(1179, 18);
					// TypeScript.g3:1179:18: ^( EXPR $ex1)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1179, 21);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1179, 27);
					adaptor.AddChild(root_2, stream_ex1.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(1179, 33);
					// TypeScript.g3:1179:33: ^( EXPR ( $ex2)? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1179, 36);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1179, 42);
					// TypeScript.g3:1179:42: ( $ex2)?
					if (stream_ex2.HasNext)
					{
						DebugLocation(1179, 42);
						adaptor.AddChild(root_2, stream_ex2.NextTree());

					}
					stream_ex2.Reset();

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(1179, 49);
					// TypeScript.g3:1179:49: ^( EXPR ( $ex3)? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1179, 52);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1179, 58);
					// TypeScript.g3:1179:58: ( $ex3)?
					if (stream_ex3.HasNext)
					{
						DebugLocation(1179, 58);
						adaptor.AddChild(root_2, stream_ex3.NextTree());

					}
					stream_ex3.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}


				}
				break;

			}
			} finally { DebugExitSubRule(61); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forControlExpression", 65);
			LeaveRule("forControlExpression", 65);
			LeaveRule_forControlExpression();
		}
		DebugLocation(1182, 1);
		} finally { DebugExitRule(GrammarFileName, "forControlExpression"); }
		return retval;

	}
	// $ANTLR end "forControlExpression"

	partial void EnterRule_forControlSemic();
	partial void LeaveRule_forControlSemic();
	// $ANTLR start "forControlSemic"
	// TypeScript.g3:1184:1: forControlSemic : SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( EXPR ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) ;
	[GrammarRule("forControlSemic")]
	private AstParserRuleReturnScope<object, IToken> forControlSemic()
	{
		EnterRule_forControlSemic();
		EnterRule("forControlSemic", 66);
		TraceIn("forControlSemic", 66);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMIC221 = default(IToken);
		IToken SEMIC222 = default(IToken);
		AstParserRuleReturnScope<object, IToken> ex1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ex2 = default(AstParserRuleReturnScope<object, IToken>);

		object SEMIC221_tree = default(object);
		object SEMIC222_tree = default(object);
		RewriteRuleITokenStream stream_SEMIC=new RewriteRuleITokenStream(adaptor,"token SEMIC");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "forControlSemic");
		DebugLocation(1184, 1);
		try
		{
			// TypeScript.g3:1185:2: ( SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( EXPR ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1185:4: SEMIC (ex1= expression )? SEMIC (ex2= expression )?
			{
			DebugLocation(1185, 4);
			SEMIC221=(IToken)Match(input,SEMIC,Follow._SEMIC_in_forControlSemic6557); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMIC.Add(SEMIC221);

			DebugLocation(1185, 13);
			// TypeScript.g3:1185:13: (ex1= expression )?
			int alt62=2;
			try { DebugEnterSubRule(62);
			try { DebugEnterDecision(62, false);
			int LA62_1 = input.LA(1);

			if ((LA62_1==ADD||LA62_1==ANY||LA62_1==CONSTRUCTOR||(LA62_1>=DEC && LA62_1<=DECLARE)||LA62_1==DELETE||LA62_1==DecimalLiteral||LA62_1==FALSE||LA62_1==FINAL||LA62_1==FUNCTION||LA62_1==GET||LA62_1==HexIntegerLiteral||LA62_1==INC||LA62_1==INV||LA62_1==Identifier||(LA62_1>=LBRACE && LA62_1<=LBRACK)||LA62_1==LPAREN||LA62_1==MODULE||(LA62_1>=NEW && LA62_1<=NOT)||(LA62_1>=NULL && LA62_1<=NUMBER)||LA62_1==OctalIntegerLiteral||LA62_1==REQUIRE||LA62_1==RegularExpressionLiteral||LA62_1==SET||(LA62_1>=STRING && LA62_1<=SUB)||LA62_1==StringLiteral||LA62_1==THIS||LA62_1==THROWS||LA62_1==TRUE||(LA62_1>=TYPE && LA62_1<=TYPEOF)||LA62_1==VOID))
			{
				alt62 = 1;
			}
			} finally { DebugExitDecision(62); }
			switch (alt62)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1185:13: ex1= expression
				{
				DebugLocation(1185, 13);
				PushFollow(Follow._expression_in_forControlSemic6561);
				ex1=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(ex1.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(62); }

			DebugLocation(1185, 26);
			SEMIC222=(IToken)Match(input,SEMIC,Follow._SEMIC_in_forControlSemic6564); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMIC.Add(SEMIC222);

			DebugLocation(1185, 35);
			// TypeScript.g3:1185:35: (ex2= expression )?
			int alt63=2;
			try { DebugEnterSubRule(63);
			try { DebugEnterDecision(63, false);
			int LA63_1 = input.LA(1);

			if ((LA63_1==ADD||LA63_1==ANY||LA63_1==CONSTRUCTOR||(LA63_1>=DEC && LA63_1<=DECLARE)||LA63_1==DELETE||LA63_1==DecimalLiteral||LA63_1==FALSE||LA63_1==FINAL||LA63_1==FUNCTION||LA63_1==GET||LA63_1==HexIntegerLiteral||LA63_1==INC||LA63_1==INV||LA63_1==Identifier||(LA63_1>=LBRACE && LA63_1<=LBRACK)||LA63_1==LPAREN||LA63_1==MODULE||(LA63_1>=NEW && LA63_1<=NOT)||(LA63_1>=NULL && LA63_1<=NUMBER)||LA63_1==OctalIntegerLiteral||LA63_1==REQUIRE||LA63_1==RegularExpressionLiteral||LA63_1==SET||(LA63_1>=STRING && LA63_1<=SUB)||LA63_1==StringLiteral||LA63_1==THIS||LA63_1==THROWS||LA63_1==TRUE||(LA63_1>=TYPE && LA63_1<=TYPEOF)||LA63_1==VOID))
			{
				alt63 = 1;
			}
			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1185:35: ex2= expression
				{
				DebugLocation(1185, 35);
				PushFollow(Follow._expression_in_forControlSemic6568);
				ex2=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(ex2.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(63); }



			{
			// AST REWRITE
			// elements: ex1, ex2
			// token labels: 
			// rule labels: ex1, ex2, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_ex1=new RewriteRuleSubtreeStream(adaptor,"rule ex1",ex1!=null?ex1.Tree:null);
			RewriteRuleSubtreeStream stream_ex2=new RewriteRuleSubtreeStream(adaptor,"rule ex2",ex2!=null?ex2.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1186:2: -> ^( FORSTEP ^( EXPR ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) )
			{
				DebugLocation(1186, 5);
				// TypeScript.g3:1186:5: ^( FORSTEP ^( EXPR ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1186, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FORSTEP, "FORSTEP"), root_1);

				DebugLocation(1186, 16);
				// TypeScript.g3:1186:16: ^( EXPR )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(1186, 19);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(1186, 26);
				// TypeScript.g3:1186:26: ^( EXPR ( $ex1)? )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(1186, 29);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

				DebugLocation(1186, 35);
				// TypeScript.g3:1186:35: ( $ex1)?
				if (stream_ex1.HasNext)
				{
					DebugLocation(1186, 35);
					adaptor.AddChild(root_2, stream_ex1.NextTree());

				}
				stream_ex1.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(1186, 42);
				// TypeScript.g3:1186:42: ^( EXPR ( $ex2)? )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(1186, 45);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

				DebugLocation(1186, 51);
				// TypeScript.g3:1186:51: ( $ex2)?
				if (stream_ex2.HasNext)
				{
					DebugLocation(1186, 51);
					adaptor.AddChild(root_2, stream_ex2.NextTree());

				}
				stream_ex2.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forControlSemic", 66);
			LeaveRule("forControlSemic", 66);
			LeaveRule_forControlSemic();
		}
		DebugLocation(1187, 1);
		} finally { DebugExitRule(GrammarFileName, "forControlSemic"); }
		return retval;

	}
	// $ANTLR end "forControlSemic"

	partial void EnterRule_continueStatement();
	partial void LeaveRule_continueStatement();
	// $ANTLR start "continueStatement"
	// TypeScript.g3:1198:1: continueStatement : CONTINUE ^ ( identifier )? semic !;
	[GrammarRule("continueStatement")]
	private AstParserRuleReturnScope<object, IToken> continueStatement()
	{
		EnterRule_continueStatement();
		EnterRule("continueStatement", 67);
		TraceIn("continueStatement", 67);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CONTINUE223 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier224 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic225 = default(AstParserRuleReturnScope<object, IToken>);

		object CONTINUE223_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "continueStatement");
		DebugLocation(1198, 1);
		try
		{
			// TypeScript.g3:1199:2: ( CONTINUE ^ ( identifier )? semic !)
			DebugEnterAlt(1);
			// TypeScript.g3:1199:4: CONTINUE ^ ( identifier )? semic !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1199, 12);
			CONTINUE223=(IToken)Match(input,CONTINUE,Follow._CONTINUE_in_continueStatement6622); if (state.failed) return retval;
			if (state.backtracking == 0) {
			CONTINUE223_tree = (object)adaptor.Create(CONTINUE223);
			root_0 = (object)adaptor.BecomeRoot(CONTINUE223_tree, root_0);
			}
			DebugLocation(1199, 14);
			if (state.backtracking == 0)
			{
				 if (input.LA(1) == Identifier) PromoteEOL(null); 
			}
			DebugLocation(1199, 67);
			// TypeScript.g3:1199:67: ( identifier )?
			int alt64=2;
			try { DebugEnterSubRule(64);
			try { DebugEnterDecision(64, false);
			int LA64_1 = input.LA(1);

			if ((LA64_1==ANY||LA64_1==CONSTRUCTOR||LA64_1==DECLARE||LA64_1==FINAL||LA64_1==GET||LA64_1==Identifier||LA64_1==MODULE||LA64_1==NUMBER||LA64_1==REQUIRE||LA64_1==SET||LA64_1==STRING||LA64_1==THROWS||LA64_1==TYPE))
			{
				alt64 = 1;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1199:67: identifier
				{
				DebugLocation(1199, 67);
				PushFollow(Follow._identifier_in_continueStatement6627);
				identifier224=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifier224.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(64); }

			DebugLocation(1199, 84);
			PushFollow(Follow._semic_in_continueStatement6630);
			semic225=semic();
			PopFollow();
			if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("continueStatement", 67);
			LeaveRule("continueStatement", 67);
			LeaveRule_continueStatement();
		}
		DebugLocation(1200, 1);
		} finally { DebugExitRule(GrammarFileName, "continueStatement"); }
		return retval;

	}
	// $ANTLR end "continueStatement"

	partial void EnterRule_breakStatement();
	partial void LeaveRule_breakStatement();
	// $ANTLR start "breakStatement"
	// TypeScript.g3:1211:1: breakStatement : BREAK ^ ( identifier )? semic !;
	[GrammarRule("breakStatement")]
	private AstParserRuleReturnScope<object, IToken> breakStatement()
	{
		EnterRule_breakStatement();
		EnterRule("breakStatement", 68);
		TraceIn("breakStatement", 68);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken BREAK226 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier227 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic228 = default(AstParserRuleReturnScope<object, IToken>);

		object BREAK226_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "breakStatement");
		DebugLocation(1211, 1);
		try
		{
			// TypeScript.g3:1212:2: ( BREAK ^ ( identifier )? semic !)
			DebugEnterAlt(1);
			// TypeScript.g3:1212:4: BREAK ^ ( identifier )? semic !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1212, 9);
			BREAK226=(IToken)Match(input,BREAK,Follow._BREAK_in_breakStatement6649); if (state.failed) return retval;
			if (state.backtracking == 0) {
			BREAK226_tree = (object)adaptor.Create(BREAK226);
			root_0 = (object)adaptor.BecomeRoot(BREAK226_tree, root_0);
			}
			DebugLocation(1212, 11);
			if (state.backtracking == 0)
			{
				 if (input.LA(1) == Identifier) PromoteEOL(null); 
			}
			DebugLocation(1212, 64);
			// TypeScript.g3:1212:64: ( identifier )?
			int alt65=2;
			try { DebugEnterSubRule(65);
			try { DebugEnterDecision(65, false);
			int LA65_1 = input.LA(1);

			if ((LA65_1==ANY||LA65_1==CONSTRUCTOR||LA65_1==DECLARE||LA65_1==FINAL||LA65_1==GET||LA65_1==Identifier||LA65_1==MODULE||LA65_1==NUMBER||LA65_1==REQUIRE||LA65_1==SET||LA65_1==STRING||LA65_1==THROWS||LA65_1==TYPE))
			{
				alt65 = 1;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1212:64: identifier
				{
				DebugLocation(1212, 64);
				PushFollow(Follow._identifier_in_breakStatement6654);
				identifier227=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifier227.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(65); }

			DebugLocation(1212, 81);
			PushFollow(Follow._semic_in_breakStatement6657);
			semic228=semic();
			PopFollow();
			if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("breakStatement", 68);
			LeaveRule("breakStatement", 68);
			LeaveRule_breakStatement();
		}
		DebugLocation(1213, 1);
		} finally { DebugExitRule(GrammarFileName, "breakStatement"); }
		return retval;

	}
	// $ANTLR end "breakStatement"

	partial void EnterRule_returnStatement();
	partial void LeaveRule_returnStatement();
	// $ANTLR start "returnStatement"
	// TypeScript.g3:1232:1: returnStatement : RETURN ^ ( expression )? semic !;
	[GrammarRule("returnStatement")]
	private AstParserRuleReturnScope<object, IToken> returnStatement()
	{
		EnterRule_returnStatement();
		EnterRule("returnStatement", 69);
		TraceIn("returnStatement", 69);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken RETURN229 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression230 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic231 = default(AstParserRuleReturnScope<object, IToken>);

		object RETURN229_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "returnStatement");
		DebugLocation(1232, 1);
		try
		{
			// TypeScript.g3:1233:2: ( RETURN ^ ( expression )? semic !)
			DebugEnterAlt(1);
			// TypeScript.g3:1233:4: RETURN ^ ( expression )? semic !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1233, 10);
			RETURN229=(IToken)Match(input,RETURN,Follow._RETURN_in_returnStatement6676); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RETURN229_tree = (object)adaptor.Create(RETURN229);
			root_0 = (object)adaptor.BecomeRoot(RETURN229_tree, root_0);
			}
			DebugLocation(1233, 12);
			if (state.backtracking == 0)
			{
				 PromoteEOL(null); 
			}
			DebugLocation(1233, 34);
			// TypeScript.g3:1233:34: ( expression )?
			int alt66=2;
			try { DebugEnterSubRule(66);
			try { DebugEnterDecision(66, false);
			int LA66_1 = input.LA(1);

			if ((LA66_1==ADD||LA66_1==ANY||LA66_1==CONSTRUCTOR||(LA66_1>=DEC && LA66_1<=DECLARE)||LA66_1==DELETE||LA66_1==DecimalLiteral||LA66_1==FALSE||LA66_1==FINAL||LA66_1==FUNCTION||LA66_1==GET||LA66_1==HexIntegerLiteral||LA66_1==INC||LA66_1==INV||LA66_1==Identifier||(LA66_1>=LBRACE && LA66_1<=LBRACK)||LA66_1==LPAREN||LA66_1==MODULE||(LA66_1>=NEW && LA66_1<=NOT)||(LA66_1>=NULL && LA66_1<=NUMBER)||LA66_1==OctalIntegerLiteral||LA66_1==REQUIRE||LA66_1==RegularExpressionLiteral||LA66_1==SET||(LA66_1>=STRING && LA66_1<=SUB)||LA66_1==StringLiteral||LA66_1==THIS||LA66_1==THROWS||LA66_1==TRUE||(LA66_1>=TYPE && LA66_1<=TYPEOF)||LA66_1==VOID))
			{
				alt66 = 1;
			}
			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1233:34: expression
				{
				DebugLocation(1233, 34);
				PushFollow(Follow._expression_in_returnStatement6681);
				expression230=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression230.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(66); }

			DebugLocation(1233, 51);
			PushFollow(Follow._semic_in_returnStatement6684);
			semic231=semic();
			PopFollow();
			if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("returnStatement", 69);
			LeaveRule("returnStatement", 69);
			LeaveRule_returnStatement();
		}
		DebugLocation(1234, 1);
		} finally { DebugExitRule(GrammarFileName, "returnStatement"); }
		return retval;

	}
	// $ANTLR end "returnStatement"

	partial void EnterRule_withStatement();
	partial void LeaveRule_withStatement();
	// $ANTLR start "withStatement"
	// TypeScript.g3:1240:1: withStatement : WITH ^ LPAREN ! expression RPAREN ! statement ;
	[GrammarRule("withStatement")]
	private AstParserRuleReturnScope<object, IToken> withStatement()
	{
		EnterRule_withStatement();
		EnterRule("withStatement", 70);
		TraceIn("withStatement", 70);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WITH232 = default(IToken);
		IToken LPAREN233 = default(IToken);
		IToken RPAREN235 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression234 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement236 = default(AstParserRuleReturnScope<object, IToken>);

		object WITH232_tree = default(object);
		object LPAREN233_tree = default(object);
		object RPAREN235_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "withStatement");
		DebugLocation(1240, 1);
		try
		{
			// TypeScript.g3:1241:2: ( WITH ^ LPAREN ! expression RPAREN ! statement )
			DebugEnterAlt(1);
			// TypeScript.g3:1241:4: WITH ^ LPAREN ! expression RPAREN ! statement
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1241, 8);
			WITH232=(IToken)Match(input,WITH,Follow._WITH_in_withStatement6701); if (state.failed) return retval;
			if (state.backtracking == 0) {
			WITH232_tree = (object)adaptor.Create(WITH232);
			root_0 = (object)adaptor.BecomeRoot(WITH232_tree, root_0);
			}
			DebugLocation(1241, 16);
			LPAREN233=(IToken)Match(input,LPAREN,Follow._LPAREN_in_withStatement6704); if (state.failed) return retval;
			DebugLocation(1241, 18);
			PushFollow(Follow._expression_in_withStatement6707);
			expression234=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression234.Tree);
			DebugLocation(1241, 35);
			RPAREN235=(IToken)Match(input,RPAREN,Follow._RPAREN_in_withStatement6709); if (state.failed) return retval;
			DebugLocation(1241, 37);
			PushFollow(Follow._statement_in_withStatement6712);
			statement236=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement236.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("withStatement", 70);
			LeaveRule("withStatement", 70);
			LeaveRule_withStatement();
		}
		DebugLocation(1242, 1);
		} finally { DebugExitRule(GrammarFileName, "withStatement"); }
		return retval;

	}
	// $ANTLR end "withStatement"

	partial void EnterRule_switchStatement();
	partial void LeaveRule_switchStatement();
	// $ANTLR start "switchStatement"
	// TypeScript.g3:1248:1: switchStatement : SWITCH LPAREN expression RPAREN LBRACE (c+= defaultClause |c+= caseClause )* RBRACE -> ^( SWITCH expression ( $c)* ) ;
	[GrammarRule("switchStatement")]
	private AstParserRuleReturnScope<object, IToken> switchStatement()
	{
		EnterRule_switchStatement();
		EnterRule("switchStatement", 71);
		TraceIn("switchStatement", 71);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SWITCH237 = default(IToken);
		IToken LPAREN238 = default(IToken);
		IToken RPAREN240 = default(IToken);
		IToken LBRACE241 = default(IToken);
		IToken RBRACE242 = default(IToken);
		List<object> list_c = null;
		AstParserRuleReturnScope<object, IToken> expression239 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> c = default(AstParserRuleReturnScope<object, IToken>);
		object SWITCH237_tree = default(object);
		object LPAREN238_tree = default(object);
		object RPAREN240_tree = default(object);
		object LBRACE241_tree = default(object);
		object RBRACE242_tree = default(object);
		RewriteRuleITokenStream stream_SWITCH=new RewriteRuleITokenStream(adaptor,"token SWITCH");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_defaultClause=new RewriteRuleSubtreeStream(adaptor,"rule defaultClause");
		RewriteRuleSubtreeStream stream_caseClause=new RewriteRuleSubtreeStream(adaptor,"rule caseClause");
		try { DebugEnterRule(GrammarFileName, "switchStatement");
		DebugLocation(1248, 1);
		try
		{
			// TypeScript.g3:1249:2: ( SWITCH LPAREN expression RPAREN LBRACE (c+= defaultClause |c+= caseClause )* RBRACE -> ^( SWITCH expression ( $c)* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1249:4: SWITCH LPAREN expression RPAREN LBRACE (c+= defaultClause |c+= caseClause )* RBRACE
			{
			DebugLocation(1249, 4);
			SWITCH237=(IToken)Match(input,SWITCH,Follow._SWITCH_in_switchStatement6728); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SWITCH.Add(SWITCH237);

			DebugLocation(1249, 11);
			LPAREN238=(IToken)Match(input,LPAREN,Follow._LPAREN_in_switchStatement6730); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN238);

			DebugLocation(1249, 18);
			PushFollow(Follow._expression_in_switchStatement6732);
			expression239=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression239.Tree);
			DebugLocation(1249, 29);
			RPAREN240=(IToken)Match(input,RPAREN,Follow._RPAREN_in_switchStatement6734); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN240);

			DebugLocation(1249, 36);
			LBRACE241=(IToken)Match(input,LBRACE,Follow._LBRACE_in_switchStatement6736); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACE.Add(LBRACE241);

			DebugLocation(1249, 43);
			// TypeScript.g3:1249:43: (c+= defaultClause |c+= caseClause )*
			try { DebugEnterSubRule(67);
			while (true)
			{
				int alt67=3;
				try { DebugEnterDecision(67, false);
				int LA67_1 = input.LA(1);

				if ((LA67_1==DEFAULT))
				{
					alt67 = 1;
				}
				else if ((LA67_1==CASE))
				{
					alt67 = 2;
				}


				} finally { DebugExitDecision(67); }
				switch ( alt67 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1249:44: c+= defaultClause
					{
					DebugLocation(1249, 45);
					PushFollow(Follow._defaultClause_in_switchStatement6741);
					c=defaultClause();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_defaultClause.Add(c.Tree);
					if (list_c==null) list_c=new List<object>();
					list_c.Add(c.Tree);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// TypeScript.g3:1249:62: c+= caseClause
					{
					DebugLocation(1249, 63);
					PushFollow(Follow._caseClause_in_switchStatement6746);
					c=caseClause();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_caseClause.Add(c.Tree);
					if (list_c==null) list_c=new List<object>();
					list_c.Add(c.Tree);


					}
					break;

				default:
					goto loop67;
				}
			}

			loop67:
				;

			} finally { DebugExitSubRule(67); }

			DebugLocation(1249, 79);
			RBRACE242=(IToken)Match(input,RBRACE,Follow._RBRACE_in_switchStatement6751); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACE.Add(RBRACE242);



			{
			// AST REWRITE
			// elements: SWITCH, expression, c
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: c
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_c=new RewriteRuleSubtreeStream(adaptor,"token c",list_c);
			root_0 = (object)adaptor.Nil();
			// 1250:2: -> ^( SWITCH expression ( $c)* )
			{
				DebugLocation(1250, 5);
				// TypeScript.g3:1250:5: ^( SWITCH expression ( $c)* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1250, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_SWITCH.NextNode(), root_1);

				DebugLocation(1250, 15);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(1250, 27);
				// TypeScript.g3:1250:27: ( $c)*
				while ( stream_c.HasNext )
				{
					DebugLocation(1250, 27);
					adaptor.AddChild(root_1, stream_c.NextTree());

				}
				stream_c.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switchStatement", 71);
			LeaveRule("switchStatement", 71);
			LeaveRule_switchStatement();
		}
		DebugLocation(1251, 1);
		} finally { DebugExitRule(GrammarFileName, "switchStatement"); }
		return retval;

	}
	// $ANTLR end "switchStatement"

	partial void EnterRule_caseClause();
	partial void LeaveRule_caseClause();
	// $ANTLR start "caseClause"
	// TypeScript.g3:1253:1: caseClause : CASE ^ expression COLON ! ( statement )* ;
	[GrammarRule("caseClause")]
	private AstParserRuleReturnScope<object, IToken> caseClause()
	{
		EnterRule_caseClause();
		EnterRule("caseClause", 72);
		TraceIn("caseClause", 72);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CASE243 = default(IToken);
		IToken COLON245 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression244 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement246 = default(AstParserRuleReturnScope<object, IToken>);

		object CASE243_tree = default(object);
		object COLON245_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "caseClause");
		DebugLocation(1253, 1);
		try
		{
			// TypeScript.g3:1254:2: ( CASE ^ expression COLON ! ( statement )* )
			DebugEnterAlt(1);
			// TypeScript.g3:1254:4: CASE ^ expression COLON ! ( statement )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1254, 8);
			CASE243=(IToken)Match(input,CASE,Follow._CASE_in_caseClause6777); if (state.failed) return retval;
			if (state.backtracking == 0) {
			CASE243_tree = (object)adaptor.Create(CASE243);
			root_0 = (object)adaptor.BecomeRoot(CASE243_tree, root_0);
			}
			DebugLocation(1254, 10);
			PushFollow(Follow._expression_in_caseClause6780);
			expression244=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression244.Tree);
			DebugLocation(1254, 26);
			COLON245=(IToken)Match(input,COLON,Follow._COLON_in_caseClause6782); if (state.failed) return retval;
			DebugLocation(1254, 28);
			// TypeScript.g3:1254:28: ( statement )*
			try { DebugEnterSubRule(68);
			while (true)
			{
				int alt68=2;
				try { DebugEnterDecision(68, false);
				int LA68_1 = input.LA(1);

				if ((LA68_1==ADD||LA68_1==ANY||LA68_1==BREAK||LA68_1==CONSTRUCTOR||LA68_1==CONTINUE||(LA68_1>=DEC && LA68_1<=DECLARE)||LA68_1==DELETE||LA68_1==DO||LA68_1==DecimalLiteral||LA68_1==FALSE||LA68_1==FINAL||LA68_1==FOR||LA68_1==FUNCTION||LA68_1==GET||(LA68_1>=HexIntegerLiteral && LA68_1<=IF)||LA68_1==INC||LA68_1==INV||LA68_1==Identifier||(LA68_1>=LBRACE && LA68_1<=LBRACK)||LA68_1==LPAREN||LA68_1==MODULE||(LA68_1>=NEW && LA68_1<=NOT)||(LA68_1>=NULL && LA68_1<=NUMBER)||LA68_1==OctalIntegerLiteral||(LA68_1>=REQUIRE && LA68_1<=RETURN)||LA68_1==RegularExpressionLiteral||(LA68_1>=SEMIC && LA68_1<=SET)||(LA68_1>=STRING && LA68_1<=SUB)||LA68_1==SWITCH||LA68_1==StringLiteral||(LA68_1>=THIS && LA68_1<=THROWS)||(LA68_1>=TRUE && LA68_1<=TRY)||(LA68_1>=TYPE && LA68_1<=TYPEOF)||LA68_1==VAR||LA68_1==VOID||(LA68_1>=WHILE && LA68_1<=WITH)))
				{
					alt68 = 1;
				}


				} finally { DebugExitDecision(68); }
				switch ( alt68 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1254:28: statement
					{
					DebugLocation(1254, 28);
					PushFollow(Follow._statement_in_caseClause6785);
					statement246=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, statement246.Tree);

					}
					break;

				default:
					goto loop68;
				}
			}

			loop68:
				;

			} finally { DebugExitSubRule(68); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseClause", 72);
			LeaveRule("caseClause", 72);
			LeaveRule_caseClause();
		}
		DebugLocation(1255, 1);
		} finally { DebugExitRule(GrammarFileName, "caseClause"); }
		return retval;

	}
	// $ANTLR end "caseClause"

	partial void EnterRule_defaultClause();
	partial void LeaveRule_defaultClause();
	// $ANTLR start "defaultClause"
	// TypeScript.g3:1257:1: defaultClause : DEFAULT ^ COLON ! ( statement )* ;
	[GrammarRule("defaultClause")]
	private AstParserRuleReturnScope<object, IToken> defaultClause()
	{
		EnterRule_defaultClause();
		EnterRule("defaultClause", 73);
		TraceIn("defaultClause", 73);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DEFAULT247 = default(IToken);
		IToken COLON248 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement249 = default(AstParserRuleReturnScope<object, IToken>);

		object DEFAULT247_tree = default(object);
		object COLON248_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "defaultClause");
		DebugLocation(1257, 1);
		try
		{
			// TypeScript.g3:1258:2: ( DEFAULT ^ COLON ! ( statement )* )
			DebugEnterAlt(1);
			// TypeScript.g3:1258:4: DEFAULT ^ COLON ! ( statement )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1258, 11);
			DEFAULT247=(IToken)Match(input,DEFAULT,Follow._DEFAULT_in_defaultClause6798); if (state.failed) return retval;
			if (state.backtracking == 0) {
			DEFAULT247_tree = (object)adaptor.Create(DEFAULT247);
			root_0 = (object)adaptor.BecomeRoot(DEFAULT247_tree, root_0);
			}
			DebugLocation(1258, 18);
			COLON248=(IToken)Match(input,COLON,Follow._COLON_in_defaultClause6801); if (state.failed) return retval;
			DebugLocation(1258, 20);
			// TypeScript.g3:1258:20: ( statement )*
			try { DebugEnterSubRule(69);
			while (true)
			{
				int alt69=2;
				try { DebugEnterDecision(69, false);
				int LA69_1 = input.LA(1);

				if ((LA69_1==ADD||LA69_1==ANY||LA69_1==BREAK||LA69_1==CONSTRUCTOR||LA69_1==CONTINUE||(LA69_1>=DEC && LA69_1<=DECLARE)||LA69_1==DELETE||LA69_1==DO||LA69_1==DecimalLiteral||LA69_1==FALSE||LA69_1==FINAL||LA69_1==FOR||LA69_1==FUNCTION||LA69_1==GET||(LA69_1>=HexIntegerLiteral && LA69_1<=IF)||LA69_1==INC||LA69_1==INV||LA69_1==Identifier||(LA69_1>=LBRACE && LA69_1<=LBRACK)||LA69_1==LPAREN||LA69_1==MODULE||(LA69_1>=NEW && LA69_1<=NOT)||(LA69_1>=NULL && LA69_1<=NUMBER)||LA69_1==OctalIntegerLiteral||(LA69_1>=REQUIRE && LA69_1<=RETURN)||LA69_1==RegularExpressionLiteral||(LA69_1>=SEMIC && LA69_1<=SET)||(LA69_1>=STRING && LA69_1<=SUB)||LA69_1==SWITCH||LA69_1==StringLiteral||(LA69_1>=THIS && LA69_1<=THROWS)||(LA69_1>=TRUE && LA69_1<=TRY)||(LA69_1>=TYPE && LA69_1<=TYPEOF)||LA69_1==VAR||LA69_1==VOID||(LA69_1>=WHILE && LA69_1<=WITH)))
				{
					alt69 = 1;
				}


				} finally { DebugExitDecision(69); }
				switch ( alt69 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1258:20: statement
					{
					DebugLocation(1258, 20);
					PushFollow(Follow._statement_in_defaultClause6804);
					statement249=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, statement249.Tree);

					}
					break;

				default:
					goto loop69;
				}
			}

			loop69:
				;

			} finally { DebugExitSubRule(69); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("defaultClause", 73);
			LeaveRule("defaultClause", 73);
			LeaveRule_defaultClause();
		}
		DebugLocation(1259, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultClause"); }
		return retval;

	}
	// $ANTLR end "defaultClause"

	partial void EnterRule_labelledStatement();
	partial void LeaveRule_labelledStatement();
	// $ANTLR start "labelledStatement"
	// TypeScript.g3:1265:1: labelledStatement : identifier COLON statement -> ^( LABELLED identifier statement ) ;
	[GrammarRule("labelledStatement")]
	private AstParserRuleReturnScope<object, IToken> labelledStatement()
	{
		EnterRule_labelledStatement();
		EnterRule("labelledStatement", 74);
		TraceIn("labelledStatement", 74);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COLON251 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier250 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement252 = default(AstParserRuleReturnScope<object, IToken>);

		object COLON251_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "labelledStatement");
		DebugLocation(1265, 1);
		try
		{
			// TypeScript.g3:1266:2: ( identifier COLON statement -> ^( LABELLED identifier statement ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1266:4: identifier COLON statement
			{
			DebugLocation(1266, 4);
			PushFollow(Follow._identifier_in_labelledStatement6821);
			identifier250=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier250.Tree);
			DebugLocation(1266, 15);
			COLON251=(IToken)Match(input,COLON,Follow._COLON_in_labelledStatement6823); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON251);

			DebugLocation(1266, 21);
			PushFollow(Follow._statement_in_labelledStatement6825);
			statement252=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement252.Tree);


			{
			// AST REWRITE
			// elements: identifier, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1267:2: -> ^( LABELLED identifier statement )
			{
				DebugLocation(1267, 5);
				// TypeScript.g3:1267:5: ^( LABELLED identifier statement )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1267, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LABELLED, "LABELLED"), root_1);

				DebugLocation(1267, 17);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(1267, 28);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("labelledStatement", 74);
			LeaveRule("labelledStatement", 74);
			LeaveRule_labelledStatement();
		}
		DebugLocation(1268, 1);
		} finally { DebugExitRule(GrammarFileName, "labelledStatement"); }
		return retval;

	}
	// $ANTLR end "labelledStatement"

	partial void EnterRule_throwStatement();
	partial void LeaveRule_throwStatement();
	// $ANTLR start "throwStatement"
	// TypeScript.g3:1289:1: throwStatement : THROW ^ expression semic !;
	[GrammarRule("throwStatement")]
	private AstParserRuleReturnScope<object, IToken> throwStatement()
	{
		EnterRule_throwStatement();
		EnterRule("throwStatement", 75);
		TraceIn("throwStatement", 75);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken THROW253 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression254 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic255 = default(AstParserRuleReturnScope<object, IToken>);

		object THROW253_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "throwStatement");
		DebugLocation(1289, 1);
		try
		{
			// TypeScript.g3:1290:2: ( THROW ^ expression semic !)
			DebugEnterAlt(1);
			// TypeScript.g3:1290:4: THROW ^ expression semic !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1290, 9);
			THROW253=(IToken)Match(input,THROW,Follow._THROW_in_throwStatement6856); if (state.failed) return retval;
			if (state.backtracking == 0) {
			THROW253_tree = (object)adaptor.Create(THROW253);
			root_0 = (object)adaptor.BecomeRoot(THROW253_tree, root_0);
			}
			DebugLocation(1290, 11);
			if (state.backtracking == 0)
			{
				 PromoteEOL(null); 
			}
			DebugLocation(1290, 33);
			PushFollow(Follow._expression_in_throwStatement6861);
			expression254=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression254.Tree);
			DebugLocation(1290, 49);
			PushFollow(Follow._semic_in_throwStatement6863);
			semic255=semic();
			PopFollow();
			if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("throwStatement", 75);
			LeaveRule("throwStatement", 75);
			LeaveRule_throwStatement();
		}
		DebugLocation(1291, 1);
		} finally { DebugExitRule(GrammarFileName, "throwStatement"); }
		return retval;

	}
	// $ANTLR end "throwStatement"

	partial void EnterRule_tryStatement();
	partial void LeaveRule_tryStatement();
	// $ANTLR start "tryStatement"
	// TypeScript.g3:1297:1: tryStatement : TRY ^ block ( catchClause ( finallyClause )? | finallyClause ) ;
	[GrammarRule("tryStatement")]
	private AstParserRuleReturnScope<object, IToken> tryStatement()
	{
		EnterRule_tryStatement();
		EnterRule("tryStatement", 76);
		TraceIn("tryStatement", 76);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TRY256 = default(IToken);
		AstParserRuleReturnScope<object, IToken> block257 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> catchClause258 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> finallyClause259 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> finallyClause260 = default(AstParserRuleReturnScope<object, IToken>);

		object TRY256_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "tryStatement");
		DebugLocation(1297, 1);
		try
		{
			// TypeScript.g3:1298:2: ( TRY ^ block ( catchClause ( finallyClause )? | finallyClause ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1298:4: TRY ^ block ( catchClause ( finallyClause )? | finallyClause )
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1298, 7);
			TRY256=(IToken)Match(input,TRY,Follow._TRY_in_tryStatement6880); if (state.failed) return retval;
			if (state.backtracking == 0) {
			TRY256_tree = (object)adaptor.Create(TRY256);
			root_0 = (object)adaptor.BecomeRoot(TRY256_tree, root_0);
			}
			DebugLocation(1298, 9);
			PushFollow(Follow._block_in_tryStatement6883);
			block257=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, block257.Tree);
			DebugLocation(1298, 15);
			// TypeScript.g3:1298:15: ( catchClause ( finallyClause )? | finallyClause )
			int alt71=2;
			try { DebugEnterSubRule(71);
			try { DebugEnterDecision(71, false);
			int LA71_1 = input.LA(1);

			if ((LA71_1==CATCH))
			{
				alt71 = 1;
			}
			else if ((LA71_1==FINALLY))
			{
				alt71 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 71, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(71); }
			switch (alt71)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1298:17: catchClause ( finallyClause )?
				{
				DebugLocation(1298, 17);
				PushFollow(Follow._catchClause_in_tryStatement6887);
				catchClause258=catchClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, catchClause258.Tree);
				DebugLocation(1298, 29);
				// TypeScript.g3:1298:29: ( finallyClause )?
				int alt70=2;
				try { DebugEnterSubRule(70);
				try { DebugEnterDecision(70, false);
				int LA70_1 = input.LA(1);

				if ((LA70_1==FINALLY))
				{
					alt70 = 1;
				}
				} finally { DebugExitDecision(70); }
				switch (alt70)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1298:29: finallyClause
					{
					DebugLocation(1298, 29);
					PushFollow(Follow._finallyClause_in_tryStatement6889);
					finallyClause259=finallyClause();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, finallyClause259.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(70); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1298:46: finallyClause
				{
				DebugLocation(1298, 46);
				PushFollow(Follow._finallyClause_in_tryStatement6894);
				finallyClause260=finallyClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, finallyClause260.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(71); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tryStatement", 76);
			LeaveRule("tryStatement", 76);
			LeaveRule_tryStatement();
		}
		DebugLocation(1299, 1);
		} finally { DebugExitRule(GrammarFileName, "tryStatement"); }
		return retval;

	}
	// $ANTLR end "tryStatement"

	partial void EnterRule_catchClause();
	partial void LeaveRule_catchClause();
	// $ANTLR start "catchClause"
	// TypeScript.g3:1301:1: catchClause : CATCH ^ LPAREN ! identifier RPAREN ! block ;
	[GrammarRule("catchClause")]
	private AstParserRuleReturnScope<object, IToken> catchClause()
	{
		EnterRule_catchClause();
		EnterRule("catchClause", 77);
		TraceIn("catchClause", 77);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CATCH261 = default(IToken);
		IToken LPAREN262 = default(IToken);
		IToken RPAREN264 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier263 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> block265 = default(AstParserRuleReturnScope<object, IToken>);

		object CATCH261_tree = default(object);
		object LPAREN262_tree = default(object);
		object RPAREN264_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "catchClause");
		DebugLocation(1301, 1);
		try
		{
			// TypeScript.g3:1302:2: ( CATCH ^ LPAREN ! identifier RPAREN ! block )
			DebugEnterAlt(1);
			// TypeScript.g3:1302:4: CATCH ^ LPAREN ! identifier RPAREN ! block
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1302, 9);
			CATCH261=(IToken)Match(input,CATCH,Follow._CATCH_in_catchClause6908); if (state.failed) return retval;
			if (state.backtracking == 0) {
			CATCH261_tree = (object)adaptor.Create(CATCH261);
			root_0 = (object)adaptor.BecomeRoot(CATCH261_tree, root_0);
			}
			DebugLocation(1302, 17);
			LPAREN262=(IToken)Match(input,LPAREN,Follow._LPAREN_in_catchClause6911); if (state.failed) return retval;
			DebugLocation(1302, 19);
			PushFollow(Follow._identifier_in_catchClause6914);
			identifier263=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, identifier263.Tree);
			DebugLocation(1302, 36);
			RPAREN264=(IToken)Match(input,RPAREN,Follow._RPAREN_in_catchClause6916); if (state.failed) return retval;
			DebugLocation(1302, 38);
			PushFollow(Follow._block_in_catchClause6919);
			block265=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, block265.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("catchClause", 77);
			LeaveRule("catchClause", 77);
			LeaveRule_catchClause();
		}
		DebugLocation(1303, 1);
		} finally { DebugExitRule(GrammarFileName, "catchClause"); }
		return retval;

	}
	// $ANTLR end "catchClause"

	partial void EnterRule_finallyClause();
	partial void LeaveRule_finallyClause();
	// $ANTLR start "finallyClause"
	// TypeScript.g3:1305:1: finallyClause : FINALLY ^ block ;
	[GrammarRule("finallyClause")]
	private AstParserRuleReturnScope<object, IToken> finallyClause()
	{
		EnterRule_finallyClause();
		EnterRule("finallyClause", 78);
		TraceIn("finallyClause", 78);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FINALLY266 = default(IToken);
		AstParserRuleReturnScope<object, IToken> block267 = default(AstParserRuleReturnScope<object, IToken>);

		object FINALLY266_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "finallyClause");
		DebugLocation(1305, 1);
		try
		{
			// TypeScript.g3:1306:2: ( FINALLY ^ block )
			DebugEnterAlt(1);
			// TypeScript.g3:1306:4: FINALLY ^ block
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1306, 11);
			FINALLY266=(IToken)Match(input,FINALLY,Follow._FINALLY_in_finallyClause6931); if (state.failed) return retval;
			if (state.backtracking == 0) {
			FINALLY266_tree = (object)adaptor.Create(FINALLY266);
			root_0 = (object)adaptor.BecomeRoot(FINALLY266_tree, root_0);
			}
			DebugLocation(1306, 13);
			PushFollow(Follow._block_in_finallyClause6934);
			block267=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, block267.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("finallyClause", 78);
			LeaveRule("finallyClause", 78);
			LeaveRule_finallyClause();
		}
		DebugLocation(1307, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyClause"); }
		return retval;

	}
	// $ANTLR end "finallyClause"

	partial void EnterRule_functionDeclaration();
	partial void LeaveRule_functionDeclaration();
	// $ANTLR start "functionDeclaration"
	// TypeScript.g3:1319:1: functionDeclaration : FUNCTION name= identifier ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? ( functionBody )? semic -> ^( FUNCTIONDECLARATION $name ( typeParameters )? ( parameterList )? ( typeAnnotation )? ( functionBody )? ) ;
	[GrammarRule("functionDeclaration")]
	private AstParserRuleReturnScope<object, IToken> functionDeclaration()
	{
		EnterRule_functionDeclaration();
		EnterRule("functionDeclaration", 79);
		TraceIn("functionDeclaration", 79);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FUNCTION268 = default(IToken);
		IToken LPAREN270 = default(IToken);
		IToken RPAREN272 = default(IToken);
		AstParserRuleReturnScope<object, IToken> name = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeParameters269 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parameterList271 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation273 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionBody274 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic275 = default(AstParserRuleReturnScope<object, IToken>);

		object FUNCTION268_tree = default(object);
		object LPAREN270_tree = default(object);
		object RPAREN272_tree = default(object);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_typeParameters=new RewriteRuleSubtreeStream(adaptor,"rule typeParameters");
		RewriteRuleSubtreeStream stream_parameterList=new RewriteRuleSubtreeStream(adaptor,"rule parameterList");
		RewriteRuleSubtreeStream stream_typeAnnotation=new RewriteRuleSubtreeStream(adaptor,"rule typeAnnotation");
		RewriteRuleSubtreeStream stream_functionBody=new RewriteRuleSubtreeStream(adaptor,"rule functionBody");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		try { DebugEnterRule(GrammarFileName, "functionDeclaration");
		DebugLocation(1319, 1);
		try
		{
			// TypeScript.g3:1320:2: ( FUNCTION name= identifier ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? ( functionBody )? semic -> ^( FUNCTIONDECLARATION $name ( typeParameters )? ( parameterList )? ( typeAnnotation )? ( functionBody )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1320:4: FUNCTION name= identifier ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? ( functionBody )? semic
			{
			DebugLocation(1320, 4);
			FUNCTION268=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_functionDeclaration6955); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION268);

			DebugLocation(1320, 17);
			PushFollow(Follow._identifier_in_functionDeclaration6959);
			name=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(name.Tree);
			DebugLocation(1320, 29);
			// TypeScript.g3:1320:29: ( typeParameters )?
			int alt72=2;
			try { DebugEnterSubRule(72);
			try { DebugEnterDecision(72, false);
			int LA72_1 = input.LA(1);

			if ((LA72_1==LT))
			{
				alt72 = 1;
			}
			} finally { DebugExitDecision(72); }
			switch (alt72)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1320:29: typeParameters
				{
				DebugLocation(1320, 29);
				PushFollow(Follow._typeParameters_in_functionDeclaration6961);
				typeParameters269=typeParameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeParameters.Add(typeParameters269.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(72); }

			DebugLocation(1320, 45);
			LPAREN270=(IToken)Match(input,LPAREN,Follow._LPAREN_in_functionDeclaration6964); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN270);

			DebugLocation(1320, 52);
			// TypeScript.g3:1320:52: ( parameterList )?
			int alt73=2;
			try { DebugEnterSubRule(73);
			try { DebugEnterDecision(73, false);
			int LA73_1 = input.LA(1);

			if ((LA73_1==ANY||LA73_1==CONSTRUCTOR||LA73_1==DECLARE||LA73_1==ELLIPSIS||LA73_1==FINAL||LA73_1==GET||LA73_1==Identifier||LA73_1==MODULE||LA73_1==NUMBER||LA73_1==PRIVATE||LA73_1==PROTECTED||LA73_1==PUBLIC||LA73_1==REQUIRE||LA73_1==SET||LA73_1==STRING||LA73_1==THROWS||LA73_1==TYPE))
			{
				alt73 = 1;
			}
			} finally { DebugExitDecision(73); }
			switch (alt73)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1320:52: parameterList
				{
				DebugLocation(1320, 52);
				PushFollow(Follow._parameterList_in_functionDeclaration6966);
				parameterList271=parameterList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterList.Add(parameterList271.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(73); }

			DebugLocation(1320, 67);
			RPAREN272=(IToken)Match(input,RPAREN,Follow._RPAREN_in_functionDeclaration6969); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN272);

			DebugLocation(1320, 74);
			// TypeScript.g3:1320:74: ( typeAnnotation )?
			int alt74=2;
			try { DebugEnterSubRule(74);
			try { DebugEnterDecision(74, false);
			int LA74_1 = input.LA(1);

			if ((LA74_1==COLON))
			{
				alt74 = 1;
			}
			} finally { DebugExitDecision(74); }
			switch (alt74)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1320:74: typeAnnotation
				{
				DebugLocation(1320, 74);
				PushFollow(Follow._typeAnnotation_in_functionDeclaration6971);
				typeAnnotation273=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation273.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(74); }

			DebugLocation(1320, 90);
			// TypeScript.g3:1320:90: ( functionBody )?
			int alt75=2;
			try { DebugEnterSubRule(75);
			try { DebugEnterDecision(75, false);
			int LA75_1 = input.LA(1);

			if ((LA75_1==LBRACE))
			{
				alt75 = 1;
			}
			} finally { DebugExitDecision(75); }
			switch (alt75)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1320:90: functionBody
				{
				DebugLocation(1320, 90);
				PushFollow(Follow._functionBody_in_functionDeclaration6974);
				functionBody274=functionBody();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_functionBody.Add(functionBody274.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(75); }

			DebugLocation(1320, 104);
			PushFollow(Follow._semic_in_functionDeclaration6977);
			semic275=semic();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semic.Add(semic275.Tree);


			{
			// AST REWRITE
			// elements: name, typeParameters, parameterList, typeAnnotation, functionBody
			// token labels: 
			// rule labels: name, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name",name!=null?name.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1321:2: -> ^( FUNCTIONDECLARATION $name ( typeParameters )? ( parameterList )? ( typeAnnotation )? ( functionBody )? )
			{
				DebugLocation(1321, 5);
				// TypeScript.g3:1321:5: ^( FUNCTIONDECLARATION $name ( typeParameters )? ( parameterList )? ( typeAnnotation )? ( functionBody )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1321, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTIONDECLARATION, "FUNCTIONDECLARATION"), root_1);

				DebugLocation(1321, 29);
				adaptor.AddChild(root_1, stream_name.NextTree());
				DebugLocation(1321, 34);
				// TypeScript.g3:1321:34: ( typeParameters )?
				if (stream_typeParameters.HasNext)
				{
					DebugLocation(1321, 34);
					adaptor.AddChild(root_1, stream_typeParameters.NextTree());

				}
				stream_typeParameters.Reset();
				DebugLocation(1321, 50);
				// TypeScript.g3:1321:50: ( parameterList )?
				if (stream_parameterList.HasNext)
				{
					DebugLocation(1321, 50);
					adaptor.AddChild(root_1, stream_parameterList.NextTree());

				}
				stream_parameterList.Reset();
				DebugLocation(1321, 65);
				// TypeScript.g3:1321:65: ( typeAnnotation )?
				if (stream_typeAnnotation.HasNext)
				{
					DebugLocation(1321, 65);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

				}
				stream_typeAnnotation.Reset();
				DebugLocation(1321, 81);
				// TypeScript.g3:1321:81: ( functionBody )?
				if (stream_functionBody.HasNext)
				{
					DebugLocation(1321, 81);
					adaptor.AddChild(root_1, stream_functionBody.NextTree());

				}
				stream_functionBody.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionDeclaration", 79);
			LeaveRule("functionDeclaration", 79);
			LeaveRule_functionDeclaration();
		}
		DebugLocation(1322, 1);
		} finally { DebugExitRule(GrammarFileName, "functionDeclaration"); }
		return retval;

	}
	// $ANTLR end "functionDeclaration"

	partial void EnterRule_functionExpression();
	partial void LeaveRule_functionExpression();
	// $ANTLR start "functionExpression"
	// TypeScript.g3:1324:1: functionExpression : FUNCTION (name= identifier )? ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? functionBody -> ^( FUNCTION ( $name)? ( typeParameters )? ( parameterList )? ( typeAnnotation )? functionBody ) ;
	[GrammarRule("functionExpression")]
	private AstParserRuleReturnScope<object, IToken> functionExpression()
	{
		EnterRule_functionExpression();
		EnterRule("functionExpression", 80);
		TraceIn("functionExpression", 80);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FUNCTION276 = default(IToken);
		IToken LPAREN278 = default(IToken);
		IToken RPAREN280 = default(IToken);
		AstParserRuleReturnScope<object, IToken> name = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeParameters277 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parameterList279 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation281 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionBody282 = default(AstParserRuleReturnScope<object, IToken>);

		object FUNCTION276_tree = default(object);
		object LPAREN278_tree = default(object);
		object RPAREN280_tree = default(object);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_typeParameters=new RewriteRuleSubtreeStream(adaptor,"rule typeParameters");
		RewriteRuleSubtreeStream stream_parameterList=new RewriteRuleSubtreeStream(adaptor,"rule parameterList");
		RewriteRuleSubtreeStream stream_typeAnnotation=new RewriteRuleSubtreeStream(adaptor,"rule typeAnnotation");
		RewriteRuleSubtreeStream stream_functionBody=new RewriteRuleSubtreeStream(adaptor,"rule functionBody");
		try { DebugEnterRule(GrammarFileName, "functionExpression");
		DebugLocation(1324, 1);
		try
		{
			// TypeScript.g3:1325:2: ( FUNCTION (name= identifier )? ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? functionBody -> ^( FUNCTION ( $name)? ( typeParameters )? ( parameterList )? ( typeAnnotation )? functionBody ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1325:4: FUNCTION (name= identifier )? ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? functionBody
			{
			DebugLocation(1325, 4);
			FUNCTION276=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_functionExpression7012); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION276);

			DebugLocation(1325, 17);
			// TypeScript.g3:1325:17: (name= identifier )?
			int alt76=2;
			try { DebugEnterSubRule(76);
			try { DebugEnterDecision(76, false);
			int LA76_1 = input.LA(1);

			if ((LA76_1==ANY||LA76_1==CONSTRUCTOR||LA76_1==DECLARE||LA76_1==FINAL||LA76_1==GET||LA76_1==Identifier||LA76_1==MODULE||LA76_1==NUMBER||LA76_1==REQUIRE||LA76_1==SET||LA76_1==STRING||LA76_1==THROWS||LA76_1==TYPE))
			{
				alt76 = 1;
			}
			} finally { DebugExitDecision(76); }
			switch (alt76)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1325:17: name= identifier
				{
				DebugLocation(1325, 17);
				PushFollow(Follow._identifier_in_functionExpression7016);
				name=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_identifier.Add(name.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(76); }

			DebugLocation(1325, 30);
			// TypeScript.g3:1325:30: ( typeParameters )?
			int alt77=2;
			try { DebugEnterSubRule(77);
			try { DebugEnterDecision(77, false);
			int LA77_1 = input.LA(1);

			if ((LA77_1==LT))
			{
				alt77 = 1;
			}
			} finally { DebugExitDecision(77); }
			switch (alt77)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1325:30: typeParameters
				{
				DebugLocation(1325, 30);
				PushFollow(Follow._typeParameters_in_functionExpression7019);
				typeParameters277=typeParameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeParameters.Add(typeParameters277.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(77); }

			DebugLocation(1325, 46);
			LPAREN278=(IToken)Match(input,LPAREN,Follow._LPAREN_in_functionExpression7022); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN278);

			DebugLocation(1325, 53);
			// TypeScript.g3:1325:53: ( parameterList )?
			int alt78=2;
			try { DebugEnterSubRule(78);
			try { DebugEnterDecision(78, false);
			int LA78_1 = input.LA(1);

			if ((LA78_1==ANY||LA78_1==CONSTRUCTOR||LA78_1==DECLARE||LA78_1==ELLIPSIS||LA78_1==FINAL||LA78_1==GET||LA78_1==Identifier||LA78_1==MODULE||LA78_1==NUMBER||LA78_1==PRIVATE||LA78_1==PROTECTED||LA78_1==PUBLIC||LA78_1==REQUIRE||LA78_1==SET||LA78_1==STRING||LA78_1==THROWS||LA78_1==TYPE))
			{
				alt78 = 1;
			}
			} finally { DebugExitDecision(78); }
			switch (alt78)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1325:53: parameterList
				{
				DebugLocation(1325, 53);
				PushFollow(Follow._parameterList_in_functionExpression7024);
				parameterList279=parameterList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterList.Add(parameterList279.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(78); }

			DebugLocation(1325, 68);
			RPAREN280=(IToken)Match(input,RPAREN,Follow._RPAREN_in_functionExpression7027); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN280);

			DebugLocation(1325, 75);
			// TypeScript.g3:1325:75: ( typeAnnotation )?
			int alt79=2;
			try { DebugEnterSubRule(79);
			try { DebugEnterDecision(79, false);
			int LA79_1 = input.LA(1);

			if ((LA79_1==COLON))
			{
				alt79 = 1;
			}
			} finally { DebugExitDecision(79); }
			switch (alt79)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1325:75: typeAnnotation
				{
				DebugLocation(1325, 75);
				PushFollow(Follow._typeAnnotation_in_functionExpression7029);
				typeAnnotation281=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation281.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(79); }

			DebugLocation(1325, 91);
			PushFollow(Follow._functionBody_in_functionExpression7032);
			functionBody282=functionBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functionBody.Add(functionBody282.Tree);


			{
			// AST REWRITE
			// elements: FUNCTION, name, typeParameters, parameterList, typeAnnotation, functionBody
			// token labels: 
			// rule labels: name, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name",name!=null?name.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1326:2: -> ^( FUNCTION ( $name)? ( typeParameters )? ( parameterList )? ( typeAnnotation )? functionBody )
			{
				DebugLocation(1326, 5);
				// TypeScript.g3:1326:5: ^( FUNCTION ( $name)? ( typeParameters )? ( parameterList )? ( typeAnnotation )? functionBody )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1326, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_FUNCTION.NextNode(), root_1);

				DebugLocation(1326, 18);
				// TypeScript.g3:1326:18: ( $name)?
				if (stream_name.HasNext)
				{
					DebugLocation(1326, 18);
					adaptor.AddChild(root_1, stream_name.NextTree());

				}
				stream_name.Reset();
				DebugLocation(1326, 24);
				// TypeScript.g3:1326:24: ( typeParameters )?
				if (stream_typeParameters.HasNext)
				{
					DebugLocation(1326, 24);
					adaptor.AddChild(root_1, stream_typeParameters.NextTree());

				}
				stream_typeParameters.Reset();
				DebugLocation(1326, 40);
				// TypeScript.g3:1326:40: ( parameterList )?
				if (stream_parameterList.HasNext)
				{
					DebugLocation(1326, 40);
					adaptor.AddChild(root_1, stream_parameterList.NextTree());

				}
				stream_parameterList.Reset();
				DebugLocation(1326, 55);
				// TypeScript.g3:1326:55: ( typeAnnotation )?
				if (stream_typeAnnotation.HasNext)
				{
					DebugLocation(1326, 55);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

				}
				stream_typeAnnotation.Reset();
				DebugLocation(1326, 72);
				adaptor.AddChild(root_1, stream_functionBody.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionExpression", 80);
			LeaveRule("functionExpression", 80);
			LeaveRule_functionExpression();
		}
		DebugLocation(1327, 1);
		} finally { DebugExitRule(GrammarFileName, "functionExpression"); }
		return retval;

	}
	// $ANTLR end "functionExpression"

	partial void EnterRule_functionBody();
	partial void LeaveRule_functionBody();
	// $ANTLR start "functionBody"
	// TypeScript.g3:1329:1: functionBody : lb= LBRACE ( sourceElement )* RBRACE -> ^( BLOCK[$lb, \"BLOCK\"] ( sourceElement )* ) ;
	[GrammarRule("functionBody")]
	private AstParserRuleReturnScope<object, IToken> functionBody()
	{
		EnterRule_functionBody();
		EnterRule("functionBody", 81);
		TraceIn("functionBody", 81);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken lb = default(IToken);
		IToken RBRACE284 = default(IToken);
		AstParserRuleReturnScope<object, IToken> sourceElement283 = default(AstParserRuleReturnScope<object, IToken>);

		object lb_tree = default(object);
		object RBRACE284_tree = default(object);
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_sourceElement=new RewriteRuleSubtreeStream(adaptor,"rule sourceElement");
		try { DebugEnterRule(GrammarFileName, "functionBody");
		DebugLocation(1329, 1);
		try
		{
			// TypeScript.g3:1330:2: (lb= LBRACE ( sourceElement )* RBRACE -> ^( BLOCK[$lb, \"BLOCK\"] ( sourceElement )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1330:4: lb= LBRACE ( sourceElement )* RBRACE
			{
			DebugLocation(1330, 6);
			lb=(IToken)Match(input,LBRACE,Follow._LBRACE_in_functionBody7070); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACE.Add(lb);

			DebugLocation(1330, 14);
			// TypeScript.g3:1330:14: ( sourceElement )*
			try { DebugEnterSubRule(80);
			while (true)
			{
				int alt80=2;
				try { DebugEnterDecision(80, false);
				int LA80_1 = input.LA(1);

				if ((LA80_1==ADD||LA80_1==ANY||LA80_1==BREAK||LA80_1==CLASS||(LA80_1>=CONST && LA80_1<=CONSTRUCTOR)||LA80_1==CONTINUE||(LA80_1>=DEC && LA80_1<=DECLARE)||LA80_1==DELETE||LA80_1==DO||LA80_1==DecimalLiteral||LA80_1==ENUM||LA80_1==FALSE||LA80_1==FINAL||LA80_1==FOR||LA80_1==FUNCTION||LA80_1==GET||(LA80_1>=HexIntegerLiteral && LA80_1<=IF)||LA80_1==IMPORT||LA80_1==INC||(LA80_1>=INTERFACE && LA80_1<=INV)||LA80_1==Identifier||(LA80_1>=LBRACE && LA80_1<=LBRACK)||LA80_1==LPAREN||LA80_1==MODULE||(LA80_1>=NEW && LA80_1<=NOT)||(LA80_1>=NULL && LA80_1<=NUMBER)||LA80_1==OctalIntegerLiteral||(LA80_1>=REQUIRE && LA80_1<=RETURN)||LA80_1==RegularExpressionLiteral||(LA80_1>=SEMIC && LA80_1<=SET)||(LA80_1>=STRING && LA80_1<=SUB)||LA80_1==SWITCH||LA80_1==StringLiteral||(LA80_1>=THIS && LA80_1<=THROWS)||(LA80_1>=TRUE && LA80_1<=TRY)||(LA80_1>=TYPE && LA80_1<=TYPEOF)||LA80_1==VAR||LA80_1==VOID||(LA80_1>=WHILE && LA80_1<=WITH)))
				{
					alt80 = 1;
				}


				} finally { DebugExitDecision(80); }
				switch ( alt80 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1330:14: sourceElement
					{
					DebugLocation(1330, 14);
					PushFollow(Follow._sourceElement_in_functionBody7072);
					sourceElement283=sourceElement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_sourceElement.Add(sourceElement283.Tree);

					}
					break;

				default:
					goto loop80;
				}
			}

			loop80:
				;

			} finally { DebugExitSubRule(80); }

			DebugLocation(1330, 29);
			RBRACE284=(IToken)Match(input,RBRACE,Follow._RBRACE_in_functionBody7075); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACE.Add(RBRACE284);



			{
			// AST REWRITE
			// elements: sourceElement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1331:2: -> ^( BLOCK[$lb, \"BLOCK\"] ( sourceElement )* )
			{
				DebugLocation(1331, 5);
				// TypeScript.g3:1331:5: ^( BLOCK[$lb, \"BLOCK\"] ( sourceElement )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1331, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BLOCK, lb, "BLOCK"), root_1);

				DebugLocation(1331, 28);
				// TypeScript.g3:1331:28: ( sourceElement )*
				while ( stream_sourceElement.HasNext )
				{
					DebugLocation(1331, 28);
					adaptor.AddChild(root_1, stream_sourceElement.NextTree());

				}
				stream_sourceElement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionBody", 81);
			LeaveRule("functionBody", 81);
			LeaveRule_functionBody();
		}
		DebugLocation(1332, 1);
		} finally { DebugExitRule(GrammarFileName, "functionBody"); }
		return retval;

	}
	// $ANTLR end "functionBody"

	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// TypeScript.g3:1338:8: public program : ( sourceElement )* ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 82);
		TraceIn("program", 82);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> sourceElement285 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(1338, 1);
		try
		{
			// TypeScript.g3:1339:2: ( ( sourceElement )* )
			DebugEnterAlt(1);
			// TypeScript.g3:1339:4: ( sourceElement )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1339, 4);
			// TypeScript.g3:1339:4: ( sourceElement )*
			try { DebugEnterSubRule(81);
			while (true)
			{
				int alt81=2;
				try { DebugEnterDecision(81, false);
				int LA81_1 = input.LA(1);

				if ((LA81_1==ADD||LA81_1==ANY||LA81_1==BREAK||LA81_1==CLASS||(LA81_1>=CONST && LA81_1<=CONSTRUCTOR)||LA81_1==CONTINUE||(LA81_1>=DEC && LA81_1<=DECLARE)||LA81_1==DELETE||LA81_1==DO||LA81_1==DecimalLiteral||LA81_1==ENUM||LA81_1==FALSE||LA81_1==FINAL||LA81_1==FOR||LA81_1==FUNCTION||LA81_1==GET||(LA81_1>=HexIntegerLiteral && LA81_1<=IF)||LA81_1==IMPORT||LA81_1==INC||(LA81_1>=INTERFACE && LA81_1<=INV)||LA81_1==Identifier||(LA81_1>=LBRACE && LA81_1<=LBRACK)||LA81_1==LPAREN||LA81_1==MODULE||(LA81_1>=NEW && LA81_1<=NOT)||(LA81_1>=NULL && LA81_1<=NUMBER)||LA81_1==OctalIntegerLiteral||(LA81_1>=REQUIRE && LA81_1<=RETURN)||LA81_1==RegularExpressionLiteral||(LA81_1>=SEMIC && LA81_1<=SET)||(LA81_1>=STRING && LA81_1<=SUB)||LA81_1==SWITCH||LA81_1==StringLiteral||(LA81_1>=THIS && LA81_1<=THROWS)||(LA81_1>=TRUE && LA81_1<=TRY)||(LA81_1>=TYPE && LA81_1<=TYPEOF)||LA81_1==VAR||LA81_1==VOID||(LA81_1>=WHILE && LA81_1<=WITH)))
				{
					alt81 = 1;
				}


				} finally { DebugExitDecision(81); }
				switch ( alt81 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1339:4: sourceElement
					{
					DebugLocation(1339, 4);
					PushFollow(Follow._sourceElement_in_program7106);
					sourceElement285=sourceElement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, sourceElement285.Tree);

					}
					break;

				default:
					goto loop81;
				}
			}

			loop81:
				;

			} finally { DebugExitSubRule(81); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 82);
			LeaveRule("program", 82);
			LeaveRule_program();
		}
		DebugLocation(1340, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_sourceElement();
	partial void LeaveRule_sourceElement();
	// $ANTLR start "sourceElement"
	// TypeScript.g3:1347:8: public sourceElement options {k=1; } : ({...}? functionDeclaration | moduleDeclaration | ambientDeclaration | statement | interfaceDeclaration | classDeclaration | importDeclaration | enumDeclaration );
	[GrammarRule("sourceElement")]
	public AstParserRuleReturnScope<object, IToken> sourceElement()
	{
		EnterRule_sourceElement();
		EnterRule("sourceElement", 83);
		TraceIn("sourceElement", 83);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> functionDeclaration286 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> moduleDeclaration287 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ambientDeclaration288 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement289 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> interfaceDeclaration290 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classDeclaration291 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> importDeclaration292 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enumDeclaration293 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "sourceElement");
		DebugLocation(1347, 4);
		try
		{
			// TypeScript.g3:1352:5: ({...}? functionDeclaration | moduleDeclaration | ambientDeclaration | statement | interfaceDeclaration | classDeclaration | importDeclaration | enumDeclaration )
			int alt82=8;
			try { DebugEnterDecision(82, false);
			switch (input.LA(1))
			{
			case FUNCTION:
				{
				int LA82_2 = input.LA(2);

				if ((( input.LA(1) == FUNCTION )))
				{
					alt82 = 1;
				}
				else if ((true))
				{
					alt82 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 82, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case MODULE:
				{
				alt82 = 2;
				}
				break;
			case DECLARE:
				{
				alt82 = 3;
				}
				break;
			case ADD:
			case ANY:
			case BREAK:
			case CONSTRUCTOR:
			case CONTINUE:
			case DEC:
			case DELETE:
			case DO:
			case DecimalLiteral:
			case FALSE:
			case FINAL:
			case FOR:
			case GET:
			case HexIntegerLiteral:
			case IF:
			case INC:
			case INV:
			case Identifier:
			case LBRACE:
			case LBRACK:
			case LPAREN:
			case NEW:
			case NOT:
			case NULL:
			case NUMBER:
			case OctalIntegerLiteral:
			case REQUIRE:
			case RETURN:
			case RegularExpressionLiteral:
			case SEMIC:
			case SET:
			case STRING:
			case SUB:
			case SWITCH:
			case StringLiteral:
			case THIS:
			case THROW:
			case THROWS:
			case TRUE:
			case TRY:
			case TYPE:
			case TYPEOF:
			case VAR:
			case VOID:
			case WHILE:
			case WITH:
				{
				alt82 = 4;
				}
				break;
			case INTERFACE:
				{
				alt82 = 5;
				}
				break;
			case CLASS:
				{
				alt82 = 6;
				}
				break;
			case IMPORT:
				{
				alt82 = 7;
				}
				break;
			case CONST:
			case ENUM:
				{
				alt82 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 82, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(82); }
			switch (alt82)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1352:7: {...}? functionDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1352, 7);
				if (!(( input.LA(1) == FUNCTION )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "sourceElement", " input.LA(1) == FUNCTION ");
				}
				DebugLocation(1352, 36);
				PushFollow(Follow._functionDeclaration_in_sourceElement7140);
				functionDeclaration286=functionDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, functionDeclaration286.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1353:7: moduleDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1353, 7);
				PushFollow(Follow._moduleDeclaration_in_sourceElement7148);
				moduleDeclaration287=moduleDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, moduleDeclaration287.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:1354:7: ambientDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1354, 7);
				PushFollow(Follow._ambientDeclaration_in_sourceElement7156);
				ambientDeclaration288=ambientDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ambientDeclaration288.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:1355:7: statement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1355, 7);
				PushFollow(Follow._statement_in_sourceElement7164);
				statement289=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statement289.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:1356:7: interfaceDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1356, 7);
				PushFollow(Follow._interfaceDeclaration_in_sourceElement7172);
				interfaceDeclaration290=interfaceDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interfaceDeclaration290.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScript.g3:1357:7: classDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1357, 7);
				PushFollow(Follow._classDeclaration_in_sourceElement7180);
				classDeclaration291=classDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classDeclaration291.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// TypeScript.g3:1358:7: importDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1358, 7);
				PushFollow(Follow._importDeclaration_in_sourceElement7188);
				importDeclaration292=importDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, importDeclaration292.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// TypeScript.g3:1359:7: enumDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1359, 7);
				PushFollow(Follow._enumDeclaration_in_sourceElement7196);
				enumDeclaration293=enumDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, enumDeclaration293.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sourceElement", 83);
			LeaveRule("sourceElement", 83);
			LeaveRule_sourceElement();
		}
		DebugLocation(1360, 4);
		} finally { DebugExitRule(GrammarFileName, "sourceElement"); }
		return retval;

	}
	// $ANTLR end "sourceElement"

	partial void EnterRule_typeConstraint();
	partial void LeaveRule_typeConstraint();
	// $ANTLR start "typeConstraint"
	// TypeScript.g3:1370:1: typeConstraint : EXTENDS type -> ^( EXTENDS type ) ;
	[GrammarRule("typeConstraint")]
	private AstParserRuleReturnScope<object, IToken> typeConstraint()
	{
		EnterRule_typeConstraint();
		EnterRule("typeConstraint", 84);
		TraceIn("typeConstraint", 84);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EXTENDS294 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type295 = default(AstParserRuleReturnScope<object, IToken>);

		object EXTENDS294_tree = default(object);
		RewriteRuleITokenStream stream_EXTENDS=new RewriteRuleITokenStream(adaptor,"token EXTENDS");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "typeConstraint");
		DebugLocation(1370, 4);
		try
		{
			// TypeScript.g3:1371:5: ( EXTENDS type -> ^( EXTENDS type ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1371:7: EXTENDS type
			{
			DebugLocation(1371, 7);
			EXTENDS294=(IToken)Match(input,EXTENDS,Follow._EXTENDS_in_typeConstraint7221); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EXTENDS.Add(EXTENDS294);

			DebugLocation(1371, 15);
			PushFollow(Follow._type_in_typeConstraint7223);
			type295=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(type295.Tree);


			{
			// AST REWRITE
			// elements: EXTENDS, type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1371:20: -> ^( EXTENDS type )
			{
				DebugLocation(1371, 23);
				// TypeScript.g3:1371:23: ^( EXTENDS type )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1371, 25);
				root_1 = (object)adaptor.BecomeRoot(stream_EXTENDS.NextNode(), root_1);

				DebugLocation(1371, 33);
				adaptor.AddChild(root_1, stream_type.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeConstraint", 84);
			LeaveRule("typeConstraint", 84);
			LeaveRule_typeConstraint();
		}
		DebugLocation(1372, 4);
		} finally { DebugExitRule(GrammarFileName, "typeConstraint"); }
		return retval;

	}
	// $ANTLR end "typeConstraint"

	partial void EnterRule_typeParameters();
	partial void LeaveRule_typeParameters();
	// $ANTLR start "typeParameters"
	// TypeScript.g3:1374:1: typeParameters : LT typeParameter ( COMMA typeParameter )* GT -> ^( TYPE_PARAMS ( typeParameter )* ) ;
	[GrammarRule("typeParameters")]
	private AstParserRuleReturnScope<object, IToken> typeParameters()
	{
		EnterRule_typeParameters();
		EnterRule("typeParameters", 85);
		TraceIn("typeParameters", 85);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LT296 = default(IToken);
		IToken COMMA298 = default(IToken);
		IToken GT300 = default(IToken);
		AstParserRuleReturnScope<object, IToken> typeParameter297 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeParameter299 = default(AstParserRuleReturnScope<object, IToken>);

		object LT296_tree = default(object);
		object COMMA298_tree = default(object);
		object GT300_tree = default(object);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_GT=new RewriteRuleITokenStream(adaptor,"token GT");
		RewriteRuleSubtreeStream stream_typeParameter=new RewriteRuleSubtreeStream(adaptor,"rule typeParameter");
		try { DebugEnterRule(GrammarFileName, "typeParameters");
		DebugLocation(1374, 4);
		try
		{
			// TypeScript.g3:1375:5: ( LT typeParameter ( COMMA typeParameter )* GT -> ^( TYPE_PARAMS ( typeParameter )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1375:7: LT typeParameter ( COMMA typeParameter )* GT
			{
			DebugLocation(1375, 7);
			LT296=(IToken)Match(input,LT,Follow._LT_in_typeParameters7248); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LT.Add(LT296);

			DebugLocation(1375, 10);
			PushFollow(Follow._typeParameter_in_typeParameters7250);
			typeParameter297=typeParameter();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeParameter.Add(typeParameter297.Tree);
			DebugLocation(1375, 24);
			// TypeScript.g3:1375:24: ( COMMA typeParameter )*
			try { DebugEnterSubRule(83);
			while (true)
			{
				int alt83=2;
				try { DebugEnterDecision(83, false);
				int LA83_1 = input.LA(1);

				if ((LA83_1==COMMA))
				{
					alt83 = 1;
				}


				} finally { DebugExitDecision(83); }
				switch ( alt83 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1375:25: COMMA typeParameter
					{
					DebugLocation(1375, 25);
					COMMA298=(IToken)Match(input,COMMA,Follow._COMMA_in_typeParameters7253); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA298);

					DebugLocation(1375, 31);
					PushFollow(Follow._typeParameter_in_typeParameters7255);
					typeParameter299=typeParameter();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_typeParameter.Add(typeParameter299.Tree);

					}
					break;

				default:
					goto loop83;
				}
			}

			loop83:
				;

			} finally { DebugExitSubRule(83); }

			DebugLocation(1375, 47);
			GT300=(IToken)Match(input,GT,Follow._GT_in_typeParameters7259); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_GT.Add(GT300);



			{
			// AST REWRITE
			// elements: typeParameter
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1375:49: -> ^( TYPE_PARAMS ( typeParameter )* )
			{
				DebugLocation(1375, 52);
				// TypeScript.g3:1375:52: ^( TYPE_PARAMS ( typeParameter )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1375, 54);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE_PARAMS, "TYPE_PARAMS"), root_1);

				DebugLocation(1375, 66);
				// TypeScript.g3:1375:66: ( typeParameter )*
				while ( stream_typeParameter.HasNext )
				{
					DebugLocation(1375, 66);
					adaptor.AddChild(root_1, stream_typeParameter.NextTree());

				}
				stream_typeParameter.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeParameters", 85);
			LeaveRule("typeParameters", 85);
			LeaveRule_typeParameters();
		}
		DebugLocation(1376, 4);
		} finally { DebugExitRule(GrammarFileName, "typeParameters"); }
		return retval;

	}
	// $ANTLR end "typeParameters"

	partial void EnterRule_typeParameter();
	partial void LeaveRule_typeParameter();
	// $ANTLR start "typeParameter"
	// TypeScript.g3:1378:1: typeParameter : identifier ( typeConstraint )? -> ^( identifier ( typeConstraint )? ) ;
	[GrammarRule("typeParameter")]
	private AstParserRuleReturnScope<object, IToken> typeParameter()
	{
		EnterRule_typeParameter();
		EnterRule("typeParameter", 86);
		TraceIn("typeParameter", 86);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> identifier301 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeConstraint302 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_typeConstraint=new RewriteRuleSubtreeStream(adaptor,"rule typeConstraint");
		try { DebugEnterRule(GrammarFileName, "typeParameter");
		DebugLocation(1378, 4);
		try
		{
			// TypeScript.g3:1379:5: ( identifier ( typeConstraint )? -> ^( identifier ( typeConstraint )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1379:7: identifier ( typeConstraint )?
			{
			DebugLocation(1379, 7);
			PushFollow(Follow._identifier_in_typeParameter7284);
			identifier301=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier301.Tree);
			DebugLocation(1379, 18);
			// TypeScript.g3:1379:18: ( typeConstraint )?
			int alt84=2;
			try { DebugEnterSubRule(84);
			try { DebugEnterDecision(84, false);
			int LA84_1 = input.LA(1);

			if ((LA84_1==EXTENDS))
			{
				alt84 = 1;
			}
			} finally { DebugExitDecision(84); }
			switch (alt84)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1379:18: typeConstraint
				{
				DebugLocation(1379, 18);
				PushFollow(Follow._typeConstraint_in_typeParameter7286);
				typeConstraint302=typeConstraint();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeConstraint.Add(typeConstraint302.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(84); }



			{
			// AST REWRITE
			// elements: identifier, typeConstraint
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1379:34: -> ^( identifier ( typeConstraint )? )
			{
				DebugLocation(1379, 37);
				// TypeScript.g3:1379:37: ^( identifier ( typeConstraint )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1379, 39);
				root_1 = (object)adaptor.BecomeRoot(stream_identifier.NextNode(), root_1);

				DebugLocation(1379, 50);
				// TypeScript.g3:1379:50: ( typeConstraint )?
				if (stream_typeConstraint.HasNext)
				{
					DebugLocation(1379, 50);
					adaptor.AddChild(root_1, stream_typeConstraint.NextTree());

				}
				stream_typeConstraint.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeParameter", 86);
			LeaveRule("typeParameter", 86);
			LeaveRule_typeParameter();
		}
		DebugLocation(1380, 4);
		} finally { DebugExitRule(GrammarFileName, "typeParameter"); }
		return retval;

	}
	// $ANTLR end "typeParameter"

	partial void EnterRule_typeArguments();
	partial void LeaveRule_typeArguments();
	// $ANTLR start "typeArguments"
	// TypeScript.g3:1386:1: typeArguments : LT type ( COMMA type )* GT -> ^( TYPE_ARGS ( type )* ) ;
	[GrammarRule("typeArguments")]
	private AstParserRuleReturnScope<object, IToken> typeArguments()
	{
		EnterRule_typeArguments();
		EnterRule("typeArguments", 87);
		TraceIn("typeArguments", 87);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LT303 = default(IToken);
		IToken COMMA305 = default(IToken);
		IToken GT307 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type304 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type306 = default(AstParserRuleReturnScope<object, IToken>);

		object LT303_tree = default(object);
		object COMMA305_tree = default(object);
		object GT307_tree = default(object);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_GT=new RewriteRuleITokenStream(adaptor,"token GT");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "typeArguments");
		DebugLocation(1386, 4);
		try
		{
			// TypeScript.g3:1387:5: ( LT type ( COMMA type )* GT -> ^( TYPE_ARGS ( type )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1387:7: LT type ( COMMA type )* GT
			{
			DebugLocation(1387, 7);
			LT303=(IToken)Match(input,LT,Follow._LT_in_typeArguments7321); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LT.Add(LT303);

			DebugLocation(1387, 10);
			PushFollow(Follow._type_in_typeArguments7323);
			type304=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(type304.Tree);
			DebugLocation(1387, 15);
			// TypeScript.g3:1387:15: ( COMMA type )*
			try { DebugEnterSubRule(85);
			while (true)
			{
				int alt85=2;
				try { DebugEnterDecision(85, false);
				int LA85_1 = input.LA(1);

				if ((LA85_1==COMMA))
				{
					alt85 = 1;
				}


				} finally { DebugExitDecision(85); }
				switch ( alt85 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1387:16: COMMA type
					{
					DebugLocation(1387, 16);
					COMMA305=(IToken)Match(input,COMMA,Follow._COMMA_in_typeArguments7326); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA305);

					DebugLocation(1387, 22);
					PushFollow(Follow._type_in_typeArguments7328);
					type306=type();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_type.Add(type306.Tree);

					}
					break;

				default:
					goto loop85;
				}
			}

			loop85:
				;

			} finally { DebugExitSubRule(85); }

			DebugLocation(1387, 29);
			GT307=(IToken)Match(input,GT,Follow._GT_in_typeArguments7332); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_GT.Add(GT307);



			{
			// AST REWRITE
			// elements: type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1387:31: -> ^( TYPE_ARGS ( type )* )
			{
				DebugLocation(1387, 34);
				// TypeScript.g3:1387:34: ^( TYPE_ARGS ( type )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1387, 36);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE_ARGS, "TYPE_ARGS"), root_1);

				DebugLocation(1387, 46);
				// TypeScript.g3:1387:46: ( type )*
				while ( stream_type.HasNext )
				{
					DebugLocation(1387, 46);
					adaptor.AddChild(root_1, stream_type.NextTree());

				}
				stream_type.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeArguments", 87);
			LeaveRule("typeArguments", 87);
			LeaveRule_typeArguments();
		}
		DebugLocation(1388, 4);
		} finally { DebugExitRule(GrammarFileName, "typeArguments"); }
		return retval;

	}
	// $ANTLR end "typeArguments"

	partial void EnterRule_type();
	partial void LeaveRule_type();
	// $ANTLR start "type"
	// TypeScript.g3:1395:8: public type options {k=4; } : ( primaryType | functionType | constructorType );
	[GrammarRule("type")]
	public AstParserRuleReturnScope<object, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 88);
		TraceIn("type", 88);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> primaryType308 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionType309 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> constructorType310 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(1395, 4);
		try
		{
			// TypeScript.g3:1400:5: ( primaryType | functionType | constructorType )
			int alt86=3;
			try { DebugEnterDecision(86, false);
			switch (input.LA(1))
			{
			case ANY:
			case BOOLEAN:
			case CONSTRUCTOR:
			case DECLARE:
			case FINAL:
			case GET:
			case Identifier:
			case LBRACE:
			case LBRACK:
			case MODULE:
			case NUMBER:
			case REQUIRE:
			case SET:
			case STRING:
			case THROWS:
			case TYPE:
			case TYPEOF:
			case VOID:
				{
				alt86 = 1;
				}
				break;
			case LPAREN:
			case LT:
				{
				alt86 = 2;
				}
				break;
			case NEW:
				{
				alt86 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 86, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(86); }
			switch (alt86)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1400:7: primaryType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1400, 7);
				PushFollow(Follow._primaryType_in_type7377);
				primaryType308=primaryType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, primaryType308.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1402:7: functionType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1402, 7);
				PushFollow(Follow._functionType_in_type7390);
				functionType309=functionType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, functionType309.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:1403:7: constructorType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1403, 7);
				PushFollow(Follow._constructorType_in_type7398);
				constructorType310=constructorType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constructorType310.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 88);
			LeaveRule("type", 88);
			LeaveRule_type();
		}
		DebugLocation(1404, 4);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_nonTupleType();
	partial void LeaveRule_nonTupleType();
	// $ANTLR start "nonTupleType"
	// TypeScript.g3:1406:1: nonTupleType options {k=4; backtrack=true; } : ( predefinedType | typeReference | objectType | typeQuery | functionType | constructorType );
	[GrammarRule("nonTupleType")]
	private AstParserRuleReturnScope<object, IToken> nonTupleType()
	{
		EnterRule_nonTupleType();
		EnterRule("nonTupleType", 89);
		TraceIn("nonTupleType", 89);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> predefinedType311 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeReference312 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> objectType313 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeQuery314 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionType315 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> constructorType316 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "nonTupleType");
		DebugLocation(1406, 1);
		try
		{
			// TypeScript.g3:1412:5: ( predefinedType | typeReference | objectType | typeQuery | functionType | constructorType )
			int alt87=6;
			try { DebugEnterDecision(87, false);
			switch (input.LA(1))
			{
			case ANY:
			case NUMBER:
			case STRING:
				{
				int LA87_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_TypeScript_fragment)))
				{
					alt87 = 1;
				}
				else if ((EvaluatePredicate(synpred2_TypeScript_fragment)))
				{
					alt87 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 87, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case BOOLEAN:
			case VOID:
				{
				alt87 = 1;
				}
				break;
			case CONSTRUCTOR:
			case DECLARE:
			case FINAL:
			case GET:
			case Identifier:
			case MODULE:
			case REQUIRE:
			case SET:
			case THROWS:
			case TYPE:
				{
				alt87 = 2;
				}
				break;
			case LBRACE:
				{
				alt87 = 3;
				}
				break;
			case TYPEOF:
				{
				alt87 = 4;
				}
				break;
			case LPAREN:
			case LT:
				{
				alt87 = 5;
				}
				break;
			case NEW:
				{
				alt87 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 87, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(87); }
			switch (alt87)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1412:7: predefinedType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1412, 7);
				PushFollow(Follow._predefinedType_in_nonTupleType7440);
				predefinedType311=predefinedType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, predefinedType311.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1413:7: typeReference
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1413, 7);
				PushFollow(Follow._typeReference_in_nonTupleType7448);
				typeReference312=typeReference();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, typeReference312.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:1414:7: objectType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1414, 7);
				PushFollow(Follow._objectType_in_nonTupleType7456);
				objectType313=objectType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, objectType313.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:1415:7: typeQuery
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1415, 7);
				PushFollow(Follow._typeQuery_in_nonTupleType7464);
				typeQuery314=typeQuery();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, typeQuery314.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:1416:7: functionType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1416, 7);
				PushFollow(Follow._functionType_in_nonTupleType7472);
				functionType315=functionType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, functionType315.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScript.g3:1417:7: constructorType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1417, 7);
				PushFollow(Follow._constructorType_in_nonTupleType7480);
				constructorType316=constructorType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constructorType316.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonTupleType", 89);
			LeaveRule("nonTupleType", 89);
			LeaveRule_nonTupleType();
		}
		DebugLocation(1419, 1);
		} finally { DebugExitRule(GrammarFileName, "nonTupleType"); }
		return retval;

	}
	// $ANTLR end "nonTupleType"

	partial void EnterRule_primaryType();
	partial void LeaveRule_primaryType();
	// $ANTLR start "primaryType"
	// TypeScript.g3:1423:1: primaryType options {k=4; backtrack=true; } : ( predefinedType | typeReference | objectType | tupleType | typeQuery ) ( arrayIndicator )* ;
	[GrammarRule("primaryType")]
	private AstParserRuleReturnScope<object, IToken> primaryType()
	{
		EnterRule_primaryType();
		EnterRule("primaryType", 90);
		TraceIn("primaryType", 90);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> predefinedType317 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeReference318 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> objectType319 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> tupleType320 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeQuery321 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arrayIndicator322 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "primaryType");
		DebugLocation(1423, 4);
		try
		{
			// TypeScript.g3:1429:5: ( ( predefinedType | typeReference | objectType | tupleType | typeQuery ) ( arrayIndicator )* )
			DebugEnterAlt(1);
			// TypeScript.g3:1429:7: ( predefinedType | typeReference | objectType | tupleType | typeQuery ) ( arrayIndicator )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1429, 7);
			// TypeScript.g3:1429:7: ( predefinedType | typeReference | objectType | tupleType | typeQuery )
			int alt88=5;
			try { DebugEnterSubRule(88);
			try { DebugEnterDecision(88, false);
			switch (input.LA(1))
			{
			case ANY:
			case BOOLEAN:
			case NUMBER:
			case STRING:
			case VOID:
				{
				alt88 = 1;
				}
				break;
			case CONSTRUCTOR:
			case DECLARE:
			case FINAL:
			case GET:
			case Identifier:
			case MODULE:
			case REQUIRE:
			case SET:
			case THROWS:
			case TYPE:
				{
				alt88 = 2;
				}
				break;
			case LBRACE:
				{
				alt88 = 3;
				}
				break;
			case LBRACK:
				{
				alt88 = 4;
				}
				break;
			case TYPEOF:
				{
				alt88 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 88, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(88); }
			switch (alt88)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1429:8: predefinedType
				{
				DebugLocation(1429, 8);
				PushFollow(Follow._predefinedType_in_primaryType7523);
				predefinedType317=predefinedType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, predefinedType317.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1430:7: typeReference
				{
				DebugLocation(1430, 7);
				PushFollow(Follow._typeReference_in_primaryType7531);
				typeReference318=typeReference();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, typeReference318.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:1431:7: objectType
				{
				DebugLocation(1431, 7);
				PushFollow(Follow._objectType_in_primaryType7539);
				objectType319=objectType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, objectType319.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:1432:7: tupleType
				{
				DebugLocation(1432, 7);
				PushFollow(Follow._tupleType_in_primaryType7547);
				tupleType320=tupleType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, tupleType320.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:1433:7: typeQuery
				{
				DebugLocation(1433, 7);
				PushFollow(Follow._typeQuery_in_primaryType7555);
				typeQuery321=typeQuery();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, typeQuery321.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(88); }

			DebugLocation(1434, 5);
			// TypeScript.g3:1434:5: ( arrayIndicator )*
			try { DebugEnterSubRule(89);
			while (true)
			{
				int alt89=2;
				try { DebugEnterDecision(89, false);
				int LA89_1 = input.LA(1);

				if ((LA89_1==LBRACK))
				{
					alt89 = 1;
				}


				} finally { DebugExitDecision(89); }
				switch ( alt89 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1434:5: arrayIndicator
					{
					DebugLocation(1434, 5);
					PushFollow(Follow._arrayIndicator_in_primaryType7562);
					arrayIndicator322=arrayIndicator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, arrayIndicator322.Tree);

					}
					break;

				default:
					goto loop89;
				}
			}

			loop89:
				;

			} finally { DebugExitSubRule(89); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryType", 90);
			LeaveRule("primaryType", 90);
			LeaveRule_primaryType();
		}
		DebugLocation(1435, 4);
		} finally { DebugExitRule(GrammarFileName, "primaryType"); }
		return retval;

	}
	// $ANTLR end "primaryType"

	partial void EnterRule_arrayIndicator();
	partial void LeaveRule_arrayIndicator();
	// $ANTLR start "arrayIndicator"
	// TypeScript.g3:1437:1: arrayIndicator : ( LBRACK RBRACK ) -> ARRAY_TYPE ;
	[GrammarRule("arrayIndicator")]
	private AstParserRuleReturnScope<object, IToken> arrayIndicator()
	{
		EnterRule_arrayIndicator();
		EnterRule("arrayIndicator", 91);
		TraceIn("arrayIndicator", 91);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LBRACK323 = default(IToken);
		IToken RBRACK324 = default(IToken);

		object LBRACK323_tree = default(object);
		object RBRACK324_tree = default(object);
		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
		try { DebugEnterRule(GrammarFileName, "arrayIndicator");
		DebugLocation(1437, 4);
		try
		{
			// TypeScript.g3:1438:5: ( ( LBRACK RBRACK ) -> ARRAY_TYPE )
			DebugEnterAlt(1);
			// TypeScript.g3:1438:7: ( LBRACK RBRACK )
			{
			DebugLocation(1438, 7);
			// TypeScript.g3:1438:7: ( LBRACK RBRACK )
			DebugEnterAlt(1);
			// TypeScript.g3:1438:8: LBRACK RBRACK
			{
			DebugLocation(1438, 8);
			LBRACK323=(IToken)Match(input,LBRACK,Follow._LBRACK_in_arrayIndicator7581); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACK.Add(LBRACK323);

			DebugLocation(1438, 15);
			RBRACK324=(IToken)Match(input,RBRACK,Follow._RBRACK_in_arrayIndicator7583); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACK.Add(RBRACK324);


			}



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1438:23: -> ARRAY_TYPE
			{
				DebugLocation(1438, 26);
				adaptor.AddChild(root_0, (object)adaptor.Create(ARRAY_TYPE, "ARRAY_TYPE"));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayIndicator", 91);
			LeaveRule("arrayIndicator", 91);
			LeaveRule_arrayIndicator();
		}
		DebugLocation(1439, 4);
		} finally { DebugExitRule(GrammarFileName, "arrayIndicator"); }
		return retval;

	}
	// $ANTLR end "arrayIndicator"

	partial void EnterRule_predefinedType();
	partial void LeaveRule_predefinedType();
	// $ANTLR start "predefinedType"
	// TypeScript.g3:1443:1: predefinedType : ( ANY | NUMBER | BOOLEAN | STRING | VOID );
	[GrammarRule("predefinedType")]
	private AstParserRuleReturnScope<object, IToken> predefinedType()
	{
		EnterRule_predefinedType();
		EnterRule("predefinedType", 92);
		TraceIn("predefinedType", 92);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set325 = default(IToken);

		object set325_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "predefinedType");
		DebugLocation(1443, 4);
		try
		{
			// TypeScript.g3:1444:5: ( ANY | NUMBER | BOOLEAN | STRING | VOID )
			DebugEnterAlt(1);
			// TypeScript.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1444, 5);

			set325=(IToken)input.LT(1);
			if (input.LA(1)==ANY||input.LA(1)==BOOLEAN||input.LA(1)==NUMBER||input.LA(1)==STRING||input.LA(1)==VOID)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set325));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("predefinedType", 92);
			LeaveRule("predefinedType", 92);
			LeaveRule_predefinedType();
		}
		DebugLocation(1449, 4);
		} finally { DebugExitRule(GrammarFileName, "predefinedType"); }
		return retval;

	}
	// $ANTLR end "predefinedType"

	partial void EnterRule_typeReference();
	partial void LeaveRule_typeReference();
	// $ANTLR start "typeReference"
	// TypeScript.g3:1455:1: typeReference : typeName ( typeArguments )? -> ^( TYPEREF typeName ( typeArguments )? ) ;
	[GrammarRule("typeReference")]
	private AstParserRuleReturnScope<object, IToken> typeReference()
	{
		EnterRule_typeReference();
		EnterRule("typeReference", 93);
		TraceIn("typeReference", 93);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> typeName326 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeArguments327 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_typeName=new RewriteRuleSubtreeStream(adaptor,"rule typeName");
		RewriteRuleSubtreeStream stream_typeArguments=new RewriteRuleSubtreeStream(adaptor,"rule typeArguments");
		try { DebugEnterRule(GrammarFileName, "typeReference");
		DebugLocation(1455, 4);
		try
		{
			// TypeScript.g3:1456:5: ( typeName ( typeArguments )? -> ^( TYPEREF typeName ( typeArguments )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1456:7: typeName ( typeArguments )?
			{
			DebugLocation(1456, 7);
			PushFollow(Follow._typeName_in_typeReference7664);
			typeName326=typeName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeName.Add(typeName326.Tree);
			DebugLocation(1456, 16);
			if (state.backtracking == 0)
			{
				 PromoteEOL(null); 
			}
			DebugLocation(1456, 38);
			// TypeScript.g3:1456:38: ( typeArguments )?
			int alt90=2;
			try { DebugEnterSubRule(90);
			try { DebugEnterDecision(90, false);
			int LA90_1 = input.LA(1);

			if ((LA90_1==LT))
			{
				alt90 = 1;
			}
			} finally { DebugExitDecision(90); }
			switch (alt90)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1456:38: typeArguments
				{
				DebugLocation(1456, 38);
				PushFollow(Follow._typeArguments_in_typeReference7668);
				typeArguments327=typeArguments();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeArguments.Add(typeArguments327.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(90); }



			{
			// AST REWRITE
			// elements: typeName, typeArguments
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1456:53: -> ^( TYPEREF typeName ( typeArguments )? )
			{
				DebugLocation(1456, 56);
				// TypeScript.g3:1456:56: ^( TYPEREF typeName ( typeArguments )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1456, 58);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPEREF, "TYPEREF"), root_1);

				DebugLocation(1456, 66);
				adaptor.AddChild(root_1, stream_typeName.NextTree());
				DebugLocation(1456, 75);
				// TypeScript.g3:1456:75: ( typeArguments )?
				if (stream_typeArguments.HasNext)
				{
					DebugLocation(1456, 75);
					adaptor.AddChild(root_1, stream_typeArguments.NextTree());

				}
				stream_typeArguments.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeReference", 93);
			LeaveRule("typeReference", 93);
			LeaveRule_typeReference();
		}
		DebugLocation(1457, 4);
		} finally { DebugExitRule(GrammarFileName, "typeReference"); }
		return retval;

	}
	// $ANTLR end "typeReference"

	partial void EnterRule_typeName();
	partial void LeaveRule_typeName();
	// $ANTLR start "typeName"
	// TypeScript.g3:1459:1: typeName : ( identifier | qName );
	[GrammarRule("typeName")]
	private AstParserRuleReturnScope<object, IToken> typeName()
	{
		EnterRule_typeName();
		EnterRule("typeName", 94);
		TraceIn("typeName", 94);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> identifier328 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> qName329 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "typeName");
		DebugLocation(1459, 4);
		try
		{
			// TypeScript.g3:1460:5: ( identifier | qName )
			int alt91=2;
			try { DebugEnterDecision(91, false);
			int LA91_1 = input.LA(1);

			if ((LA91_1==ANY||LA91_1==CONSTRUCTOR||LA91_1==DECLARE||LA91_1==FINAL||LA91_1==GET||LA91_1==MODULE||LA91_1==NUMBER||LA91_1==REQUIRE||LA91_1==SET||LA91_1==STRING||LA91_1==THROWS||LA91_1==TYPE))
			{
				int LA91_2 = input.LA(2);

				if ((LA91_2==EOF||LA91_2==ASSIGN||LA91_2==COMMA||LA91_2==EOL||LA91_2==GT||LA91_2==IMPLEMENTS||LA91_2==IN||(LA91_2>=LBRACE && LA91_2<=LBRACK)||LA91_2==LT||LA91_2==MultiLineComment||LA91_2==OR||(LA91_2>=RBRACE && LA91_2<=RBRACK)||LA91_2==RPAREN||LA91_2==SEMIC))
				{
					alt91 = 1;
				}
				else if ((LA91_2==DOT))
				{
					alt91 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 91, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA91_1==Identifier))
			{
				int LA91_2 = input.LA(2);

				if ((LA91_2==EOF||LA91_2==ASSIGN||LA91_2==COMMA||LA91_2==EOL||LA91_2==GT||LA91_2==IMPLEMENTS||LA91_2==IN||(LA91_2>=LBRACE && LA91_2<=LBRACK)||LA91_2==LT||LA91_2==MultiLineComment||LA91_2==OR||(LA91_2>=RBRACE && LA91_2<=RBRACK)||LA91_2==RPAREN||LA91_2==SEMIC))
				{
					alt91 = 1;
				}
				else if ((LA91_2==DOT))
				{
					alt91 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 91, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 91, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(91); }
			switch (alt91)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1460:7: identifier
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1460, 7);
				PushFollow(Follow._identifier_in_typeName7697);
				identifier328=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifier328.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1461:7: qName
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1461, 7);
				PushFollow(Follow._qName_in_typeName7705);
				qName329=qName();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, qName329.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeName", 94);
			LeaveRule("typeName", 94);
			LeaveRule_typeName();
		}
		DebugLocation(1462, 4);
		} finally { DebugExitRule(GrammarFileName, "typeName"); }
		return retval;

	}
	// $ANTLR end "typeName"

	partial void EnterRule_qName();
	partial void LeaveRule_qName();
	// $ANTLR start "qName"
	// TypeScript.g3:1464:1: qName : x= identifier ( DOT y= identifier )+ -> Identifier[null, result] ;
	[GrammarRule("qName")]
	private AstParserRuleReturnScope<object, IToken> qName()
	{
		EnterRule_qName();
		EnterRule("qName", 95);
		TraceIn("qName", 95);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DOT330 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> y = default(AstParserRuleReturnScope<object, IToken>);

		object DOT330_tree = default(object);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		 string result = ""; 
		try { DebugEnterRule(GrammarFileName, "qName");
		DebugLocation(1464, 1);
		try
		{
			// TypeScript.g3:1466:2: (x= identifier ( DOT y= identifier )+ -> Identifier[null, result] )
			DebugEnterAlt(1);
			// TypeScript.g3:1466:4: x= identifier ( DOT y= identifier )+
			{
			DebugLocation(1466, 5);
			PushFollow(Follow._identifier_in_qName7727);
			x=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(x.Tree);
			DebugLocation(1466, 17);
			if (state.backtracking == 0)
			{
				 result = (x!=null?input.ToString(x.Start,x.Stop):null); 
			}
			DebugLocation(1466, 39);
			// TypeScript.g3:1466:39: ( DOT y= identifier )+
			int cnt92=0;
			try { DebugEnterSubRule(92);
			while (true)
			{
				int alt92=2;
				try { DebugEnterDecision(92, false);
				int LA92_1 = input.LA(1);

				if ((LA92_1==DOT))
				{
					alt92 = 1;
				}


				} finally { DebugExitDecision(92); }
				switch (alt92)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1466:41: DOT y= identifier
					{
					DebugLocation(1466, 41);
					DOT330=(IToken)Match(input,DOT,Follow._DOT_in_qName7733); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_DOT.Add(DOT330);

					DebugLocation(1466, 45);
					if (state.backtracking == 0)
					{
						 result += '.'; 
					}
					DebugLocation(1466, 65);
					PushFollow(Follow._identifier_in_qName7739);
					y=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_identifier.Add(y.Tree);
					DebugLocation(1466, 77);
					if (state.backtracking == 0)
					{
						 result += (y!=null?input.ToString(y.Start,y.Stop):null); 
					}

					}
					break;

				default:
					if (cnt92 >= 1)
						goto loop92;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee92 = new EarlyExitException( 92, input );
					DebugRecognitionException(eee92);
					throw eee92;
				}
				cnt92++;
			}
			loop92:
				;

			} finally { DebugExitSubRule(92); }



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1466:103: -> Identifier[null, result]
			{
				DebugLocation(1466, 106);
				adaptor.AddChild(root_0, (object)adaptor.Create(Identifier, null, result));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("qName", 95);
			LeaveRule("qName", 95);
			LeaveRule_qName();
		}
		DebugLocation(1467, 1);
		} finally { DebugExitRule(GrammarFileName, "qName"); }
		return retval;

	}
	// $ANTLR end "qName"

	partial void EnterRule_objectType();
	partial void LeaveRule_objectType();
	// $ANTLR start "objectType"
	// TypeScript.g3:1471:1: objectType : LBRACE ( typeMember semic )* RBRACE -> ^( OBJECT_TYPE ( typeMember )* ) ;
	[GrammarRule("objectType")]
	private AstParserRuleReturnScope<object, IToken> objectType()
	{
		EnterRule_objectType();
		EnterRule("objectType", 96);
		TraceIn("objectType", 96);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LBRACE331 = default(IToken);
		IToken RBRACE334 = default(IToken);
		AstParserRuleReturnScope<object, IToken> typeMember332 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic333 = default(AstParserRuleReturnScope<object, IToken>);

		object LBRACE331_tree = default(object);
		object RBRACE334_tree = default(object);
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_typeMember=new RewriteRuleSubtreeStream(adaptor,"rule typeMember");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		try { DebugEnterRule(GrammarFileName, "objectType");
		DebugLocation(1471, 4);
		try
		{
			// TypeScript.g3:1472:5: ( LBRACE ( typeMember semic )* RBRACE -> ^( OBJECT_TYPE ( typeMember )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1472:7: LBRACE ( typeMember semic )* RBRACE
			{
			DebugLocation(1472, 7);
			LBRACE331=(IToken)Match(input,LBRACE,Follow._LBRACE_in_objectType7765); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACE.Add(LBRACE331);

			DebugLocation(1472, 14);
			// TypeScript.g3:1472:14: ( typeMember semic )*
			try { DebugEnterSubRule(93);
			while (true)
			{
				int alt93=2;
				try { DebugEnterDecision(93, false);
				int LA93_1 = input.LA(1);

				if ((LA93_1==ANY||LA93_1==CONSTRUCTOR||LA93_1==DECLARE||LA93_1==DecimalLiteral||LA93_1==FINAL||LA93_1==GET||LA93_1==HexIntegerLiteral||LA93_1==Identifier||LA93_1==LBRACK||LA93_1==LPAREN||LA93_1==LT||LA93_1==MODULE||LA93_1==NEW||LA93_1==NUMBER||LA93_1==OctalIntegerLiteral||LA93_1==REQUIRE||LA93_1==SET||LA93_1==STRING||LA93_1==StringLiteral||LA93_1==THROWS||LA93_1==TYPE))
				{
					alt93 = 1;
				}


				} finally { DebugExitDecision(93); }
				switch ( alt93 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1472:15: typeMember semic
					{
					DebugLocation(1472, 15);
					PushFollow(Follow._typeMember_in_objectType7768);
					typeMember332=typeMember();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_typeMember.Add(typeMember332.Tree);
					DebugLocation(1472, 26);
					PushFollow(Follow._semic_in_objectType7770);
					semic333=semic();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_semic.Add(semic333.Tree);

					}
					break;

				default:
					goto loop93;
				}
			}

			loop93:
				;

			} finally { DebugExitSubRule(93); }

			DebugLocation(1472, 34);
			RBRACE334=(IToken)Match(input,RBRACE,Follow._RBRACE_in_objectType7774); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACE.Add(RBRACE334);



			{
			// AST REWRITE
			// elements: typeMember
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1472:41: -> ^( OBJECT_TYPE ( typeMember )* )
			{
				DebugLocation(1472, 44);
				// TypeScript.g3:1472:44: ^( OBJECT_TYPE ( typeMember )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1472, 46);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(OBJECT_TYPE, "OBJECT_TYPE"), root_1);

				DebugLocation(1472, 58);
				// TypeScript.g3:1472:58: ( typeMember )*
				while ( stream_typeMember.HasNext )
				{
					DebugLocation(1472, 58);
					adaptor.AddChild(root_1, stream_typeMember.NextTree());

				}
				stream_typeMember.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("objectType", 96);
			LeaveRule("objectType", 96);
			LeaveRule_objectType();
		}
		DebugLocation(1473, 4);
		} finally { DebugExitRule(GrammarFileName, "objectType"); }
		return retval;

	}
	// $ANTLR end "objectType"

	partial void EnterRule_typeMember();
	partial void LeaveRule_typeMember();
	// $ANTLR start "typeMember"
	// TypeScript.g3:1475:1: typeMember : ( propertySignature | callSignature | constructSignature | indexSignature | methodSignature );
	[GrammarRule("typeMember")]
	private AstParserRuleReturnScope<object, IToken> typeMember()
	{
		EnterRule_typeMember();
		EnterRule("typeMember", 97);
		TraceIn("typeMember", 97);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> propertySignature335 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> callSignature336 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> constructSignature337 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> indexSignature338 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> methodSignature339 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "typeMember");
		DebugLocation(1475, 4);
		try
		{
			// TypeScript.g3:1476:5: ( propertySignature | callSignature | constructSignature | indexSignature | methodSignature )
			int alt94=5;
			try { DebugEnterDecision(94, false);
			try
			{
				alt94 = dfa94.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(94); }
			switch (alt94)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1476:7: propertySignature
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1476, 7);
				PushFollow(Follow._propertySignature_in_typeMember7800);
				propertySignature335=propertySignature();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, propertySignature335.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1477:7: callSignature
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1477, 7);
				PushFollow(Follow._callSignature_in_typeMember7808);
				callSignature336=callSignature();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, callSignature336.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:1478:7: constructSignature
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1478, 7);
				PushFollow(Follow._constructSignature_in_typeMember7816);
				constructSignature337=constructSignature();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constructSignature337.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:1479:7: indexSignature
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1479, 7);
				PushFollow(Follow._indexSignature_in_typeMember7824);
				indexSignature338=indexSignature();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, indexSignature338.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:1480:7: methodSignature
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1480, 7);
				PushFollow(Follow._methodSignature_in_typeMember7832);
				methodSignature339=methodSignature();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, methodSignature339.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeMember", 97);
			LeaveRule("typeMember", 97);
			LeaveRule_typeMember();
		}
		DebugLocation(1481, 4);
		} finally { DebugExitRule(GrammarFileName, "typeMember"); }
		return retval;

	}
	// $ANTLR end "typeMember"

	partial void EnterRule_tupleType();
	partial void LeaveRule_tupleType();
	// $ANTLR start "tupleType"
	// TypeScript.g3:1487:1: tupleType : LBRACK nonTupleType ( COMMA type )* RBRACK -> ^( TUPLE_TYPE nonTupleType ( type )* ) ;
	[GrammarRule("tupleType")]
	private AstParserRuleReturnScope<object, IToken> tupleType()
	{
		EnterRule_tupleType();
		EnterRule("tupleType", 98);
		TraceIn("tupleType", 98);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LBRACK340 = default(IToken);
		IToken COMMA342 = default(IToken);
		IToken RBRACK344 = default(IToken);
		AstParserRuleReturnScope<object, IToken> nonTupleType341 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type343 = default(AstParserRuleReturnScope<object, IToken>);

		object LBRACK340_tree = default(object);
		object COMMA342_tree = default(object);
		object RBRACK344_tree = default(object);
		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
		RewriteRuleSubtreeStream stream_nonTupleType=new RewriteRuleSubtreeStream(adaptor,"rule nonTupleType");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "tupleType");
		DebugLocation(1487, 4);
		try
		{
			// TypeScript.g3:1488:5: ( LBRACK nonTupleType ( COMMA type )* RBRACK -> ^( TUPLE_TYPE nonTupleType ( type )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1488:7: LBRACK nonTupleType ( COMMA type )* RBRACK
			{
			DebugLocation(1488, 7);
			LBRACK340=(IToken)Match(input,LBRACK,Follow._LBRACK_in_tupleType7853); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACK.Add(LBRACK340);

			DebugLocation(1488, 14);
			PushFollow(Follow._nonTupleType_in_tupleType7855);
			nonTupleType341=nonTupleType();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_nonTupleType.Add(nonTupleType341.Tree);
			DebugLocation(1488, 27);
			// TypeScript.g3:1488:27: ( COMMA type )*
			try { DebugEnterSubRule(95);
			while (true)
			{
				int alt95=2;
				try { DebugEnterDecision(95, false);
				int LA95_1 = input.LA(1);

				if ((LA95_1==COMMA))
				{
					alt95 = 1;
				}


				} finally { DebugExitDecision(95); }
				switch ( alt95 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1488:28: COMMA type
					{
					DebugLocation(1488, 28);
					COMMA342=(IToken)Match(input,COMMA,Follow._COMMA_in_tupleType7858); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA342);

					DebugLocation(1488, 34);
					PushFollow(Follow._type_in_tupleType7860);
					type343=type();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_type.Add(type343.Tree);

					}
					break;

				default:
					goto loop95;
				}
			}

			loop95:
				;

			} finally { DebugExitSubRule(95); }

			DebugLocation(1488, 41);
			RBRACK344=(IToken)Match(input,RBRACK,Follow._RBRACK_in_tupleType7864); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACK.Add(RBRACK344);



			{
			// AST REWRITE
			// elements: nonTupleType, type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1488:48: -> ^( TUPLE_TYPE nonTupleType ( type )* )
			{
				DebugLocation(1488, 51);
				// TypeScript.g3:1488:51: ^( TUPLE_TYPE nonTupleType ( type )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1488, 53);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TUPLE_TYPE, "TUPLE_TYPE"), root_1);

				DebugLocation(1488, 64);
				adaptor.AddChild(root_1, stream_nonTupleType.NextTree());
				DebugLocation(1488, 77);
				// TypeScript.g3:1488:77: ( type )*
				while ( stream_type.HasNext )
				{
					DebugLocation(1488, 77);
					adaptor.AddChild(root_1, stream_type.NextTree());

				}
				stream_type.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tupleType", 98);
			LeaveRule("tupleType", 98);
			LeaveRule_tupleType();
		}
		DebugLocation(1489, 4);
		} finally { DebugExitRule(GrammarFileName, "tupleType"); }
		return retval;

	}
	// $ANTLR end "tupleType"

	partial void EnterRule_unionType();
	partial void LeaveRule_unionType();
	// $ANTLR start "unionType"
	// TypeScript.g3:1495:1: unionType : primaryType ( OR primaryType )+ ;
	[GrammarRule("unionType")]
	private AstParserRuleReturnScope<object, IToken> unionType()
	{
		EnterRule_unionType();
		EnterRule("unionType", 99);
		TraceIn("unionType", 99);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR346 = default(IToken);
		AstParserRuleReturnScope<object, IToken> primaryType345 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primaryType347 = default(AstParserRuleReturnScope<object, IToken>);

		object OR346_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "unionType");
		DebugLocation(1495, 4);
		try
		{
			// TypeScript.g3:1496:5: ( primaryType ( OR primaryType )+ )
			DebugEnterAlt(1);
			// TypeScript.g3:1496:7: primaryType ( OR primaryType )+
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1496, 7);
			PushFollow(Follow._primaryType_in_unionType7896);
			primaryType345=primaryType();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, primaryType345.Tree);
			DebugLocation(1496, 19);
			// TypeScript.g3:1496:19: ( OR primaryType )+
			int cnt96=0;
			try { DebugEnterSubRule(96);
			while (true)
			{
				int alt96=2;
				try { DebugEnterDecision(96, false);
				int LA96_1 = input.LA(1);

				if ((LA96_1==OR))
				{
					alt96 = 1;
				}


				} finally { DebugExitDecision(96); }
				switch (alt96)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1496:20: OR primaryType
					{
					DebugLocation(1496, 20);
					OR346=(IToken)Match(input,OR,Follow._OR_in_unionType7899); if (state.failed) return retval;
					if (state.backtracking == 0) {
					OR346_tree = (object)adaptor.Create(OR346);
					adaptor.AddChild(root_0, OR346_tree);
					}
					DebugLocation(1496, 23);
					PushFollow(Follow._primaryType_in_unionType7901);
					primaryType347=primaryType();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primaryType347.Tree);

					}
					break;

				default:
					if (cnt96 >= 1)
						goto loop96;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee96 = new EarlyExitException( 96, input );
					DebugRecognitionException(eee96);
					throw eee96;
				}
				cnt96++;
			}
			loop96:
				;

			} finally { DebugExitSubRule(96); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unionType", 99);
			LeaveRule("unionType", 99);
			LeaveRule_unionType();
		}
		DebugLocation(1497, 4);
		} finally { DebugExitRule(GrammarFileName, "unionType"); }
		return retval;

	}
	// $ANTLR end "unionType"

	partial void EnterRule_functionType();
	partial void LeaveRule_functionType();
	// $ANTLR start "functionType"
	// TypeScript.g3:1503:1: functionType : ( typeParameters )? LPAREN ( parameterList )? RPAREN ARROW type -> ^( FUNC_TYPE ( typeParameters )? ( parameterList )? ( type )? ) ;
	[GrammarRule("functionType")]
	private AstParserRuleReturnScope<object, IToken> functionType()
	{
		EnterRule_functionType();
		EnterRule("functionType", 100);
		TraceIn("functionType", 100);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN349 = default(IToken);
		IToken RPAREN351 = default(IToken);
		IToken ARROW352 = default(IToken);
		AstParserRuleReturnScope<object, IToken> typeParameters348 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parameterList350 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type353 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN349_tree = default(object);
		object RPAREN351_tree = default(object);
		object ARROW352_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_ARROW=new RewriteRuleITokenStream(adaptor,"token ARROW");
		RewriteRuleSubtreeStream stream_typeParameters=new RewriteRuleSubtreeStream(adaptor,"rule typeParameters");
		RewriteRuleSubtreeStream stream_parameterList=new RewriteRuleSubtreeStream(adaptor,"rule parameterList");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "functionType");
		DebugLocation(1503, 4);
		try
		{
			// TypeScript.g3:1504:5: ( ( typeParameters )? LPAREN ( parameterList )? RPAREN ARROW type -> ^( FUNC_TYPE ( typeParameters )? ( parameterList )? ( type )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1504:7: ( typeParameters )? LPAREN ( parameterList )? RPAREN ARROW type
			{
			DebugLocation(1504, 7);
			// TypeScript.g3:1504:7: ( typeParameters )?
			int alt97=2;
			try { DebugEnterSubRule(97);
			try { DebugEnterDecision(97, false);
			int LA97_1 = input.LA(1);

			if ((LA97_1==LT))
			{
				alt97 = 1;
			}
			} finally { DebugExitDecision(97); }
			switch (alt97)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1504:7: typeParameters
				{
				DebugLocation(1504, 7);
				PushFollow(Follow._typeParameters_in_functionType7924);
				typeParameters348=typeParameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeParameters.Add(typeParameters348.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(97); }

			DebugLocation(1504, 23);
			LPAREN349=(IToken)Match(input,LPAREN,Follow._LPAREN_in_functionType7927); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN349);

			DebugLocation(1504, 30);
			// TypeScript.g3:1504:30: ( parameterList )?
			int alt98=2;
			try { DebugEnterSubRule(98);
			try { DebugEnterDecision(98, false);
			int LA98_1 = input.LA(1);

			if ((LA98_1==ANY||LA98_1==CONSTRUCTOR||LA98_1==DECLARE||LA98_1==ELLIPSIS||LA98_1==FINAL||LA98_1==GET||LA98_1==Identifier||LA98_1==MODULE||LA98_1==NUMBER||LA98_1==PRIVATE||LA98_1==PROTECTED||LA98_1==PUBLIC||LA98_1==REQUIRE||LA98_1==SET||LA98_1==STRING||LA98_1==THROWS||LA98_1==TYPE))
			{
				alt98 = 1;
			}
			} finally { DebugExitDecision(98); }
			switch (alt98)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1504:30: parameterList
				{
				DebugLocation(1504, 30);
				PushFollow(Follow._parameterList_in_functionType7929);
				parameterList350=parameterList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterList.Add(parameterList350.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(98); }

			DebugLocation(1504, 45);
			RPAREN351=(IToken)Match(input,RPAREN,Follow._RPAREN_in_functionType7932); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN351);

			DebugLocation(1504, 52);
			ARROW352=(IToken)Match(input,ARROW,Follow._ARROW_in_functionType7934); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ARROW.Add(ARROW352);

			DebugLocation(1504, 58);
			PushFollow(Follow._type_in_functionType7936);
			type353=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(type353.Tree);


			{
			// AST REWRITE
			// elements: typeParameters, parameterList, type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1504:63: -> ^( FUNC_TYPE ( typeParameters )? ( parameterList )? ( type )? )
			{
				DebugLocation(1504, 66);
				// TypeScript.g3:1504:66: ^( FUNC_TYPE ( typeParameters )? ( parameterList )? ( type )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1504, 68);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNC_TYPE, "FUNC_TYPE"), root_1);

				DebugLocation(1504, 78);
				// TypeScript.g3:1504:78: ( typeParameters )?
				if (stream_typeParameters.HasNext)
				{
					DebugLocation(1504, 78);
					adaptor.AddChild(root_1, stream_typeParameters.NextTree());

				}
				stream_typeParameters.Reset();
				DebugLocation(1504, 94);
				// TypeScript.g3:1504:94: ( parameterList )?
				if (stream_parameterList.HasNext)
				{
					DebugLocation(1504, 94);
					adaptor.AddChild(root_1, stream_parameterList.NextTree());

				}
				stream_parameterList.Reset();
				DebugLocation(1504, 109);
				// TypeScript.g3:1504:109: ( type )?
				if (stream_type.HasNext)
				{
					DebugLocation(1504, 109);
					adaptor.AddChild(root_1, stream_type.NextTree());

				}
				stream_type.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionType", 100);
			LeaveRule("functionType", 100);
			LeaveRule_functionType();
		}
		DebugLocation(1505, 4);
		} finally { DebugExitRule(GrammarFileName, "functionType"); }
		return retval;

	}
	// $ANTLR end "functionType"

	partial void EnterRule_constructorType();
	partial void LeaveRule_constructorType();
	// $ANTLR start "constructorType"
	// TypeScript.g3:1511:1: constructorType : NEW ( typeParameters )? LPAREN ( parameterList )? RPAREN ARROW type -> ^( CONST_TYPE ( typeParameters )? ( parameterList )? ( type )? ) ;
	[GrammarRule("constructorType")]
	private AstParserRuleReturnScope<object, IToken> constructorType()
	{
		EnterRule_constructorType();
		EnterRule("constructorType", 101);
		TraceIn("constructorType", 101);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NEW354 = default(IToken);
		IToken LPAREN356 = default(IToken);
		IToken RPAREN358 = default(IToken);
		IToken ARROW359 = default(IToken);
		AstParserRuleReturnScope<object, IToken> typeParameters355 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parameterList357 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type360 = default(AstParserRuleReturnScope<object, IToken>);

		object NEW354_tree = default(object);
		object LPAREN356_tree = default(object);
		object RPAREN358_tree = default(object);
		object ARROW359_tree = default(object);
		RewriteRuleITokenStream stream_NEW=new RewriteRuleITokenStream(adaptor,"token NEW");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_ARROW=new RewriteRuleITokenStream(adaptor,"token ARROW");
		RewriteRuleSubtreeStream stream_typeParameters=new RewriteRuleSubtreeStream(adaptor,"rule typeParameters");
		RewriteRuleSubtreeStream stream_parameterList=new RewriteRuleSubtreeStream(adaptor,"rule parameterList");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "constructorType");
		DebugLocation(1511, 4);
		try
		{
			// TypeScript.g3:1512:5: ( NEW ( typeParameters )? LPAREN ( parameterList )? RPAREN ARROW type -> ^( CONST_TYPE ( typeParameters )? ( parameterList )? ( type )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1512:7: NEW ( typeParameters )? LPAREN ( parameterList )? RPAREN ARROW type
			{
			DebugLocation(1512, 7);
			NEW354=(IToken)Match(input,NEW,Follow._NEW_in_constructorType7972); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NEW.Add(NEW354);

			DebugLocation(1512, 11);
			// TypeScript.g3:1512:11: ( typeParameters )?
			int alt99=2;
			try { DebugEnterSubRule(99);
			try { DebugEnterDecision(99, false);
			int LA99_1 = input.LA(1);

			if ((LA99_1==LT))
			{
				alt99 = 1;
			}
			} finally { DebugExitDecision(99); }
			switch (alt99)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1512:11: typeParameters
				{
				DebugLocation(1512, 11);
				PushFollow(Follow._typeParameters_in_constructorType7974);
				typeParameters355=typeParameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeParameters.Add(typeParameters355.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(99); }

			DebugLocation(1512, 27);
			LPAREN356=(IToken)Match(input,LPAREN,Follow._LPAREN_in_constructorType7977); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN356);

			DebugLocation(1512, 34);
			// TypeScript.g3:1512:34: ( parameterList )?
			int alt100=2;
			try { DebugEnterSubRule(100);
			try { DebugEnterDecision(100, false);
			int LA100_1 = input.LA(1);

			if ((LA100_1==ANY||LA100_1==CONSTRUCTOR||LA100_1==DECLARE||LA100_1==ELLIPSIS||LA100_1==FINAL||LA100_1==GET||LA100_1==Identifier||LA100_1==MODULE||LA100_1==NUMBER||LA100_1==PRIVATE||LA100_1==PROTECTED||LA100_1==PUBLIC||LA100_1==REQUIRE||LA100_1==SET||LA100_1==STRING||LA100_1==THROWS||LA100_1==TYPE))
			{
				alt100 = 1;
			}
			} finally { DebugExitDecision(100); }
			switch (alt100)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1512:34: parameterList
				{
				DebugLocation(1512, 34);
				PushFollow(Follow._parameterList_in_constructorType7979);
				parameterList357=parameterList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterList.Add(parameterList357.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(100); }

			DebugLocation(1512, 49);
			RPAREN358=(IToken)Match(input,RPAREN,Follow._RPAREN_in_constructorType7982); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN358);

			DebugLocation(1512, 56);
			ARROW359=(IToken)Match(input,ARROW,Follow._ARROW_in_constructorType7984); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ARROW.Add(ARROW359);

			DebugLocation(1512, 62);
			PushFollow(Follow._type_in_constructorType7986);
			type360=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(type360.Tree);


			{
			// AST REWRITE
			// elements: typeParameters, parameterList, type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1512:67: -> ^( CONST_TYPE ( typeParameters )? ( parameterList )? ( type )? )
			{
				DebugLocation(1512, 70);
				// TypeScript.g3:1512:70: ^( CONST_TYPE ( typeParameters )? ( parameterList )? ( type )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1512, 72);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CONST_TYPE, "CONST_TYPE"), root_1);

				DebugLocation(1512, 83);
				// TypeScript.g3:1512:83: ( typeParameters )?
				if (stream_typeParameters.HasNext)
				{
					DebugLocation(1512, 83);
					adaptor.AddChild(root_1, stream_typeParameters.NextTree());

				}
				stream_typeParameters.Reset();
				DebugLocation(1512, 99);
				// TypeScript.g3:1512:99: ( parameterList )?
				if (stream_parameterList.HasNext)
				{
					DebugLocation(1512, 99);
					adaptor.AddChild(root_1, stream_parameterList.NextTree());

				}
				stream_parameterList.Reset();
				DebugLocation(1512, 114);
				// TypeScript.g3:1512:114: ( type )?
				if (stream_type.HasNext)
				{
					DebugLocation(1512, 114);
					adaptor.AddChild(root_1, stream_type.NextTree());

				}
				stream_type.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constructorType", 101);
			LeaveRule("constructorType", 101);
			LeaveRule_constructorType();
		}
		DebugLocation(1513, 4);
		} finally { DebugExitRule(GrammarFileName, "constructorType"); }
		return retval;

	}
	// $ANTLR end "constructorType"

	partial void EnterRule_typeQuery();
	partial void LeaveRule_typeQuery();
	// $ANTLR start "typeQuery"
	// TypeScript.g3:1519:1: typeQuery : TYPEOF ^ ( identifier | qName ) ;
	[GrammarRule("typeQuery")]
	private AstParserRuleReturnScope<object, IToken> typeQuery()
	{
		EnterRule_typeQuery();
		EnterRule("typeQuery", 102);
		TraceIn("typeQuery", 102);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TYPEOF361 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier362 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> qName363 = default(AstParserRuleReturnScope<object, IToken>);

		object TYPEOF361_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "typeQuery");
		DebugLocation(1519, 4);
		try
		{
			// TypeScript.g3:1520:5: ( TYPEOF ^ ( identifier | qName ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1520:7: TYPEOF ^ ( identifier | qName )
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1520, 13);
			TYPEOF361=(IToken)Match(input,TYPEOF,Follow._TYPEOF_in_typeQuery8022); if (state.failed) return retval;
			if (state.backtracking == 0) {
			TYPEOF361_tree = (object)adaptor.Create(TYPEOF361);
			root_0 = (object)adaptor.BecomeRoot(TYPEOF361_tree, root_0);
			}
			DebugLocation(1520, 15);
			// TypeScript.g3:1520:15: ( identifier | qName )
			int alt101=2;
			try { DebugEnterSubRule(101);
			try { DebugEnterDecision(101, false);
			int LA101_1 = input.LA(1);

			if ((LA101_1==ANY||LA101_1==CONSTRUCTOR||LA101_1==DECLARE||LA101_1==FINAL||LA101_1==GET||LA101_1==MODULE||LA101_1==NUMBER||LA101_1==REQUIRE||LA101_1==SET||LA101_1==STRING||LA101_1==THROWS||LA101_1==TYPE))
			{
				int LA101_2 = input.LA(2);

				if ((LA101_2==EOF||LA101_2==ASSIGN||LA101_2==COMMA||LA101_2==EOL||LA101_2==GT||LA101_2==IN||(LA101_2>=LBRACE && LA101_2<=LBRACK)||LA101_2==MultiLineComment||LA101_2==OR||(LA101_2>=RBRACE && LA101_2<=RBRACK)||LA101_2==RPAREN||LA101_2==SEMIC))
				{
					alt101 = 1;
				}
				else if ((LA101_2==DOT))
				{
					alt101 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 101, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA101_1==Identifier))
			{
				int LA101_2 = input.LA(2);

				if ((LA101_2==EOF||LA101_2==ASSIGN||LA101_2==COMMA||LA101_2==EOL||LA101_2==GT||LA101_2==IN||(LA101_2>=LBRACE && LA101_2<=LBRACK)||LA101_2==MultiLineComment||LA101_2==OR||(LA101_2>=RBRACE && LA101_2<=RBRACK)||LA101_2==RPAREN||LA101_2==SEMIC))
				{
					alt101 = 1;
				}
				else if ((LA101_2==DOT))
				{
					alt101 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 101, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 101, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(101); }
			switch (alt101)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1520:16: identifier
				{
				DebugLocation(1520, 16);
				PushFollow(Follow._identifier_in_typeQuery8026);
				identifier362=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifier362.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1520:29: qName
				{
				DebugLocation(1520, 29);
				PushFollow(Follow._qName_in_typeQuery8030);
				qName363=qName();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, qName363.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(101); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeQuery", 102);
			LeaveRule("typeQuery", 102);
			LeaveRule_typeQuery();
		}
		DebugLocation(1521, 4);
		} finally { DebugExitRule(GrammarFileName, "typeQuery"); }
		return retval;

	}
	// $ANTLR end "typeQuery"

	partial void EnterRule_propertySignature();
	partial void LeaveRule_propertySignature();
	// $ANTLR start "propertySignature"
	// TypeScript.g3:1529:1: propertySignature : propertyName ( QUE )? ( typeAnnotation )? -> ^( PROP_SIG propertyName ( QUE )? ( typeAnnotation )? ) ;
	[GrammarRule("propertySignature")]
	private AstParserRuleReturnScope<object, IToken> propertySignature()
	{
		EnterRule_propertySignature();
		EnterRule("propertySignature", 103);
		TraceIn("propertySignature", 103);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken QUE365 = default(IToken);
		AstParserRuleReturnScope<object, IToken> propertyName364 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation366 = default(AstParserRuleReturnScope<object, IToken>);

		object QUE365_tree = default(object);
		RewriteRuleITokenStream stream_QUE=new RewriteRuleITokenStream(adaptor,"token QUE");
		RewriteRuleSubtreeStream stream_propertyName=new RewriteRuleSubtreeStream(adaptor,"rule propertyName");
		RewriteRuleSubtreeStream stream_typeAnnotation=new RewriteRuleSubtreeStream(adaptor,"rule typeAnnotation");
		try { DebugEnterRule(GrammarFileName, "propertySignature");
		DebugLocation(1529, 4);
		try
		{
			// TypeScript.g3:1530:5: ( propertyName ( QUE )? ( typeAnnotation )? -> ^( PROP_SIG propertyName ( QUE )? ( typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1530:7: propertyName ( QUE )? ( typeAnnotation )?
			{
			DebugLocation(1530, 7);
			PushFollow(Follow._propertyName_in_propertySignature8058);
			propertyName364=propertyName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_propertyName.Add(propertyName364.Tree);
			DebugLocation(1530, 20);
			// TypeScript.g3:1530:20: ( QUE )?
			int alt102=2;
			try { DebugEnterSubRule(102);
			try { DebugEnterDecision(102, false);
			int LA102_1 = input.LA(1);

			if ((LA102_1==QUE))
			{
				alt102 = 1;
			}
			} finally { DebugExitDecision(102); }
			switch (alt102)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1530:20: QUE
				{
				DebugLocation(1530, 20);
				QUE365=(IToken)Match(input,QUE,Follow._QUE_in_propertySignature8060); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_QUE.Add(QUE365);


				}
				break;

			}
			} finally { DebugExitSubRule(102); }

			DebugLocation(1530, 25);
			// TypeScript.g3:1530:25: ( typeAnnotation )?
			int alt103=2;
			try { DebugEnterSubRule(103);
			try { DebugEnterDecision(103, false);
			int LA103_1 = input.LA(1);

			if ((LA103_1==COLON))
			{
				alt103 = 1;
			}
			} finally { DebugExitDecision(103); }
			switch (alt103)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1530:25: typeAnnotation
				{
				DebugLocation(1530, 25);
				PushFollow(Follow._typeAnnotation_in_propertySignature8063);
				typeAnnotation366=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation366.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(103); }



			{
			// AST REWRITE
			// elements: propertyName, QUE, typeAnnotation
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1530:41: -> ^( PROP_SIG propertyName ( QUE )? ( typeAnnotation )? )
			{
				DebugLocation(1530, 44);
				// TypeScript.g3:1530:44: ^( PROP_SIG propertyName ( QUE )? ( typeAnnotation )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1530, 46);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROP_SIG, "PROP_SIG"), root_1);

				DebugLocation(1530, 55);
				adaptor.AddChild(root_1, stream_propertyName.NextTree());
				DebugLocation(1530, 68);
				// TypeScript.g3:1530:68: ( QUE )?
				if (stream_QUE.HasNext)
				{
					DebugLocation(1530, 68);
					adaptor.AddChild(root_1, stream_QUE.NextNode());

				}
				stream_QUE.Reset();
				DebugLocation(1530, 73);
				// TypeScript.g3:1530:73: ( typeAnnotation )?
				if (stream_typeAnnotation.HasNext)
				{
					DebugLocation(1530, 73);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

				}
				stream_typeAnnotation.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertySignature", 103);
			LeaveRule("propertySignature", 103);
			LeaveRule_propertySignature();
		}
		DebugLocation(1531, 4);
		} finally { DebugExitRule(GrammarFileName, "propertySignature"); }
		return retval;

	}
	// $ANTLR end "propertySignature"

	partial void EnterRule_callSignature();
	partial void LeaveRule_callSignature();
	// $ANTLR start "callSignature"
	// TypeScript.g3:1537:1: callSignature : ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? -> ^( CALL_SIG ( typeParameters )? ( parameterList )? ( typeAnnotation )? ) ;
	[GrammarRule("callSignature")]
	private AstParserRuleReturnScope<object, IToken> callSignature()
	{
		EnterRule_callSignature();
		EnterRule("callSignature", 104);
		TraceIn("callSignature", 104);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN368 = default(IToken);
		IToken RPAREN370 = default(IToken);
		AstParserRuleReturnScope<object, IToken> typeParameters367 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parameterList369 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation371 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN368_tree = default(object);
		object RPAREN370_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_typeParameters=new RewriteRuleSubtreeStream(adaptor,"rule typeParameters");
		RewriteRuleSubtreeStream stream_parameterList=new RewriteRuleSubtreeStream(adaptor,"rule parameterList");
		RewriteRuleSubtreeStream stream_typeAnnotation=new RewriteRuleSubtreeStream(adaptor,"rule typeAnnotation");
		try { DebugEnterRule(GrammarFileName, "callSignature");
		DebugLocation(1537, 4);
		try
		{
			// TypeScript.g3:1538:5: ( ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? -> ^( CALL_SIG ( typeParameters )? ( parameterList )? ( typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1538:7: ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )?
			{
			DebugLocation(1538, 7);
			// TypeScript.g3:1538:7: ( typeParameters )?
			int alt104=2;
			try { DebugEnterSubRule(104);
			try { DebugEnterDecision(104, false);
			int LA104_1 = input.LA(1);

			if ((LA104_1==LT))
			{
				alt104 = 1;
			}
			} finally { DebugExitDecision(104); }
			switch (alt104)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1538:7: typeParameters
				{
				DebugLocation(1538, 7);
				PushFollow(Follow._typeParameters_in_callSignature8099);
				typeParameters367=typeParameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeParameters.Add(typeParameters367.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(104); }

			DebugLocation(1538, 23);
			LPAREN368=(IToken)Match(input,LPAREN,Follow._LPAREN_in_callSignature8102); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN368);

			DebugLocation(1538, 30);
			// TypeScript.g3:1538:30: ( parameterList )?
			int alt105=2;
			try { DebugEnterSubRule(105);
			try { DebugEnterDecision(105, false);
			int LA105_1 = input.LA(1);

			if ((LA105_1==ANY||LA105_1==CONSTRUCTOR||LA105_1==DECLARE||LA105_1==ELLIPSIS||LA105_1==FINAL||LA105_1==GET||LA105_1==Identifier||LA105_1==MODULE||LA105_1==NUMBER||LA105_1==PRIVATE||LA105_1==PROTECTED||LA105_1==PUBLIC||LA105_1==REQUIRE||LA105_1==SET||LA105_1==STRING||LA105_1==THROWS||LA105_1==TYPE))
			{
				alt105 = 1;
			}
			} finally { DebugExitDecision(105); }
			switch (alt105)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1538:30: parameterList
				{
				DebugLocation(1538, 30);
				PushFollow(Follow._parameterList_in_callSignature8104);
				parameterList369=parameterList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterList.Add(parameterList369.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(105); }

			DebugLocation(1538, 45);
			RPAREN370=(IToken)Match(input,RPAREN,Follow._RPAREN_in_callSignature8107); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN370);

			DebugLocation(1538, 52);
			// TypeScript.g3:1538:52: ( typeAnnotation )?
			int alt106=2;
			try { DebugEnterSubRule(106);
			try { DebugEnterDecision(106, false);
			int LA106_1 = input.LA(1);

			if ((LA106_1==COLON))
			{
				alt106 = 1;
			}
			} finally { DebugExitDecision(106); }
			switch (alt106)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1538:52: typeAnnotation
				{
				DebugLocation(1538, 52);
				PushFollow(Follow._typeAnnotation_in_callSignature8109);
				typeAnnotation371=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation371.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(106); }



			{
			// AST REWRITE
			// elements: typeParameters, parameterList, typeAnnotation
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1538:68: -> ^( CALL_SIG ( typeParameters )? ( parameterList )? ( typeAnnotation )? )
			{
				DebugLocation(1538, 71);
				// TypeScript.g3:1538:71: ^( CALL_SIG ( typeParameters )? ( parameterList )? ( typeAnnotation )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1538, 73);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL_SIG, "CALL_SIG"), root_1);

				DebugLocation(1538, 82);
				// TypeScript.g3:1538:82: ( typeParameters )?
				if (stream_typeParameters.HasNext)
				{
					DebugLocation(1538, 82);
					adaptor.AddChild(root_1, stream_typeParameters.NextTree());

				}
				stream_typeParameters.Reset();
				DebugLocation(1538, 98);
				// TypeScript.g3:1538:98: ( parameterList )?
				if (stream_parameterList.HasNext)
				{
					DebugLocation(1538, 98);
					adaptor.AddChild(root_1, stream_parameterList.NextTree());

				}
				stream_parameterList.Reset();
				DebugLocation(1538, 113);
				// TypeScript.g3:1538:113: ( typeAnnotation )?
				if (stream_typeAnnotation.HasNext)
				{
					DebugLocation(1538, 113);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

				}
				stream_typeAnnotation.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("callSignature", 104);
			LeaveRule("callSignature", 104);
			LeaveRule_callSignature();
		}
		DebugLocation(1539, 4);
		} finally { DebugExitRule(GrammarFileName, "callSignature"); }
		return retval;

	}
	// $ANTLR end "callSignature"

	partial void EnterRule_parameterList();
	partial void LeaveRule_parameterList();
	// $ANTLR start "parameterList"
	// TypeScript.g3:1545:1: parameterList : ( parameter ( COMMA parameter )* ( COMMA restParameter )? -> ^( PARAMS ( parameter )* ( restParameter )? ) | restParameter -> ^( PARAMS restParameter ) );
	[GrammarRule("parameterList")]
	private AstParserRuleReturnScope<object, IToken> parameterList()
	{
		EnterRule_parameterList();
		EnterRule("parameterList", 105);
		TraceIn("parameterList", 105);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA373 = default(IToken);
		IToken COMMA375 = default(IToken);
		AstParserRuleReturnScope<object, IToken> parameter372 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parameter374 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> restParameter376 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> restParameter377 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA373_tree = default(object);
		object COMMA375_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_parameter=new RewriteRuleSubtreeStream(adaptor,"rule parameter");
		RewriteRuleSubtreeStream stream_restParameter=new RewriteRuleSubtreeStream(adaptor,"rule restParameter");
		try { DebugEnterRule(GrammarFileName, "parameterList");
		DebugLocation(1545, 4);
		try
		{
			// TypeScript.g3:1546:5: ( parameter ( COMMA parameter )* ( COMMA restParameter )? -> ^( PARAMS ( parameter )* ( restParameter )? ) | restParameter -> ^( PARAMS restParameter ) )
			int alt109=2;
			try { DebugEnterDecision(109, false);
			int LA109_1 = input.LA(1);

			if ((LA109_1==ANY||LA109_1==CONSTRUCTOR||LA109_1==DECLARE||LA109_1==FINAL||LA109_1==GET||LA109_1==Identifier||LA109_1==MODULE||LA109_1==NUMBER||LA109_1==PRIVATE||LA109_1==PROTECTED||LA109_1==PUBLIC||LA109_1==REQUIRE||LA109_1==SET||LA109_1==STRING||LA109_1==THROWS||LA109_1==TYPE))
			{
				alt109 = 1;
			}
			else if ((LA109_1==ELLIPSIS))
			{
				alt109 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 109, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(109); }
			switch (alt109)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1546:7: parameter ( COMMA parameter )* ( COMMA restParameter )?
				{
				DebugLocation(1546, 7);
				PushFollow(Follow._parameter_in_parameterList8146);
				parameter372=parameter();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameter.Add(parameter372.Tree);
				DebugLocation(1546, 17);
				// TypeScript.g3:1546:17: ( COMMA parameter )*
				try { DebugEnterSubRule(107);
				while (true)
				{
					int alt107=2;
					try { DebugEnterDecision(107, false);
					int LA107_1 = input.LA(1);

					if ((LA107_1==COMMA))
					{
						int LA107_2 = input.LA(2);

						if ((LA107_2==ANY||LA107_2==CONSTRUCTOR||LA107_2==DECLARE||LA107_2==FINAL||LA107_2==GET||LA107_2==Identifier||LA107_2==MODULE||LA107_2==NUMBER||LA107_2==PRIVATE||LA107_2==PROTECTED||LA107_2==PUBLIC||LA107_2==REQUIRE||LA107_2==SET||LA107_2==STRING||LA107_2==THROWS||LA107_2==TYPE))
						{
							alt107 = 1;
						}


					}


					} finally { DebugExitDecision(107); }
					switch ( alt107 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScript.g3:1546:19: COMMA parameter
						{
						DebugLocation(1546, 19);
						COMMA373=(IToken)Match(input,COMMA,Follow._COMMA_in_parameterList8150); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA373);

						DebugLocation(1546, 25);
						PushFollow(Follow._parameter_in_parameterList8152);
						parameter374=parameter();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_parameter.Add(parameter374.Tree);

						}
						break;

					default:
						goto loop107;
					}
				}

				loop107:
					;

				} finally { DebugExitSubRule(107); }

				DebugLocation(1546, 38);
				// TypeScript.g3:1546:38: ( COMMA restParameter )?
				int alt108=2;
				try { DebugEnterSubRule(108);
				try { DebugEnterDecision(108, false);
				int LA108_1 = input.LA(1);

				if ((LA108_1==COMMA))
				{
					alt108 = 1;
				}
				} finally { DebugExitDecision(108); }
				switch (alt108)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1546:39: COMMA restParameter
					{
					DebugLocation(1546, 39);
					COMMA375=(IToken)Match(input,COMMA,Follow._COMMA_in_parameterList8158); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA375);

					DebugLocation(1546, 45);
					PushFollow(Follow._restParameter_in_parameterList8160);
					restParameter376=restParameter();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_restParameter.Add(restParameter376.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(108); }



				{
				// AST REWRITE
				// elements: parameter, restParameter
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1546:61: -> ^( PARAMS ( parameter )* ( restParameter )? )
				{
					DebugLocation(1546, 64);
					// TypeScript.g3:1546:64: ^( PARAMS ( parameter )* ( restParameter )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1546, 66);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAMS, "PARAMS"), root_1);

					DebugLocation(1546, 73);
					// TypeScript.g3:1546:73: ( parameter )*
					while ( stream_parameter.HasNext )
					{
						DebugLocation(1546, 73);
						adaptor.AddChild(root_1, stream_parameter.NextTree());

					}
					stream_parameter.Reset();
					DebugLocation(1546, 84);
					// TypeScript.g3:1546:84: ( restParameter )?
					if (stream_restParameter.HasNext)
					{
						DebugLocation(1546, 84);
						adaptor.AddChild(root_1, stream_restParameter.NextTree());

					}
					stream_restParameter.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1547:7: restParameter
				{
				DebugLocation(1547, 7);
				PushFollow(Follow._restParameter_in_parameterList8182);
				restParameter377=restParameter();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_restParameter.Add(restParameter377.Tree);


				{
				// AST REWRITE
				// elements: restParameter
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1547:21: -> ^( PARAMS restParameter )
				{
					DebugLocation(1547, 24);
					// TypeScript.g3:1547:24: ^( PARAMS restParameter )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1547, 26);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAMS, "PARAMS"), root_1);

					DebugLocation(1547, 33);
					adaptor.AddChild(root_1, stream_restParameter.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameterList", 105);
			LeaveRule("parameterList", 105);
			LeaveRule_parameterList();
		}
		DebugLocation(1548, 4);
		} finally { DebugExitRule(GrammarFileName, "parameterList"); }
		return retval;

	}
	// $ANTLR end "parameterList"

	partial void EnterRule_accessibilityModifier();
	partial void LeaveRule_accessibilityModifier();
	// $ANTLR start "accessibilityModifier"
	// TypeScript.g3:1550:1: accessibilityModifier : ( PUBLIC | PRIVATE | PROTECTED );
	[GrammarRule("accessibilityModifier")]
	private AstParserRuleReturnScope<object, IToken> accessibilityModifier()
	{
		EnterRule_accessibilityModifier();
		EnterRule("accessibilityModifier", 106);
		TraceIn("accessibilityModifier", 106);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set378 = default(IToken);

		object set378_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "accessibilityModifier");
		DebugLocation(1550, 4);
		try
		{
			// TypeScript.g3:1551:5: ( PUBLIC | PRIVATE | PROTECTED )
			DebugEnterAlt(1);
			// TypeScript.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1551, 5);

			set378=(IToken)input.LT(1);
			if (input.LA(1)==PRIVATE||input.LA(1)==PROTECTED||input.LA(1)==PUBLIC)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set378));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("accessibilityModifier", 106);
			LeaveRule("accessibilityModifier", 106);
			LeaveRule_accessibilityModifier();
		}
		DebugLocation(1554, 4);
		} finally { DebugExitRule(GrammarFileName, "accessibilityModifier"); }
		return retval;

	}
	// $ANTLR end "accessibilityModifier"

	partial void EnterRule_parameter();
	partial void LeaveRule_parameter();
	// $ANTLR start "parameter"
	// TypeScript.g3:1556:1: parameter : ( accessibilityModifier )? identifier ( QUE )? ( typeAnnotation )? ( ASSIGN assignmentExpression )? -> ^( PARAM identifier ( accessibilityModifier )? ( QUE )? ( typeAnnotation )? ( assignmentExpression )? ) ;
	[GrammarRule("parameter")]
	private AstParserRuleReturnScope<object, IToken> parameter()
	{
		EnterRule_parameter();
		EnterRule("parameter", 107);
		TraceIn("parameter", 107);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken QUE381 = default(IToken);
		IToken ASSIGN383 = default(IToken);
		AstParserRuleReturnScope<object, IToken> accessibilityModifier379 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> identifier380 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation382 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression384 = default(AstParserRuleReturnScope<object, IToken>);

		object QUE381_tree = default(object);
		object ASSIGN383_tree = default(object);
		RewriteRuleITokenStream stream_QUE=new RewriteRuleITokenStream(adaptor,"token QUE");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_accessibilityModifier=new RewriteRuleSubtreeStream(adaptor,"rule accessibilityModifier");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_typeAnnotation=new RewriteRuleSubtreeStream(adaptor,"rule typeAnnotation");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "parameter");
		DebugLocation(1556, 4);
		try
		{
			// TypeScript.g3:1557:5: ( ( accessibilityModifier )? identifier ( QUE )? ( typeAnnotation )? ( ASSIGN assignmentExpression )? -> ^( PARAM identifier ( accessibilityModifier )? ( QUE )? ( typeAnnotation )? ( assignmentExpression )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1557:7: ( accessibilityModifier )? identifier ( QUE )? ( typeAnnotation )? ( ASSIGN assignmentExpression )?
			{
			DebugLocation(1557, 7);
			// TypeScript.g3:1557:7: ( accessibilityModifier )?
			int alt110=2;
			try { DebugEnterSubRule(110);
			try { DebugEnterDecision(110, false);
			int LA110_1 = input.LA(1);

			if ((LA110_1==PRIVATE||LA110_1==PROTECTED||LA110_1==PUBLIC))
			{
				alt110 = 1;
			}
			} finally { DebugExitDecision(110); }
			switch (alt110)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1557:7: accessibilityModifier
				{
				DebugLocation(1557, 7);
				PushFollow(Follow._accessibilityModifier_in_parameter8240);
				accessibilityModifier379=accessibilityModifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_accessibilityModifier.Add(accessibilityModifier379.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(110); }

			DebugLocation(1557, 30);
			PushFollow(Follow._identifier_in_parameter8243);
			identifier380=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier380.Tree);
			DebugLocation(1557, 41);
			// TypeScript.g3:1557:41: ( QUE )?
			int alt111=2;
			try { DebugEnterSubRule(111);
			try { DebugEnterDecision(111, false);
			int LA111_1 = input.LA(1);

			if ((LA111_1==QUE))
			{
				alt111 = 1;
			}
			} finally { DebugExitDecision(111); }
			switch (alt111)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1557:41: QUE
				{
				DebugLocation(1557, 41);
				QUE381=(IToken)Match(input,QUE,Follow._QUE_in_parameter8245); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_QUE.Add(QUE381);


				}
				break;

			}
			} finally { DebugExitSubRule(111); }

			DebugLocation(1557, 46);
			// TypeScript.g3:1557:46: ( typeAnnotation )?
			int alt112=2;
			try { DebugEnterSubRule(112);
			try { DebugEnterDecision(112, false);
			int LA112_1 = input.LA(1);

			if ((LA112_1==COLON))
			{
				alt112 = 1;
			}
			} finally { DebugExitDecision(112); }
			switch (alt112)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1557:46: typeAnnotation
				{
				DebugLocation(1557, 46);
				PushFollow(Follow._typeAnnotation_in_parameter8248);
				typeAnnotation382=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation382.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(112); }

			DebugLocation(1557, 61);
			// TypeScript.g3:1557:61: ( ASSIGN assignmentExpression )?
			int alt113=2;
			try { DebugEnterSubRule(113);
			try { DebugEnterDecision(113, false);
			int LA113_1 = input.LA(1);

			if ((LA113_1==ASSIGN))
			{
				alt113 = 1;
			}
			} finally { DebugExitDecision(113); }
			switch (alt113)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1557:63: ASSIGN assignmentExpression
				{
				DebugLocation(1557, 63);
				ASSIGN383=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_parameter8252); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN383);

				DebugLocation(1557, 70);
				PushFollow(Follow._assignmentExpression_in_parameter8254);
				assignmentExpression384=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression384.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(113); }



			{
			// AST REWRITE
			// elements: identifier, accessibilityModifier, QUE, typeAnnotation, assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1557:94: -> ^( PARAM identifier ( accessibilityModifier )? ( QUE )? ( typeAnnotation )? ( assignmentExpression )? )
			{
				DebugLocation(1557, 97);
				// TypeScript.g3:1557:97: ^( PARAM identifier ( accessibilityModifier )? ( QUE )? ( typeAnnotation )? ( assignmentExpression )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1557, 99);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAM, "PARAM"), root_1);

				DebugLocation(1557, 105);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(1557, 116);
				// TypeScript.g3:1557:116: ( accessibilityModifier )?
				if (stream_accessibilityModifier.HasNext)
				{
					DebugLocation(1557, 116);
					adaptor.AddChild(root_1, stream_accessibilityModifier.NextTree());

				}
				stream_accessibilityModifier.Reset();
				DebugLocation(1557, 139);
				// TypeScript.g3:1557:139: ( QUE )?
				if (stream_QUE.HasNext)
				{
					DebugLocation(1557, 139);
					adaptor.AddChild(root_1, stream_QUE.NextNode());

				}
				stream_QUE.Reset();
				DebugLocation(1557, 144);
				// TypeScript.g3:1557:144: ( typeAnnotation )?
				if (stream_typeAnnotation.HasNext)
				{
					DebugLocation(1557, 144);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

				}
				stream_typeAnnotation.Reset();
				DebugLocation(1557, 160);
				// TypeScript.g3:1557:160: ( assignmentExpression )?
				if (stream_assignmentExpression.HasNext)
				{
					DebugLocation(1557, 160);
					adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				}
				stream_assignmentExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameter", 107);
			LeaveRule("parameter", 107);
			LeaveRule_parameter();
		}
		DebugLocation(1558, 4);
		} finally { DebugExitRule(GrammarFileName, "parameter"); }
		return retval;

	}
	// $ANTLR end "parameter"

	partial void EnterRule_restParameter();
	partial void LeaveRule_restParameter();
	// $ANTLR start "restParameter"
	// TypeScript.g3:1560:1: restParameter : ELLIPSIS identifier ( typeAnnotation )? -> ^( ELLIPSIS identifier ( typeAnnotation )? ) ;
	[GrammarRule("restParameter")]
	private AstParserRuleReturnScope<object, IToken> restParameter()
	{
		EnterRule_restParameter();
		EnterRule("restParameter", 108);
		TraceIn("restParameter", 108);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ELLIPSIS385 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier386 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation387 = default(AstParserRuleReturnScope<object, IToken>);

		object ELLIPSIS385_tree = default(object);
		RewriteRuleITokenStream stream_ELLIPSIS=new RewriteRuleITokenStream(adaptor,"token ELLIPSIS");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_typeAnnotation=new RewriteRuleSubtreeStream(adaptor,"rule typeAnnotation");
		try { DebugEnterRule(GrammarFileName, "restParameter");
		DebugLocation(1560, 4);
		try
		{
			// TypeScript.g3:1561:5: ( ELLIPSIS identifier ( typeAnnotation )? -> ^( ELLIPSIS identifier ( typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1561:7: ELLIPSIS identifier ( typeAnnotation )?
			{
			DebugLocation(1561, 7);
			ELLIPSIS385=(IToken)Match(input,ELLIPSIS,Follow._ELLIPSIS_in_restParameter8294); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ELLIPSIS.Add(ELLIPSIS385);

			DebugLocation(1561, 16);
			PushFollow(Follow._identifier_in_restParameter8296);
			identifier386=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier386.Tree);
			DebugLocation(1561, 27);
			// TypeScript.g3:1561:27: ( typeAnnotation )?
			int alt114=2;
			try { DebugEnterSubRule(114);
			try { DebugEnterDecision(114, false);
			int LA114_1 = input.LA(1);

			if ((LA114_1==COLON))
			{
				alt114 = 1;
			}
			} finally { DebugExitDecision(114); }
			switch (alt114)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1561:27: typeAnnotation
				{
				DebugLocation(1561, 27);
				PushFollow(Follow._typeAnnotation_in_restParameter8298);
				typeAnnotation387=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation387.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(114); }



			{
			// AST REWRITE
			// elements: ELLIPSIS, identifier, typeAnnotation
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1561:43: -> ^( ELLIPSIS identifier ( typeAnnotation )? )
			{
				DebugLocation(1561, 46);
				// TypeScript.g3:1561:46: ^( ELLIPSIS identifier ( typeAnnotation )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1561, 48);
				root_1 = (object)adaptor.BecomeRoot(stream_ELLIPSIS.NextNode(), root_1);

				DebugLocation(1561, 57);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(1561, 68);
				// TypeScript.g3:1561:68: ( typeAnnotation )?
				if (stream_typeAnnotation.HasNext)
				{
					DebugLocation(1561, 68);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

				}
				stream_typeAnnotation.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("restParameter", 108);
			LeaveRule("restParameter", 108);
			LeaveRule_restParameter();
		}
		DebugLocation(1562, 4);
		} finally { DebugExitRule(GrammarFileName, "restParameter"); }
		return retval;

	}
	// $ANTLR end "restParameter"

	partial void EnterRule_constructSignature();
	partial void LeaveRule_constructSignature();
	// $ANTLR start "constructSignature"
	// TypeScript.g3:1567:1: constructSignature : NEW ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? -> ^( CONST_SIG ( typeParameters )? ( parameterList )? ( typeAnnotation )? ) ;
	[GrammarRule("constructSignature")]
	private AstParserRuleReturnScope<object, IToken> constructSignature()
	{
		EnterRule_constructSignature();
		EnterRule("constructSignature", 109);
		TraceIn("constructSignature", 109);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NEW388 = default(IToken);
		IToken LPAREN390 = default(IToken);
		IToken RPAREN392 = default(IToken);
		AstParserRuleReturnScope<object, IToken> typeParameters389 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parameterList391 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation393 = default(AstParserRuleReturnScope<object, IToken>);

		object NEW388_tree = default(object);
		object LPAREN390_tree = default(object);
		object RPAREN392_tree = default(object);
		RewriteRuleITokenStream stream_NEW=new RewriteRuleITokenStream(adaptor,"token NEW");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_typeParameters=new RewriteRuleSubtreeStream(adaptor,"rule typeParameters");
		RewriteRuleSubtreeStream stream_parameterList=new RewriteRuleSubtreeStream(adaptor,"rule parameterList");
		RewriteRuleSubtreeStream stream_typeAnnotation=new RewriteRuleSubtreeStream(adaptor,"rule typeAnnotation");
		try { DebugEnterRule(GrammarFileName, "constructSignature");
		DebugLocation(1567, 4);
		try
		{
			// TypeScript.g3:1568:5: ( NEW ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? -> ^( CONST_SIG ( typeParameters )? ( parameterList )? ( typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1568:7: NEW ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )?
			{
			DebugLocation(1568, 7);
			NEW388=(IToken)Match(input,NEW,Follow._NEW_in_constructSignature8330); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NEW.Add(NEW388);

			DebugLocation(1568, 11);
			// TypeScript.g3:1568:11: ( typeParameters )?
			int alt115=2;
			try { DebugEnterSubRule(115);
			try { DebugEnterDecision(115, false);
			int LA115_1 = input.LA(1);

			if ((LA115_1==LT))
			{
				alt115 = 1;
			}
			} finally { DebugExitDecision(115); }
			switch (alt115)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1568:11: typeParameters
				{
				DebugLocation(1568, 11);
				PushFollow(Follow._typeParameters_in_constructSignature8332);
				typeParameters389=typeParameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeParameters.Add(typeParameters389.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(115); }

			DebugLocation(1568, 27);
			LPAREN390=(IToken)Match(input,LPAREN,Follow._LPAREN_in_constructSignature8335); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN390);

			DebugLocation(1568, 34);
			// TypeScript.g3:1568:34: ( parameterList )?
			int alt116=2;
			try { DebugEnterSubRule(116);
			try { DebugEnterDecision(116, false);
			int LA116_1 = input.LA(1);

			if ((LA116_1==ANY||LA116_1==CONSTRUCTOR||LA116_1==DECLARE||LA116_1==ELLIPSIS||LA116_1==FINAL||LA116_1==GET||LA116_1==Identifier||LA116_1==MODULE||LA116_1==NUMBER||LA116_1==PRIVATE||LA116_1==PROTECTED||LA116_1==PUBLIC||LA116_1==REQUIRE||LA116_1==SET||LA116_1==STRING||LA116_1==THROWS||LA116_1==TYPE))
			{
				alt116 = 1;
			}
			} finally { DebugExitDecision(116); }
			switch (alt116)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1568:34: parameterList
				{
				DebugLocation(1568, 34);
				PushFollow(Follow._parameterList_in_constructSignature8337);
				parameterList391=parameterList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterList.Add(parameterList391.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(116); }

			DebugLocation(1568, 49);
			RPAREN392=(IToken)Match(input,RPAREN,Follow._RPAREN_in_constructSignature8340); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN392);

			DebugLocation(1568, 56);
			// TypeScript.g3:1568:56: ( typeAnnotation )?
			int alt117=2;
			try { DebugEnterSubRule(117);
			try { DebugEnterDecision(117, false);
			int LA117_1 = input.LA(1);

			if ((LA117_1==COLON))
			{
				alt117 = 1;
			}
			} finally { DebugExitDecision(117); }
			switch (alt117)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1568:56: typeAnnotation
				{
				DebugLocation(1568, 56);
				PushFollow(Follow._typeAnnotation_in_constructSignature8342);
				typeAnnotation393=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation393.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(117); }



			{
			// AST REWRITE
			// elements: typeParameters, parameterList, typeAnnotation
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1568:72: -> ^( CONST_SIG ( typeParameters )? ( parameterList )? ( typeAnnotation )? )
			{
				DebugLocation(1568, 75);
				// TypeScript.g3:1568:75: ^( CONST_SIG ( typeParameters )? ( parameterList )? ( typeAnnotation )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1568, 77);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CONST_SIG, "CONST_SIG"), root_1);

				DebugLocation(1568, 87);
				// TypeScript.g3:1568:87: ( typeParameters )?
				if (stream_typeParameters.HasNext)
				{
					DebugLocation(1568, 87);
					adaptor.AddChild(root_1, stream_typeParameters.NextTree());

				}
				stream_typeParameters.Reset();
				DebugLocation(1568, 103);
				// TypeScript.g3:1568:103: ( parameterList )?
				if (stream_parameterList.HasNext)
				{
					DebugLocation(1568, 103);
					adaptor.AddChild(root_1, stream_parameterList.NextTree());

				}
				stream_parameterList.Reset();
				DebugLocation(1568, 118);
				// TypeScript.g3:1568:118: ( typeAnnotation )?
				if (stream_typeAnnotation.HasNext)
				{
					DebugLocation(1568, 118);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

				}
				stream_typeAnnotation.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constructSignature", 109);
			LeaveRule("constructSignature", 109);
			LeaveRule_constructSignature();
		}
		DebugLocation(1569, 4);
		} finally { DebugExitRule(GrammarFileName, "constructSignature"); }
		return retval;

	}
	// $ANTLR end "constructSignature"

	partial void EnterRule_indexSignature();
	partial void LeaveRule_indexSignature();
	// $ANTLR start "indexSignature"
	// TypeScript.g3:1572:1: indexSignature options {k=4; } : ( LBRACK identifier COLON STRING RBRACK typeAnnotation -> ^( INDEX_SIG identifier STRING typeAnnotation ) | LBRACK identifier COLON NUMBER RBRACK typeAnnotation -> ^( INDEX_SIG identifier NUMBER typeAnnotation ) );
	[GrammarRule("indexSignature")]
	private AstParserRuleReturnScope<object, IToken> indexSignature()
	{
		EnterRule_indexSignature();
		EnterRule("indexSignature", 110);
		TraceIn("indexSignature", 110);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LBRACK394 = default(IToken);
		IToken COLON396 = default(IToken);
		IToken STRING397 = default(IToken);
		IToken RBRACK398 = default(IToken);
		IToken LBRACK400 = default(IToken);
		IToken COLON402 = default(IToken);
		IToken NUMBER403 = default(IToken);
		IToken RBRACK404 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier395 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation399 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> identifier401 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation405 = default(AstParserRuleReturnScope<object, IToken>);

		object LBRACK394_tree = default(object);
		object COLON396_tree = default(object);
		object STRING397_tree = default(object);
		object RBRACK398_tree = default(object);
		object LBRACK400_tree = default(object);
		object COLON402_tree = default(object);
		object NUMBER403_tree = default(object);
		object RBRACK404_tree = default(object);
		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_STRING=new RewriteRuleITokenStream(adaptor,"token STRING");
		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
		RewriteRuleITokenStream stream_NUMBER=new RewriteRuleITokenStream(adaptor,"token NUMBER");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_typeAnnotation=new RewriteRuleSubtreeStream(adaptor,"rule typeAnnotation");
		try { DebugEnterRule(GrammarFileName, "indexSignature");
		DebugLocation(1572, 4);
		try
		{
			// TypeScript.g3:1577:5: ( LBRACK identifier COLON STRING RBRACK typeAnnotation -> ^( INDEX_SIG identifier STRING typeAnnotation ) | LBRACK identifier COLON NUMBER RBRACK typeAnnotation -> ^( INDEX_SIG identifier NUMBER typeAnnotation ) )
			int alt118=2;
			try { DebugEnterDecision(118, false);
			int LA118_1 = input.LA(1);

			if ((LA118_1==LBRACK))
			{
				int LA118_2 = input.LA(2);

				if ((LA118_2==ANY||LA118_2==CONSTRUCTOR||LA118_2==DECLARE||LA118_2==FINAL||LA118_2==GET||LA118_2==MODULE||LA118_2==NUMBER||LA118_2==REQUIRE||LA118_2==SET||LA118_2==STRING||LA118_2==THROWS||LA118_2==TYPE))
				{
					int LA118_3 = input.LA(3);

					if ((LA118_3==COLON))
					{
						int LA118_4 = input.LA(4);

						if ((LA118_4==STRING))
						{
							alt118 = 1;
						}
						else if ((LA118_4==NUMBER))
						{
							alt118 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 118, 4, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 118, 2, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA118_2==Identifier))
				{
					int LA118_3 = input.LA(3);

					if ((LA118_3==COLON))
					{
						int LA118_4 = input.LA(4);

						if ((LA118_4==STRING))
						{
							alt118 = 1;
						}
						else if ((LA118_4==NUMBER))
						{
							alt118 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 118, 5, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 118, 3, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 118, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 118, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(118); }
			switch (alt118)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1577:7: LBRACK identifier COLON STRING RBRACK typeAnnotation
				{
				DebugLocation(1577, 7);
				LBRACK394=(IToken)Match(input,LBRACK,Follow._LBRACK_in_indexSignature8389); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LBRACK.Add(LBRACK394);

				DebugLocation(1577, 14);
				PushFollow(Follow._identifier_in_indexSignature8391);
				identifier395=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_identifier.Add(identifier395.Tree);
				DebugLocation(1577, 25);
				COLON396=(IToken)Match(input,COLON,Follow._COLON_in_indexSignature8393); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON396);

				DebugLocation(1577, 31);
				STRING397=(IToken)Match(input,STRING,Follow._STRING_in_indexSignature8395); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STRING.Add(STRING397);

				DebugLocation(1577, 38);
				RBRACK398=(IToken)Match(input,RBRACK,Follow._RBRACK_in_indexSignature8397); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RBRACK.Add(RBRACK398);

				DebugLocation(1577, 45);
				PushFollow(Follow._typeAnnotation_in_indexSignature8399);
				typeAnnotation399=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation399.Tree);


				{
				// AST REWRITE
				// elements: identifier, STRING, typeAnnotation
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1577:60: -> ^( INDEX_SIG identifier STRING typeAnnotation )
				{
					DebugLocation(1577, 63);
					// TypeScript.g3:1577:63: ^( INDEX_SIG identifier STRING typeAnnotation )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1577, 65);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INDEX_SIG, "INDEX_SIG"), root_1);

					DebugLocation(1577, 75);
					adaptor.AddChild(root_1, stream_identifier.NextTree());
					DebugLocation(1577, 86);
					adaptor.AddChild(root_1, stream_STRING.NextNode());
					DebugLocation(1577, 93);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1578:7: LBRACK identifier COLON NUMBER RBRACK typeAnnotation
				{
				DebugLocation(1578, 7);
				LBRACK400=(IToken)Match(input,LBRACK,Follow._LBRACK_in_indexSignature8419); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LBRACK.Add(LBRACK400);

				DebugLocation(1578, 14);
				PushFollow(Follow._identifier_in_indexSignature8421);
				identifier401=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_identifier.Add(identifier401.Tree);
				DebugLocation(1578, 25);
				COLON402=(IToken)Match(input,COLON,Follow._COLON_in_indexSignature8423); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON402);

				DebugLocation(1578, 31);
				NUMBER403=(IToken)Match(input,NUMBER,Follow._NUMBER_in_indexSignature8425); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NUMBER.Add(NUMBER403);

				DebugLocation(1578, 38);
				RBRACK404=(IToken)Match(input,RBRACK,Follow._RBRACK_in_indexSignature8427); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RBRACK.Add(RBRACK404);

				DebugLocation(1578, 45);
				PushFollow(Follow._typeAnnotation_in_indexSignature8429);
				typeAnnotation405=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation405.Tree);


				{
				// AST REWRITE
				// elements: identifier, NUMBER, typeAnnotation
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1578:60: -> ^( INDEX_SIG identifier NUMBER typeAnnotation )
				{
					DebugLocation(1578, 63);
					// TypeScript.g3:1578:63: ^( INDEX_SIG identifier NUMBER typeAnnotation )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1578, 65);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INDEX_SIG, "INDEX_SIG"), root_1);

					DebugLocation(1578, 75);
					adaptor.AddChild(root_1, stream_identifier.NextTree());
					DebugLocation(1578, 86);
					adaptor.AddChild(root_1, stream_NUMBER.NextNode());
					DebugLocation(1578, 93);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("indexSignature", 110);
			LeaveRule("indexSignature", 110);
			LeaveRule_indexSignature();
		}
		DebugLocation(1579, 4);
		} finally { DebugExitRule(GrammarFileName, "indexSignature"); }
		return retval;

	}
	// $ANTLR end "indexSignature"

	partial void EnterRule_methodSignature();
	partial void LeaveRule_methodSignature();
	// $ANTLR start "methodSignature"
	// TypeScript.g3:1581:1: methodSignature : propertyName ( QUE )? ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? -> ^( METH_SIG propertyName ( QUE )? ( typeParameters )? ( parameterList )? ( typeAnnotation )? ) ;
	[GrammarRule("methodSignature")]
	private AstParserRuleReturnScope<object, IToken> methodSignature()
	{
		EnterRule_methodSignature();
		EnterRule("methodSignature", 111);
		TraceIn("methodSignature", 111);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken QUE407 = default(IToken);
		IToken LPAREN409 = default(IToken);
		IToken RPAREN411 = default(IToken);
		AstParserRuleReturnScope<object, IToken> propertyName406 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeParameters408 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parameterList410 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation412 = default(AstParserRuleReturnScope<object, IToken>);

		object QUE407_tree = default(object);
		object LPAREN409_tree = default(object);
		object RPAREN411_tree = default(object);
		RewriteRuleITokenStream stream_QUE=new RewriteRuleITokenStream(adaptor,"token QUE");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_propertyName=new RewriteRuleSubtreeStream(adaptor,"rule propertyName");
		RewriteRuleSubtreeStream stream_typeParameters=new RewriteRuleSubtreeStream(adaptor,"rule typeParameters");
		RewriteRuleSubtreeStream stream_parameterList=new RewriteRuleSubtreeStream(adaptor,"rule parameterList");
		RewriteRuleSubtreeStream stream_typeAnnotation=new RewriteRuleSubtreeStream(adaptor,"rule typeAnnotation");
		try { DebugEnterRule(GrammarFileName, "methodSignature");
		DebugLocation(1581, 4);
		try
		{
			// TypeScript.g3:1582:5: ( propertyName ( QUE )? ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? -> ^( METH_SIG propertyName ( QUE )? ( typeParameters )? ( parameterList )? ( typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1582:7: propertyName ( QUE )? ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )?
			{
			DebugLocation(1582, 7);
			PushFollow(Follow._propertyName_in_methodSignature8458);
			propertyName406=propertyName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_propertyName.Add(propertyName406.Tree);
			DebugLocation(1582, 20);
			// TypeScript.g3:1582:20: ( QUE )?
			int alt119=2;
			try { DebugEnterSubRule(119);
			try { DebugEnterDecision(119, false);
			int LA119_1 = input.LA(1);

			if ((LA119_1==QUE))
			{
				alt119 = 1;
			}
			} finally { DebugExitDecision(119); }
			switch (alt119)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1582:20: QUE
				{
				DebugLocation(1582, 20);
				QUE407=(IToken)Match(input,QUE,Follow._QUE_in_methodSignature8460); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_QUE.Add(QUE407);


				}
				break;

			}
			} finally { DebugExitSubRule(119); }

			DebugLocation(1582, 25);
			// TypeScript.g3:1582:25: ( typeParameters )?
			int alt120=2;
			try { DebugEnterSubRule(120);
			try { DebugEnterDecision(120, false);
			int LA120_1 = input.LA(1);

			if ((LA120_1==LT))
			{
				alt120 = 1;
			}
			} finally { DebugExitDecision(120); }
			switch (alt120)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1582:25: typeParameters
				{
				DebugLocation(1582, 25);
				PushFollow(Follow._typeParameters_in_methodSignature8463);
				typeParameters408=typeParameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeParameters.Add(typeParameters408.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(120); }

			DebugLocation(1582, 41);
			LPAREN409=(IToken)Match(input,LPAREN,Follow._LPAREN_in_methodSignature8466); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN409);

			DebugLocation(1582, 48);
			// TypeScript.g3:1582:48: ( parameterList )?
			int alt121=2;
			try { DebugEnterSubRule(121);
			try { DebugEnterDecision(121, false);
			int LA121_1 = input.LA(1);

			if ((LA121_1==ANY||LA121_1==CONSTRUCTOR||LA121_1==DECLARE||LA121_1==ELLIPSIS||LA121_1==FINAL||LA121_1==GET||LA121_1==Identifier||LA121_1==MODULE||LA121_1==NUMBER||LA121_1==PRIVATE||LA121_1==PROTECTED||LA121_1==PUBLIC||LA121_1==REQUIRE||LA121_1==SET||LA121_1==STRING||LA121_1==THROWS||LA121_1==TYPE))
			{
				alt121 = 1;
			}
			} finally { DebugExitDecision(121); }
			switch (alt121)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1582:48: parameterList
				{
				DebugLocation(1582, 48);
				PushFollow(Follow._parameterList_in_methodSignature8468);
				parameterList410=parameterList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterList.Add(parameterList410.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(121); }

			DebugLocation(1582, 63);
			RPAREN411=(IToken)Match(input,RPAREN,Follow._RPAREN_in_methodSignature8471); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN411);

			DebugLocation(1582, 70);
			// TypeScript.g3:1582:70: ( typeAnnotation )?
			int alt122=2;
			try { DebugEnterSubRule(122);
			try { DebugEnterDecision(122, false);
			int LA122_1 = input.LA(1);

			if ((LA122_1==COLON))
			{
				alt122 = 1;
			}
			} finally { DebugExitDecision(122); }
			switch (alt122)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1582:70: typeAnnotation
				{
				DebugLocation(1582, 70);
				PushFollow(Follow._typeAnnotation_in_methodSignature8473);
				typeAnnotation412=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation412.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(122); }



			{
			// AST REWRITE
			// elements: propertyName, QUE, typeParameters, parameterList, typeAnnotation
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1582:86: -> ^( METH_SIG propertyName ( QUE )? ( typeParameters )? ( parameterList )? ( typeAnnotation )? )
			{
				DebugLocation(1582, 89);
				// TypeScript.g3:1582:89: ^( METH_SIG propertyName ( QUE )? ( typeParameters )? ( parameterList )? ( typeAnnotation )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1582, 91);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(METH_SIG, "METH_SIG"), root_1);

				DebugLocation(1582, 100);
				adaptor.AddChild(root_1, stream_propertyName.NextTree());
				DebugLocation(1582, 113);
				// TypeScript.g3:1582:113: ( QUE )?
				if (stream_QUE.HasNext)
				{
					DebugLocation(1582, 113);
					adaptor.AddChild(root_1, stream_QUE.NextNode());

				}
				stream_QUE.Reset();
				DebugLocation(1582, 118);
				// TypeScript.g3:1582:118: ( typeParameters )?
				if (stream_typeParameters.HasNext)
				{
					DebugLocation(1582, 118);
					adaptor.AddChild(root_1, stream_typeParameters.NextTree());

				}
				stream_typeParameters.Reset();
				DebugLocation(1582, 134);
				// TypeScript.g3:1582:134: ( parameterList )?
				if (stream_parameterList.HasNext)
				{
					DebugLocation(1582, 134);
					adaptor.AddChild(root_1, stream_parameterList.NextTree());

				}
				stream_parameterList.Reset();
				DebugLocation(1582, 149);
				// TypeScript.g3:1582:149: ( typeAnnotation )?
				if (stream_typeAnnotation.HasNext)
				{
					DebugLocation(1582, 149);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

				}
				stream_typeAnnotation.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methodSignature", 111);
			LeaveRule("methodSignature", 111);
			LeaveRule_methodSignature();
		}
		DebugLocation(1583, 4);
		} finally { DebugExitRule(GrammarFileName, "methodSignature"); }
		return retval;

	}
	// $ANTLR end "methodSignature"

	partial void EnterRule_typeAliasDeclaration();
	partial void LeaveRule_typeAliasDeclaration();
	// $ANTLR start "typeAliasDeclaration"
	// TypeScript.g3:1587:1: typeAliasDeclaration : TYPE identifier EQ type semic ;
	[GrammarRule("typeAliasDeclaration")]
	private AstParserRuleReturnScope<object, IToken> typeAliasDeclaration()
	{
		EnterRule_typeAliasDeclaration();
		EnterRule("typeAliasDeclaration", 112);
		TraceIn("typeAliasDeclaration", 112);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TYPE413 = default(IToken);
		IToken EQ415 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier414 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type416 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic417 = default(AstParserRuleReturnScope<object, IToken>);

		object TYPE413_tree = default(object);
		object EQ415_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "typeAliasDeclaration");
		DebugLocation(1587, 4);
		try
		{
			// TypeScript.g3:1588:5: ( TYPE identifier EQ type semic )
			DebugEnterAlt(1);
			// TypeScript.g3:1588:7: TYPE identifier EQ type semic
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1588, 7);
			TYPE413=(IToken)Match(input,TYPE,Follow._TYPE_in_typeAliasDeclaration8513); if (state.failed) return retval;
			if (state.backtracking == 0) {
			TYPE413_tree = (object)adaptor.Create(TYPE413);
			adaptor.AddChild(root_0, TYPE413_tree);
			}
			DebugLocation(1588, 12);
			PushFollow(Follow._identifier_in_typeAliasDeclaration8515);
			identifier414=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, identifier414.Tree);
			DebugLocation(1588, 23);
			EQ415=(IToken)Match(input,EQ,Follow._EQ_in_typeAliasDeclaration8517); if (state.failed) return retval;
			if (state.backtracking == 0) {
			EQ415_tree = (object)adaptor.Create(EQ415);
			adaptor.AddChild(root_0, EQ415_tree);
			}
			DebugLocation(1588, 26);
			PushFollow(Follow._type_in_typeAliasDeclaration8519);
			type416=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, type416.Tree);
			DebugLocation(1588, 31);
			PushFollow(Follow._semic_in_typeAliasDeclaration8521);
			semic417=semic();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, semic417.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeAliasDeclaration", 112);
			LeaveRule("typeAliasDeclaration", 112);
			LeaveRule_typeAliasDeclaration();
		}
		DebugLocation(1589, 4);
		} finally { DebugExitRule(GrammarFileName, "typeAliasDeclaration"); }
		return retval;

	}
	// $ANTLR end "typeAliasDeclaration"

	partial void EnterRule_typeAnnotation();
	partial void LeaveRule_typeAnnotation();
	// $ANTLR start "typeAnnotation"
	// TypeScript.g3:1594:1: typeAnnotation : COLON type -> ^( COLON type ) ;
	[GrammarRule("typeAnnotation")]
	private AstParserRuleReturnScope<object, IToken> typeAnnotation()
	{
		EnterRule_typeAnnotation();
		EnterRule("typeAnnotation", 113);
		TraceIn("typeAnnotation", 113);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COLON418 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type419 = default(AstParserRuleReturnScope<object, IToken>);

		object COLON418_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "typeAnnotation");
		DebugLocation(1594, 4);
		try
		{
			// TypeScript.g3:1595:5: ( COLON type -> ^( COLON type ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1595:7: COLON type
			{
			DebugLocation(1595, 7);
			COLON418=(IToken)Match(input,COLON,Follow._COLON_in_typeAnnotation8541); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON418);

			DebugLocation(1595, 13);
			PushFollow(Follow._type_in_typeAnnotation8543);
			type419=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(type419.Tree);


			{
			// AST REWRITE
			// elements: COLON, type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1595:18: -> ^( COLON type )
			{
				DebugLocation(1595, 21);
				// TypeScript.g3:1595:21: ^( COLON type )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1595, 23);
				root_1 = (object)adaptor.BecomeRoot(stream_COLON.NextNode(), root_1);

				DebugLocation(1595, 29);
				adaptor.AddChild(root_1, stream_type.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeAnnotation", 113);
			LeaveRule("typeAnnotation", 113);
			LeaveRule_typeAnnotation();
		}
		DebugLocation(1596, 4);
		} finally { DebugExitRule(GrammarFileName, "typeAnnotation"); }
		return retval;

	}
	// $ANTLR end "typeAnnotation"

	partial void EnterRule_interfaceDeclaration();
	partial void LeaveRule_interfaceDeclaration();
	// $ANTLR start "interfaceDeclaration"
	// TypeScript.g3:1600:1: interfaceDeclaration : INTERFACE identifier ( typeParameters )? ( extendsClause )? LBRACE ( typeMember semic )* RBRACE -> ^( INTERFACE identifier ( typeParameters )? ( extendsClause )? ( typeMember )* ) ;
	[GrammarRule("interfaceDeclaration")]
	private AstParserRuleReturnScope<object, IToken> interfaceDeclaration()
	{
		EnterRule_interfaceDeclaration();
		EnterRule("interfaceDeclaration", 114);
		TraceIn("interfaceDeclaration", 114);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken INTERFACE420 = default(IToken);
		IToken LBRACE424 = default(IToken);
		IToken RBRACE427 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier421 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeParameters422 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> extendsClause423 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeMember425 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic426 = default(AstParserRuleReturnScope<object, IToken>);

		object INTERFACE420_tree = default(object);
		object LBRACE424_tree = default(object);
		object RBRACE427_tree = default(object);
		RewriteRuleITokenStream stream_INTERFACE=new RewriteRuleITokenStream(adaptor,"token INTERFACE");
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_typeParameters=new RewriteRuleSubtreeStream(adaptor,"rule typeParameters");
		RewriteRuleSubtreeStream stream_extendsClause=new RewriteRuleSubtreeStream(adaptor,"rule extendsClause");
		RewriteRuleSubtreeStream stream_typeMember=new RewriteRuleSubtreeStream(adaptor,"rule typeMember");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		try { DebugEnterRule(GrammarFileName, "interfaceDeclaration");
		DebugLocation(1600, 1);
		try
		{
			// TypeScript.g3:1601:2: ( INTERFACE identifier ( typeParameters )? ( extendsClause )? LBRACE ( typeMember semic )* RBRACE -> ^( INTERFACE identifier ( typeParameters )? ( extendsClause )? ( typeMember )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1601:4: INTERFACE identifier ( typeParameters )? ( extendsClause )? LBRACE ( typeMember semic )* RBRACE
			{
			DebugLocation(1601, 4);
			INTERFACE420=(IToken)Match(input,INTERFACE,Follow._INTERFACE_in_interfaceDeclaration8567); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_INTERFACE.Add(INTERFACE420);

			DebugLocation(1601, 14);
			PushFollow(Follow._identifier_in_interfaceDeclaration8569);
			identifier421=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier421.Tree);
			DebugLocation(1601, 25);
			// TypeScript.g3:1601:25: ( typeParameters )?
			int alt123=2;
			try { DebugEnterSubRule(123);
			try { DebugEnterDecision(123, false);
			int LA123_1 = input.LA(1);

			if ((LA123_1==LT))
			{
				alt123 = 1;
			}
			} finally { DebugExitDecision(123); }
			switch (alt123)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1601:25: typeParameters
				{
				DebugLocation(1601, 25);
				PushFollow(Follow._typeParameters_in_interfaceDeclaration8571);
				typeParameters422=typeParameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeParameters.Add(typeParameters422.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(123); }

			DebugLocation(1601, 41);
			// TypeScript.g3:1601:41: ( extendsClause )?
			int alt124=2;
			try { DebugEnterSubRule(124);
			try { DebugEnterDecision(124, false);
			int LA124_1 = input.LA(1);

			if ((LA124_1==EXTENDS))
			{
				alt124 = 1;
			}
			} finally { DebugExitDecision(124); }
			switch (alt124)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1601:41: extendsClause
				{
				DebugLocation(1601, 41);
				PushFollow(Follow._extendsClause_in_interfaceDeclaration8574);
				extendsClause423=extendsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_extendsClause.Add(extendsClause423.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(124); }

			DebugLocation(1601, 56);
			LBRACE424=(IToken)Match(input,LBRACE,Follow._LBRACE_in_interfaceDeclaration8577); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACE.Add(LBRACE424);

			DebugLocation(1601, 63);
			// TypeScript.g3:1601:63: ( typeMember semic )*
			try { DebugEnterSubRule(125);
			while (true)
			{
				int alt125=2;
				try { DebugEnterDecision(125, false);
				int LA125_1 = input.LA(1);

				if ((LA125_1==ANY||LA125_1==CONSTRUCTOR||LA125_1==DECLARE||LA125_1==DecimalLiteral||LA125_1==FINAL||LA125_1==GET||LA125_1==HexIntegerLiteral||LA125_1==Identifier||LA125_1==LBRACK||LA125_1==LPAREN||LA125_1==LT||LA125_1==MODULE||LA125_1==NEW||LA125_1==NUMBER||LA125_1==OctalIntegerLiteral||LA125_1==REQUIRE||LA125_1==SET||LA125_1==STRING||LA125_1==StringLiteral||LA125_1==THROWS||LA125_1==TYPE))
				{
					alt125 = 1;
				}


				} finally { DebugExitDecision(125); }
				switch ( alt125 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1601:64: typeMember semic
					{
					DebugLocation(1601, 64);
					PushFollow(Follow._typeMember_in_interfaceDeclaration8580);
					typeMember425=typeMember();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_typeMember.Add(typeMember425.Tree);
					DebugLocation(1601, 75);
					PushFollow(Follow._semic_in_interfaceDeclaration8582);
					semic426=semic();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_semic.Add(semic426.Tree);

					}
					break;

				default:
					goto loop125;
				}
			}

			loop125:
				;

			} finally { DebugExitSubRule(125); }

			DebugLocation(1601, 83);
			RBRACE427=(IToken)Match(input,RBRACE,Follow._RBRACE_in_interfaceDeclaration8586); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACE.Add(RBRACE427);



			{
			// AST REWRITE
			// elements: INTERFACE, identifier, typeParameters, extendsClause, typeMember
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1601:90: -> ^( INTERFACE identifier ( typeParameters )? ( extendsClause )? ( typeMember )* )
			{
				DebugLocation(1601, 93);
				// TypeScript.g3:1601:93: ^( INTERFACE identifier ( typeParameters )? ( extendsClause )? ( typeMember )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1601, 95);
				root_1 = (object)adaptor.BecomeRoot(stream_INTERFACE.NextNode(), root_1);

				DebugLocation(1601, 105);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(1601, 116);
				// TypeScript.g3:1601:116: ( typeParameters )?
				if (stream_typeParameters.HasNext)
				{
					DebugLocation(1601, 116);
					adaptor.AddChild(root_1, stream_typeParameters.NextTree());

				}
				stream_typeParameters.Reset();
				DebugLocation(1601, 132);
				// TypeScript.g3:1601:132: ( extendsClause )?
				if (stream_extendsClause.HasNext)
				{
					DebugLocation(1601, 132);
					adaptor.AddChild(root_1, stream_extendsClause.NextTree());

				}
				stream_extendsClause.Reset();
				DebugLocation(1601, 147);
				// TypeScript.g3:1601:147: ( typeMember )*
				while ( stream_typeMember.HasNext )
				{
					DebugLocation(1601, 147);
					adaptor.AddChild(root_1, stream_typeMember.NextTree());

				}
				stream_typeMember.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interfaceDeclaration", 114);
			LeaveRule("interfaceDeclaration", 114);
			LeaveRule_interfaceDeclaration();
		}
		DebugLocation(1602, 1);
		} finally { DebugExitRule(GrammarFileName, "interfaceDeclaration"); }
		return retval;

	}
	// $ANTLR end "interfaceDeclaration"

	partial void EnterRule_extendsClause();
	partial void LeaveRule_extendsClause();
	// $ANTLR start "extendsClause"
	// TypeScript.g3:1604:1: extendsClause : EXTENDS typeReference ( COMMA typeReference )* -> ^( EXTENDS ( typeReference )* ) ;
	[GrammarRule("extendsClause")]
	private AstParserRuleReturnScope<object, IToken> extendsClause()
	{
		EnterRule_extendsClause();
		EnterRule("extendsClause", 115);
		TraceIn("extendsClause", 115);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EXTENDS428 = default(IToken);
		IToken COMMA430 = default(IToken);
		AstParserRuleReturnScope<object, IToken> typeReference429 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeReference431 = default(AstParserRuleReturnScope<object, IToken>);

		object EXTENDS428_tree = default(object);
		object COMMA430_tree = default(object);
		RewriteRuleITokenStream stream_EXTENDS=new RewriteRuleITokenStream(adaptor,"token EXTENDS");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_typeReference=new RewriteRuleSubtreeStream(adaptor,"rule typeReference");
		try { DebugEnterRule(GrammarFileName, "extendsClause");
		DebugLocation(1604, 1);
		try
		{
			// TypeScript.g3:1605:2: ( EXTENDS typeReference ( COMMA typeReference )* -> ^( EXTENDS ( typeReference )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1605:4: EXTENDS typeReference ( COMMA typeReference )*
			{
			DebugLocation(1605, 4);
			EXTENDS428=(IToken)Match(input,EXTENDS,Follow._EXTENDS_in_extendsClause8615); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EXTENDS.Add(EXTENDS428);

			DebugLocation(1605, 12);
			PushFollow(Follow._typeReference_in_extendsClause8617);
			typeReference429=typeReference();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeReference.Add(typeReference429.Tree);
			DebugLocation(1605, 26);
			// TypeScript.g3:1605:26: ( COMMA typeReference )*
			try { DebugEnterSubRule(126);
			while (true)
			{
				int alt126=2;
				try { DebugEnterDecision(126, false);
				int LA126_1 = input.LA(1);

				if ((LA126_1==COMMA))
				{
					alt126 = 1;
				}


				} finally { DebugExitDecision(126); }
				switch ( alt126 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1605:27: COMMA typeReference
					{
					DebugLocation(1605, 27);
					COMMA430=(IToken)Match(input,COMMA,Follow._COMMA_in_extendsClause8620); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA430);

					DebugLocation(1605, 33);
					PushFollow(Follow._typeReference_in_extendsClause8622);
					typeReference431=typeReference();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_typeReference.Add(typeReference431.Tree);

					}
					break;

				default:
					goto loop126;
				}
			}

			loop126:
				;

			} finally { DebugExitSubRule(126); }



			{
			// AST REWRITE
			// elements: EXTENDS, typeReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1605:49: -> ^( EXTENDS ( typeReference )* )
			{
				DebugLocation(1605, 52);
				// TypeScript.g3:1605:52: ^( EXTENDS ( typeReference )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1605, 54);
				root_1 = (object)adaptor.BecomeRoot(stream_EXTENDS.NextNode(), root_1);

				DebugLocation(1605, 62);
				// TypeScript.g3:1605:62: ( typeReference )*
				while ( stream_typeReference.HasNext )
				{
					DebugLocation(1605, 62);
					adaptor.AddChild(root_1, stream_typeReference.NextTree());

				}
				stream_typeReference.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("extendsClause", 115);
			LeaveRule("extendsClause", 115);
			LeaveRule_extendsClause();
		}
		DebugLocation(1606, 1);
		} finally { DebugExitRule(GrammarFileName, "extendsClause"); }
		return retval;

	}
	// $ANTLR end "extendsClause"

	partial void EnterRule_classDeclaration();
	partial void LeaveRule_classDeclaration();
	// $ANTLR start "classDeclaration"
	// TypeScript.g3:1612:1: classDeclaration : CLASS identifier ( typeParameters )? ( extendsClause )? ( implementsClause )? LBRACE ( classElement )* RBRACE -> ^( CLASS identifier ( typeParameters )? ( extendsClause )? ( implementsClause )? ( classElement )* ) ;
	[GrammarRule("classDeclaration")]
	private AstParserRuleReturnScope<object, IToken> classDeclaration()
	{
		EnterRule_classDeclaration();
		EnterRule("classDeclaration", 116);
		TraceIn("classDeclaration", 116);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CLASS432 = default(IToken);
		IToken LBRACE437 = default(IToken);
		IToken RBRACE439 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier433 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeParameters434 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> extendsClause435 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> implementsClause436 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classElement438 = default(AstParserRuleReturnScope<object, IToken>);

		object CLASS432_tree = default(object);
		object LBRACE437_tree = default(object);
		object RBRACE439_tree = default(object);
		RewriteRuleITokenStream stream_CLASS=new RewriteRuleITokenStream(adaptor,"token CLASS");
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_typeParameters=new RewriteRuleSubtreeStream(adaptor,"rule typeParameters");
		RewriteRuleSubtreeStream stream_extendsClause=new RewriteRuleSubtreeStream(adaptor,"rule extendsClause");
		RewriteRuleSubtreeStream stream_implementsClause=new RewriteRuleSubtreeStream(adaptor,"rule implementsClause");
		RewriteRuleSubtreeStream stream_classElement=new RewriteRuleSubtreeStream(adaptor,"rule classElement");
		try { DebugEnterRule(GrammarFileName, "classDeclaration");
		DebugLocation(1612, 1);
		try
		{
			// TypeScript.g3:1613:2: ( CLASS identifier ( typeParameters )? ( extendsClause )? ( implementsClause )? LBRACE ( classElement )* RBRACE -> ^( CLASS identifier ( typeParameters )? ( extendsClause )? ( implementsClause )? ( classElement )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1613:4: CLASS identifier ( typeParameters )? ( extendsClause )? ( implementsClause )? LBRACE ( classElement )* RBRACE
			{
			DebugLocation(1613, 4);
			CLASS432=(IToken)Match(input,CLASS,Follow._CLASS_in_classDeclaration8648); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CLASS.Add(CLASS432);

			DebugLocation(1613, 10);
			PushFollow(Follow._identifier_in_classDeclaration8650);
			identifier433=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier433.Tree);
			DebugLocation(1613, 21);
			// TypeScript.g3:1613:21: ( typeParameters )?
			int alt127=2;
			try { DebugEnterSubRule(127);
			try { DebugEnterDecision(127, false);
			int LA127_1 = input.LA(1);

			if ((LA127_1==LT))
			{
				alt127 = 1;
			}
			} finally { DebugExitDecision(127); }
			switch (alt127)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1613:21: typeParameters
				{
				DebugLocation(1613, 21);
				PushFollow(Follow._typeParameters_in_classDeclaration8652);
				typeParameters434=typeParameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeParameters.Add(typeParameters434.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(127); }

			DebugLocation(1613, 37);
			// TypeScript.g3:1613:37: ( extendsClause )?
			int alt128=2;
			try { DebugEnterSubRule(128);
			try { DebugEnterDecision(128, false);
			int LA128_1 = input.LA(1);

			if ((LA128_1==EXTENDS))
			{
				alt128 = 1;
			}
			} finally { DebugExitDecision(128); }
			switch (alt128)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1613:37: extendsClause
				{
				DebugLocation(1613, 37);
				PushFollow(Follow._extendsClause_in_classDeclaration8655);
				extendsClause435=extendsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_extendsClause.Add(extendsClause435.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(128); }

			DebugLocation(1613, 52);
			// TypeScript.g3:1613:52: ( implementsClause )?
			int alt129=2;
			try { DebugEnterSubRule(129);
			try { DebugEnterDecision(129, false);
			int LA129_1 = input.LA(1);

			if ((LA129_1==IMPLEMENTS))
			{
				alt129 = 1;
			}
			} finally { DebugExitDecision(129); }
			switch (alt129)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1613:52: implementsClause
				{
				DebugLocation(1613, 52);
				PushFollow(Follow._implementsClause_in_classDeclaration8658);
				implementsClause436=implementsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_implementsClause.Add(implementsClause436.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(129); }

			DebugLocation(1613, 70);
			LBRACE437=(IToken)Match(input,LBRACE,Follow._LBRACE_in_classDeclaration8661); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACE.Add(LBRACE437);

			DebugLocation(1613, 77);
			// TypeScript.g3:1613:77: ( classElement )*
			try { DebugEnterSubRule(130);
			while (true)
			{
				int alt130=2;
				try { DebugEnterDecision(130, false);
				int LA130_1 = input.LA(1);

				if ((LA130_1==ANY||LA130_1==CONSTRUCTOR||LA130_1==DECLARE||LA130_1==FINAL||LA130_1==GET||LA130_1==Identifier||LA130_1==LBRACK||LA130_1==MODULE||LA130_1==NUMBER||LA130_1==PRIVATE||LA130_1==PROTECTED||LA130_1==PUBLIC||LA130_1==REQUIRE||LA130_1==SET||(LA130_1>=STATIC && LA130_1<=STRING)||LA130_1==THROWS||LA130_1==TYPE))
				{
					alt130 = 1;
				}


				} finally { DebugExitDecision(130); }
				switch ( alt130 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1613:77: classElement
					{
					DebugLocation(1613, 77);
					PushFollow(Follow._classElement_in_classDeclaration8663);
					classElement438=classElement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_classElement.Add(classElement438.Tree);

					}
					break;

				default:
					goto loop130;
				}
			}

			loop130:
				;

			} finally { DebugExitSubRule(130); }

			DebugLocation(1613, 91);
			RBRACE439=(IToken)Match(input,RBRACE,Follow._RBRACE_in_classDeclaration8666); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACE.Add(RBRACE439);



			{
			// AST REWRITE
			// elements: CLASS, identifier, typeParameters, extendsClause, implementsClause, classElement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1613:98: -> ^( CLASS identifier ( typeParameters )? ( extendsClause )? ( implementsClause )? ( classElement )* )
			{
				DebugLocation(1613, 101);
				// TypeScript.g3:1613:101: ^( CLASS identifier ( typeParameters )? ( extendsClause )? ( implementsClause )? ( classElement )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1613, 103);
				root_1 = (object)adaptor.BecomeRoot(stream_CLASS.NextNode(), root_1);

				DebugLocation(1613, 109);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(1613, 120);
				// TypeScript.g3:1613:120: ( typeParameters )?
				if (stream_typeParameters.HasNext)
				{
					DebugLocation(1613, 120);
					adaptor.AddChild(root_1, stream_typeParameters.NextTree());

				}
				stream_typeParameters.Reset();
				DebugLocation(1613, 136);
				// TypeScript.g3:1613:136: ( extendsClause )?
				if (stream_extendsClause.HasNext)
				{
					DebugLocation(1613, 136);
					adaptor.AddChild(root_1, stream_extendsClause.NextTree());

				}
				stream_extendsClause.Reset();
				DebugLocation(1613, 151);
				// TypeScript.g3:1613:151: ( implementsClause )?
				if (stream_implementsClause.HasNext)
				{
					DebugLocation(1613, 151);
					adaptor.AddChild(root_1, stream_implementsClause.NextTree());

				}
				stream_implementsClause.Reset();
				DebugLocation(1613, 169);
				// TypeScript.g3:1613:169: ( classElement )*
				while ( stream_classElement.HasNext )
				{
					DebugLocation(1613, 169);
					adaptor.AddChild(root_1, stream_classElement.NextTree());

				}
				stream_classElement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classDeclaration", 116);
			LeaveRule("classDeclaration", 116);
			LeaveRule_classDeclaration();
		}
		DebugLocation(1614, 1);
		} finally { DebugExitRule(GrammarFileName, "classDeclaration"); }
		return retval;

	}
	// $ANTLR end "classDeclaration"

	partial void EnterRule_implementsClause();
	partial void LeaveRule_implementsClause();
	// $ANTLR start "implementsClause"
	// TypeScript.g3:1616:1: implementsClause : IMPLEMENTS typeReference ( COMMA typeReference )* -> ^( IMPLEMENTS ( typeReference )* ) ;
	[GrammarRule("implementsClause")]
	private AstParserRuleReturnScope<object, IToken> implementsClause()
	{
		EnterRule_implementsClause();
		EnterRule("implementsClause", 117);
		TraceIn("implementsClause", 117);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IMPLEMENTS440 = default(IToken);
		IToken COMMA442 = default(IToken);
		AstParserRuleReturnScope<object, IToken> typeReference441 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeReference443 = default(AstParserRuleReturnScope<object, IToken>);

		object IMPLEMENTS440_tree = default(object);
		object COMMA442_tree = default(object);
		RewriteRuleITokenStream stream_IMPLEMENTS=new RewriteRuleITokenStream(adaptor,"token IMPLEMENTS");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_typeReference=new RewriteRuleSubtreeStream(adaptor,"rule typeReference");
		try { DebugEnterRule(GrammarFileName, "implementsClause");
		DebugLocation(1616, 1);
		try
		{
			// TypeScript.g3:1617:2: ( IMPLEMENTS typeReference ( COMMA typeReference )* -> ^( IMPLEMENTS ( typeReference )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1617:4: IMPLEMENTS typeReference ( COMMA typeReference )*
			{
			DebugLocation(1617, 4);
			IMPLEMENTS440=(IToken)Match(input,IMPLEMENTS,Follow._IMPLEMENTS_in_implementsClause8699); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IMPLEMENTS.Add(IMPLEMENTS440);

			DebugLocation(1617, 15);
			PushFollow(Follow._typeReference_in_implementsClause8701);
			typeReference441=typeReference();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeReference.Add(typeReference441.Tree);
			DebugLocation(1617, 29);
			// TypeScript.g3:1617:29: ( COMMA typeReference )*
			try { DebugEnterSubRule(131);
			while (true)
			{
				int alt131=2;
				try { DebugEnterDecision(131, false);
				int LA131_1 = input.LA(1);

				if ((LA131_1==COMMA))
				{
					alt131 = 1;
				}


				} finally { DebugExitDecision(131); }
				switch ( alt131 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1617:30: COMMA typeReference
					{
					DebugLocation(1617, 30);
					COMMA442=(IToken)Match(input,COMMA,Follow._COMMA_in_implementsClause8704); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA442);

					DebugLocation(1617, 36);
					PushFollow(Follow._typeReference_in_implementsClause8706);
					typeReference443=typeReference();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_typeReference.Add(typeReference443.Tree);

					}
					break;

				default:
					goto loop131;
				}
			}

			loop131:
				;

			} finally { DebugExitSubRule(131); }



			{
			// AST REWRITE
			// elements: IMPLEMENTS, typeReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1617:52: -> ^( IMPLEMENTS ( typeReference )* )
			{
				DebugLocation(1617, 55);
				// TypeScript.g3:1617:55: ^( IMPLEMENTS ( typeReference )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1617, 57);
				root_1 = (object)adaptor.BecomeRoot(stream_IMPLEMENTS.NextNode(), root_1);

				DebugLocation(1617, 68);
				// TypeScript.g3:1617:68: ( typeReference )*
				while ( stream_typeReference.HasNext )
				{
					DebugLocation(1617, 68);
					adaptor.AddChild(root_1, stream_typeReference.NextTree());

				}
				stream_typeReference.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("implementsClause", 117);
			LeaveRule("implementsClause", 117);
			LeaveRule_implementsClause();
		}
		DebugLocation(1618, 1);
		} finally { DebugExitRule(GrammarFileName, "implementsClause"); }
		return retval;

	}
	// $ANTLR end "implementsClause"

	partial void EnterRule_classElement();
	partial void LeaveRule_classElement();
	// $ANTLR start "classElement"
	// TypeScript.g3:1620:1: classElement options {k=4; } : ( getAccessor | setAccessor | constructorDeclaration | memberVariableDeclaration | memberFunctionDeclaration | indexSignature semic -> indexSignature );
	[GrammarRule("classElement")]
	private AstParserRuleReturnScope<object, IToken> classElement()
	{
		EnterRule_classElement();
		EnterRule("classElement", 118);
		TraceIn("classElement", 118);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> getAccessor444 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> setAccessor445 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> constructorDeclaration446 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> memberVariableDeclaration447 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> memberFunctionDeclaration448 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> indexSignature449 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic450 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_indexSignature=new RewriteRuleSubtreeStream(adaptor,"rule indexSignature");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		try { DebugEnterRule(GrammarFileName, "classElement");
		DebugLocation(1620, 1);
		try
		{
			// TypeScript.g3:1625:2: ( getAccessor | setAccessor | constructorDeclaration | memberVariableDeclaration | memberFunctionDeclaration | indexSignature semic -> indexSignature )
			int alt132=6;
			try { DebugEnterDecision(132, false);
			try
			{
				alt132 = dfa132.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(132); }
			switch (alt132)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1625:4: getAccessor
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1625, 4);
				PushFollow(Follow._getAccessor_in_classElement8742);
				getAccessor444=getAccessor();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, getAccessor444.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1626:11: setAccessor
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1626, 11);
				PushFollow(Follow._setAccessor_in_classElement8755);
				setAccessor445=setAccessor();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, setAccessor445.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:1627:4: constructorDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1627, 4);
				PushFollow(Follow._constructorDeclaration_in_classElement8760);
				constructorDeclaration446=constructorDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constructorDeclaration446.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:1628:4: memberVariableDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1628, 4);
				PushFollow(Follow._memberVariableDeclaration_in_classElement8766);
				memberVariableDeclaration447=memberVariableDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, memberVariableDeclaration447.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:1629:4: memberFunctionDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1629, 4);
				PushFollow(Follow._memberFunctionDeclaration_in_classElement8772);
				memberFunctionDeclaration448=memberFunctionDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, memberFunctionDeclaration448.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScript.g3:1630:4: indexSignature semic
				{
				DebugLocation(1630, 4);
				PushFollow(Follow._indexSignature_in_classElement8778);
				indexSignature449=indexSignature();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_indexSignature.Add(indexSignature449.Tree);
				DebugLocation(1630, 19);
				PushFollow(Follow._semic_in_classElement8780);
				semic450=semic();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_semic.Add(semic450.Tree);


				{
				// AST REWRITE
				// elements: indexSignature
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1630:25: -> indexSignature
				{
					DebugLocation(1630, 28);
					adaptor.AddChild(root_0, stream_indexSignature.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classElement", 118);
			LeaveRule("classElement", 118);
			LeaveRule_classElement();
		}
		DebugLocation(1631, 1);
		} finally { DebugExitRule(GrammarFileName, "classElement"); }
		return retval;

	}
	// $ANTLR end "classElement"

	partial void EnterRule_constructorDeclaration();
	partial void LeaveRule_constructorDeclaration();
	// $ANTLR start "constructorDeclaration"
	// TypeScript.g3:1633:1: constructorDeclaration : constructorCallSignature ( semic constructorCallSignature )* functionBody -> ^( CONST_DECL ( constructorCallSignature )* functionBody ) ;
	[GrammarRule("constructorDeclaration")]
	private AstParserRuleReturnScope<object, IToken> constructorDeclaration()
	{
		EnterRule_constructorDeclaration();
		EnterRule("constructorDeclaration", 119);
		TraceIn("constructorDeclaration", 119);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> constructorCallSignature451 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic452 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> constructorCallSignature453 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionBody454 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_constructorCallSignature=new RewriteRuleSubtreeStream(adaptor,"rule constructorCallSignature");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		RewriteRuleSubtreeStream stream_functionBody=new RewriteRuleSubtreeStream(adaptor,"rule functionBody");
		try { DebugEnterRule(GrammarFileName, "constructorDeclaration");
		DebugLocation(1633, 1);
		try
		{
			// TypeScript.g3:1634:2: ( constructorCallSignature ( semic constructorCallSignature )* functionBody -> ^( CONST_DECL ( constructorCallSignature )* functionBody ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1634:4: constructorCallSignature ( semic constructorCallSignature )* functionBody
			{
			DebugLocation(1634, 4);
			PushFollow(Follow._constructorCallSignature_in_constructorDeclaration8797);
			constructorCallSignature451=constructorCallSignature();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_constructorCallSignature.Add(constructorCallSignature451.Tree);
			DebugLocation(1634, 29);
			// TypeScript.g3:1634:29: ( semic constructorCallSignature )*
			try { DebugEnterSubRule(133);
			while (true)
			{
				int alt133=2;
				try { DebugEnterDecision(133, false);
				int LA133_1 = input.LA(1);

				if ((LA133_1==EOF||LA133_1==EOL||LA133_1==MultiLineComment||LA133_1==RBRACE||LA133_1==SEMIC))
				{
					alt133 = 1;
				}


				} finally { DebugExitDecision(133); }
				switch ( alt133 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1634:30: semic constructorCallSignature
					{
					DebugLocation(1634, 30);
					PushFollow(Follow._semic_in_constructorDeclaration8800);
					semic452=semic();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_semic.Add(semic452.Tree);
					DebugLocation(1634, 36);
					PushFollow(Follow._constructorCallSignature_in_constructorDeclaration8802);
					constructorCallSignature453=constructorCallSignature();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_constructorCallSignature.Add(constructorCallSignature453.Tree);

					}
					break;

				default:
					goto loop133;
				}
			}

			loop133:
				;

			} finally { DebugExitSubRule(133); }

			DebugLocation(1634, 63);
			PushFollow(Follow._functionBody_in_constructorDeclaration8806);
			functionBody454=functionBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functionBody.Add(functionBody454.Tree);


			{
			// AST REWRITE
			// elements: constructorCallSignature, functionBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1634:76: -> ^( CONST_DECL ( constructorCallSignature )* functionBody )
			{
				DebugLocation(1634, 79);
				// TypeScript.g3:1634:79: ^( CONST_DECL ( constructorCallSignature )* functionBody )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1634, 81);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CONST_DECL, "CONST_DECL"), root_1);

				DebugLocation(1634, 92);
				// TypeScript.g3:1634:92: ( constructorCallSignature )*
				while ( stream_constructorCallSignature.HasNext )
				{
					DebugLocation(1634, 92);
					adaptor.AddChild(root_1, stream_constructorCallSignature.NextTree());

				}
				stream_constructorCallSignature.Reset();
				DebugLocation(1634, 118);
				adaptor.AddChild(root_1, stream_functionBody.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constructorDeclaration", 119);
			LeaveRule("constructorDeclaration", 119);
			LeaveRule_constructorDeclaration();
		}
		DebugLocation(1635, 1);
		} finally { DebugExitRule(GrammarFileName, "constructorDeclaration"); }
		return retval;

	}
	// $ANTLR end "constructorDeclaration"

	partial void EnterRule_constructorCallSignature();
	partial void LeaveRule_constructorCallSignature();
	// $ANTLR start "constructorCallSignature"
	// TypeScript.g3:1637:1: constructorCallSignature : ( accessibilityModifier )? CONSTRUCTOR LPAREN ( parameterList )? RPAREN -> ^( CONST_SIG ( accessibilityModifier )? ( parameterList )? ) ;
	[GrammarRule("constructorCallSignature")]
	private AstParserRuleReturnScope<object, IToken> constructorCallSignature()
	{
		EnterRule_constructorCallSignature();
		EnterRule("constructorCallSignature", 120);
		TraceIn("constructorCallSignature", 120);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CONSTRUCTOR456 = default(IToken);
		IToken LPAREN457 = default(IToken);
		IToken RPAREN459 = default(IToken);
		AstParserRuleReturnScope<object, IToken> accessibilityModifier455 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parameterList458 = default(AstParserRuleReturnScope<object, IToken>);

		object CONSTRUCTOR456_tree = default(object);
		object LPAREN457_tree = default(object);
		object RPAREN459_tree = default(object);
		RewriteRuleITokenStream stream_CONSTRUCTOR=new RewriteRuleITokenStream(adaptor,"token CONSTRUCTOR");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_accessibilityModifier=new RewriteRuleSubtreeStream(adaptor,"rule accessibilityModifier");
		RewriteRuleSubtreeStream stream_parameterList=new RewriteRuleSubtreeStream(adaptor,"rule parameterList");
		try { DebugEnterRule(GrammarFileName, "constructorCallSignature");
		DebugLocation(1637, 1);
		try
		{
			// TypeScript.g3:1638:2: ( ( accessibilityModifier )? CONSTRUCTOR LPAREN ( parameterList )? RPAREN -> ^( CONST_SIG ( accessibilityModifier )? ( parameterList )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1638:4: ( accessibilityModifier )? CONSTRUCTOR LPAREN ( parameterList )? RPAREN
			{
			DebugLocation(1638, 4);
			// TypeScript.g3:1638:4: ( accessibilityModifier )?
			int alt134=2;
			try { DebugEnterSubRule(134);
			try { DebugEnterDecision(134, false);
			int LA134_1 = input.LA(1);

			if ((LA134_1==PRIVATE||LA134_1==PROTECTED||LA134_1==PUBLIC))
			{
				alt134 = 1;
			}
			} finally { DebugExitDecision(134); }
			switch (alt134)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1638:4: accessibilityModifier
				{
				DebugLocation(1638, 4);
				PushFollow(Follow._accessibilityModifier_in_constructorCallSignature8829);
				accessibilityModifier455=accessibilityModifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_accessibilityModifier.Add(accessibilityModifier455.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(134); }

			DebugLocation(1638, 27);
			CONSTRUCTOR456=(IToken)Match(input,CONSTRUCTOR,Follow._CONSTRUCTOR_in_constructorCallSignature8832); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CONSTRUCTOR.Add(CONSTRUCTOR456);

			DebugLocation(1638, 39);
			LPAREN457=(IToken)Match(input,LPAREN,Follow._LPAREN_in_constructorCallSignature8834); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN457);

			DebugLocation(1638, 46);
			// TypeScript.g3:1638:46: ( parameterList )?
			int alt135=2;
			try { DebugEnterSubRule(135);
			try { DebugEnterDecision(135, false);
			int LA135_1 = input.LA(1);

			if ((LA135_1==ANY||LA135_1==CONSTRUCTOR||LA135_1==DECLARE||LA135_1==ELLIPSIS||LA135_1==FINAL||LA135_1==GET||LA135_1==Identifier||LA135_1==MODULE||LA135_1==NUMBER||LA135_1==PRIVATE||LA135_1==PROTECTED||LA135_1==PUBLIC||LA135_1==REQUIRE||LA135_1==SET||LA135_1==STRING||LA135_1==THROWS||LA135_1==TYPE))
			{
				alt135 = 1;
			}
			} finally { DebugExitDecision(135); }
			switch (alt135)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1638:46: parameterList
				{
				DebugLocation(1638, 46);
				PushFollow(Follow._parameterList_in_constructorCallSignature8836);
				parameterList458=parameterList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterList.Add(parameterList458.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(135); }

			DebugLocation(1638, 61);
			RPAREN459=(IToken)Match(input,RPAREN,Follow._RPAREN_in_constructorCallSignature8839); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN459);



			{
			// AST REWRITE
			// elements: accessibilityModifier, parameterList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1638:68: -> ^( CONST_SIG ( accessibilityModifier )? ( parameterList )? )
			{
				DebugLocation(1638, 71);
				// TypeScript.g3:1638:71: ^( CONST_SIG ( accessibilityModifier )? ( parameterList )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1638, 73);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CONST_SIG, "CONST_SIG"), root_1);

				DebugLocation(1638, 83);
				// TypeScript.g3:1638:83: ( accessibilityModifier )?
				if (stream_accessibilityModifier.HasNext)
				{
					DebugLocation(1638, 83);
					adaptor.AddChild(root_1, stream_accessibilityModifier.NextTree());

				}
				stream_accessibilityModifier.Reset();
				DebugLocation(1638, 106);
				// TypeScript.g3:1638:106: ( parameterList )?
				if (stream_parameterList.HasNext)
				{
					DebugLocation(1638, 106);
					adaptor.AddChild(root_1, stream_parameterList.NextTree());

				}
				stream_parameterList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constructorCallSignature", 120);
			LeaveRule("constructorCallSignature", 120);
			LeaveRule_constructorCallSignature();
		}
		DebugLocation(1639, 1);
		} finally { DebugExitRule(GrammarFileName, "constructorCallSignature"); }
		return retval;

	}
	// $ANTLR end "constructorCallSignature"

	partial void EnterRule_memberVariableDeclaration();
	partial void LeaveRule_memberVariableDeclaration();
	// $ANTLR start "memberVariableDeclaration"
	// TypeScript.g3:1641:1: memberVariableDeclaration : ( accessibilityModifier )? ( STATIC )? variableDeclaration semic -> ^( VAR ( accessibilityModifier )? ( STATIC )? variableDeclaration ) ;
	[GrammarRule("memberVariableDeclaration")]
	private AstParserRuleReturnScope<object, IToken> memberVariableDeclaration()
	{
		EnterRule_memberVariableDeclaration();
		EnterRule("memberVariableDeclaration", 121);
		TraceIn("memberVariableDeclaration", 121);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken STATIC461 = default(IToken);
		AstParserRuleReturnScope<object, IToken> accessibilityModifier460 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableDeclaration462 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic463 = default(AstParserRuleReturnScope<object, IToken>);

		object STATIC461_tree = default(object);
		RewriteRuleITokenStream stream_STATIC=new RewriteRuleITokenStream(adaptor,"token STATIC");
		RewriteRuleSubtreeStream stream_accessibilityModifier=new RewriteRuleSubtreeStream(adaptor,"rule accessibilityModifier");
		RewriteRuleSubtreeStream stream_variableDeclaration=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclaration");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		try { DebugEnterRule(GrammarFileName, "memberVariableDeclaration");
		DebugLocation(1641, 1);
		try
		{
			// TypeScript.g3:1642:9: ( ( accessibilityModifier )? ( STATIC )? variableDeclaration semic -> ^( VAR ( accessibilityModifier )? ( STATIC )? variableDeclaration ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1642:11: ( accessibilityModifier )? ( STATIC )? variableDeclaration semic
			{
			DebugLocation(1642, 11);
			// TypeScript.g3:1642:11: ( accessibilityModifier )?
			int alt136=2;
			try { DebugEnterSubRule(136);
			try { DebugEnterDecision(136, false);
			int LA136_1 = input.LA(1);

			if ((LA136_1==PRIVATE||LA136_1==PROTECTED||LA136_1==PUBLIC))
			{
				alt136 = 1;
			}
			} finally { DebugExitDecision(136); }
			switch (alt136)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1642:11: accessibilityModifier
				{
				DebugLocation(1642, 11);
				PushFollow(Follow._accessibilityModifier_in_memberVariableDeclaration8870);
				accessibilityModifier460=accessibilityModifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_accessibilityModifier.Add(accessibilityModifier460.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(136); }

			DebugLocation(1642, 34);
			// TypeScript.g3:1642:34: ( STATIC )?
			int alt137=2;
			try { DebugEnterSubRule(137);
			try { DebugEnterDecision(137, false);
			int LA137_1 = input.LA(1);

			if ((LA137_1==STATIC))
			{
				alt137 = 1;
			}
			} finally { DebugExitDecision(137); }
			switch (alt137)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1642:34: STATIC
				{
				DebugLocation(1642, 34);
				STATIC461=(IToken)Match(input,STATIC,Follow._STATIC_in_memberVariableDeclaration8873); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STATIC.Add(STATIC461);


				}
				break;

			}
			} finally { DebugExitSubRule(137); }

			DebugLocation(1642, 42);
			PushFollow(Follow._variableDeclaration_in_memberVariableDeclaration8876);
			variableDeclaration462=variableDeclaration();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclaration.Add(variableDeclaration462.Tree);
			DebugLocation(1642, 62);
			PushFollow(Follow._semic_in_memberVariableDeclaration8878);
			semic463=semic();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semic.Add(semic463.Tree);


			{
			// AST REWRITE
			// elements: accessibilityModifier, STATIC, variableDeclaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1643:2: -> ^( VAR ( accessibilityModifier )? ( STATIC )? variableDeclaration )
			{
				DebugLocation(1643, 5);
				// TypeScript.g3:1643:5: ^( VAR ( accessibilityModifier )? ( STATIC )? variableDeclaration )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1643, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, "VAR"), root_1);

				DebugLocation(1643, 12);
				// TypeScript.g3:1643:12: ( accessibilityModifier )?
				if (stream_accessibilityModifier.HasNext)
				{
					DebugLocation(1643, 12);
					adaptor.AddChild(root_1, stream_accessibilityModifier.NextTree());

				}
				stream_accessibilityModifier.Reset();
				DebugLocation(1643, 35);
				// TypeScript.g3:1643:35: ( STATIC )?
				if (stream_STATIC.HasNext)
				{
					DebugLocation(1643, 35);
					adaptor.AddChild(root_1, stream_STATIC.NextNode());

				}
				stream_STATIC.Reset();
				DebugLocation(1643, 43);
				adaptor.AddChild(root_1, stream_variableDeclaration.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("memberVariableDeclaration", 121);
			LeaveRule("memberVariableDeclaration", 121);
			LeaveRule_memberVariableDeclaration();
		}
		DebugLocation(1644, 1);
		} finally { DebugExitRule(GrammarFileName, "memberVariableDeclaration"); }
		return retval;

	}
	// $ANTLR end "memberVariableDeclaration"

	partial void EnterRule_memberFunctionDeclaration();
	partial void LeaveRule_memberFunctionDeclaration();
	// $ANTLR start "memberFunctionDeclaration"
	// TypeScript.g3:1646:1: memberFunctionDeclaration : memberFunctionCallSignature ( semic memberFunctionCallSignature )* functionBody -> ^( METH_DECL ( memberFunctionCallSignature )* functionBody ) ;
	[GrammarRule("memberFunctionDeclaration")]
	private AstParserRuleReturnScope<object, IToken> memberFunctionDeclaration()
	{
		EnterRule_memberFunctionDeclaration();
		EnterRule("memberFunctionDeclaration", 122);
		TraceIn("memberFunctionDeclaration", 122);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> memberFunctionCallSignature464 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic465 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> memberFunctionCallSignature466 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionBody467 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_memberFunctionCallSignature=new RewriteRuleSubtreeStream(adaptor,"rule memberFunctionCallSignature");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		RewriteRuleSubtreeStream stream_functionBody=new RewriteRuleSubtreeStream(adaptor,"rule functionBody");
		try { DebugEnterRule(GrammarFileName, "memberFunctionDeclaration");
		DebugLocation(1646, 1);
		try
		{
			// TypeScript.g3:1647:2: ( memberFunctionCallSignature ( semic memberFunctionCallSignature )* functionBody -> ^( METH_DECL ( memberFunctionCallSignature )* functionBody ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1647:4: memberFunctionCallSignature ( semic memberFunctionCallSignature )* functionBody
			{
			DebugLocation(1647, 4);
			PushFollow(Follow._memberFunctionCallSignature_in_memberFunctionDeclaration8908);
			memberFunctionCallSignature464=memberFunctionCallSignature();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_memberFunctionCallSignature.Add(memberFunctionCallSignature464.Tree);
			DebugLocation(1647, 32);
			// TypeScript.g3:1647:32: ( semic memberFunctionCallSignature )*
			try { DebugEnterSubRule(138);
			while (true)
			{
				int alt138=2;
				try { DebugEnterDecision(138, false);
				int LA138_1 = input.LA(1);

				if ((LA138_1==EOF||LA138_1==EOL||LA138_1==MultiLineComment||LA138_1==RBRACE||LA138_1==SEMIC))
				{
					alt138 = 1;
				}


				} finally { DebugExitDecision(138); }
				switch ( alt138 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1647:33: semic memberFunctionCallSignature
					{
					DebugLocation(1647, 33);
					PushFollow(Follow._semic_in_memberFunctionDeclaration8911);
					semic465=semic();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_semic.Add(semic465.Tree);
					DebugLocation(1647, 39);
					PushFollow(Follow._memberFunctionCallSignature_in_memberFunctionDeclaration8913);
					memberFunctionCallSignature466=memberFunctionCallSignature();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_memberFunctionCallSignature.Add(memberFunctionCallSignature466.Tree);

					}
					break;

				default:
					goto loop138;
				}
			}

			loop138:
				;

			} finally { DebugExitSubRule(138); }

			DebugLocation(1647, 69);
			PushFollow(Follow._functionBody_in_memberFunctionDeclaration8917);
			functionBody467=functionBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functionBody.Add(functionBody467.Tree);


			{
			// AST REWRITE
			// elements: memberFunctionCallSignature, functionBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1647:82: -> ^( METH_DECL ( memberFunctionCallSignature )* functionBody )
			{
				DebugLocation(1647, 85);
				// TypeScript.g3:1647:85: ^( METH_DECL ( memberFunctionCallSignature )* functionBody )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1647, 87);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(METH_DECL, "METH_DECL"), root_1);

				DebugLocation(1647, 97);
				// TypeScript.g3:1647:97: ( memberFunctionCallSignature )*
				while ( stream_memberFunctionCallSignature.HasNext )
				{
					DebugLocation(1647, 97);
					adaptor.AddChild(root_1, stream_memberFunctionCallSignature.NextTree());

				}
				stream_memberFunctionCallSignature.Reset();
				DebugLocation(1647, 126);
				adaptor.AddChild(root_1, stream_functionBody.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("memberFunctionDeclaration", 122);
			LeaveRule("memberFunctionDeclaration", 122);
			LeaveRule_memberFunctionDeclaration();
		}
		DebugLocation(1648, 1);
		} finally { DebugExitRule(GrammarFileName, "memberFunctionDeclaration"); }
		return retval;

	}
	// $ANTLR end "memberFunctionDeclaration"

	partial void EnterRule_memberFunctionCallSignature();
	partial void LeaveRule_memberFunctionCallSignature();
	// $ANTLR start "memberFunctionCallSignature"
	// TypeScript.g3:1650:1: memberFunctionCallSignature : ( accessibilityModifier )? ( STATIC )? identifier ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? -> ^( METH_SIG ( accessibilityModifier )? ( STATIC )? identifier ( typeParameters )? ( parameterList )? ( typeAnnotation )? ) ;
	[GrammarRule("memberFunctionCallSignature")]
	private AstParserRuleReturnScope<object, IToken> memberFunctionCallSignature()
	{
		EnterRule_memberFunctionCallSignature();
		EnterRule("memberFunctionCallSignature", 123);
		TraceIn("memberFunctionCallSignature", 123);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken STATIC469 = default(IToken);
		IToken LPAREN472 = default(IToken);
		IToken RPAREN474 = default(IToken);
		AstParserRuleReturnScope<object, IToken> accessibilityModifier468 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> identifier470 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeParameters471 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parameterList473 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation475 = default(AstParserRuleReturnScope<object, IToken>);

		object STATIC469_tree = default(object);
		object LPAREN472_tree = default(object);
		object RPAREN474_tree = default(object);
		RewriteRuleITokenStream stream_STATIC=new RewriteRuleITokenStream(adaptor,"token STATIC");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_accessibilityModifier=new RewriteRuleSubtreeStream(adaptor,"rule accessibilityModifier");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_typeParameters=new RewriteRuleSubtreeStream(adaptor,"rule typeParameters");
		RewriteRuleSubtreeStream stream_parameterList=new RewriteRuleSubtreeStream(adaptor,"rule parameterList");
		RewriteRuleSubtreeStream stream_typeAnnotation=new RewriteRuleSubtreeStream(adaptor,"rule typeAnnotation");
		try { DebugEnterRule(GrammarFileName, "memberFunctionCallSignature");
		DebugLocation(1650, 1);
		try
		{
			// TypeScript.g3:1651:2: ( ( accessibilityModifier )? ( STATIC )? identifier ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? -> ^( METH_SIG ( accessibilityModifier )? ( STATIC )? identifier ( typeParameters )? ( parameterList )? ( typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1651:4: ( accessibilityModifier )? ( STATIC )? identifier ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )?
			{
			DebugLocation(1651, 4);
			// TypeScript.g3:1651:4: ( accessibilityModifier )?
			int alt139=2;
			try { DebugEnterSubRule(139);
			try { DebugEnterDecision(139, false);
			int LA139_1 = input.LA(1);

			if ((LA139_1==PRIVATE||LA139_1==PROTECTED||LA139_1==PUBLIC))
			{
				alt139 = 1;
			}
			} finally { DebugExitDecision(139); }
			switch (alt139)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1651:4: accessibilityModifier
				{
				DebugLocation(1651, 4);
				PushFollow(Follow._accessibilityModifier_in_memberFunctionCallSignature8940);
				accessibilityModifier468=accessibilityModifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_accessibilityModifier.Add(accessibilityModifier468.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(139); }

			DebugLocation(1651, 27);
			// TypeScript.g3:1651:27: ( STATIC )?
			int alt140=2;
			try { DebugEnterSubRule(140);
			try { DebugEnterDecision(140, false);
			int LA140_1 = input.LA(1);

			if ((LA140_1==STATIC))
			{
				alt140 = 1;
			}
			} finally { DebugExitDecision(140); }
			switch (alt140)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1651:27: STATIC
				{
				DebugLocation(1651, 27);
				STATIC469=(IToken)Match(input,STATIC,Follow._STATIC_in_memberFunctionCallSignature8943); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STATIC.Add(STATIC469);


				}
				break;

			}
			} finally { DebugExitSubRule(140); }

			DebugLocation(1651, 35);
			PushFollow(Follow._identifier_in_memberFunctionCallSignature8946);
			identifier470=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier470.Tree);
			DebugLocation(1651, 46);
			// TypeScript.g3:1651:46: ( typeParameters )?
			int alt141=2;
			try { DebugEnterSubRule(141);
			try { DebugEnterDecision(141, false);
			int LA141_1 = input.LA(1);

			if ((LA141_1==LT))
			{
				alt141 = 1;
			}
			} finally { DebugExitDecision(141); }
			switch (alt141)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1651:46: typeParameters
				{
				DebugLocation(1651, 46);
				PushFollow(Follow._typeParameters_in_memberFunctionCallSignature8948);
				typeParameters471=typeParameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeParameters.Add(typeParameters471.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(141); }

			DebugLocation(1651, 62);
			LPAREN472=(IToken)Match(input,LPAREN,Follow._LPAREN_in_memberFunctionCallSignature8951); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN472);

			DebugLocation(1651, 69);
			// TypeScript.g3:1651:69: ( parameterList )?
			int alt142=2;
			try { DebugEnterSubRule(142);
			try { DebugEnterDecision(142, false);
			int LA142_1 = input.LA(1);

			if ((LA142_1==ANY||LA142_1==CONSTRUCTOR||LA142_1==DECLARE||LA142_1==ELLIPSIS||LA142_1==FINAL||LA142_1==GET||LA142_1==Identifier||LA142_1==MODULE||LA142_1==NUMBER||LA142_1==PRIVATE||LA142_1==PROTECTED||LA142_1==PUBLIC||LA142_1==REQUIRE||LA142_1==SET||LA142_1==STRING||LA142_1==THROWS||LA142_1==TYPE))
			{
				alt142 = 1;
			}
			} finally { DebugExitDecision(142); }
			switch (alt142)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1651:69: parameterList
				{
				DebugLocation(1651, 69);
				PushFollow(Follow._parameterList_in_memberFunctionCallSignature8953);
				parameterList473=parameterList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterList.Add(parameterList473.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(142); }

			DebugLocation(1651, 84);
			RPAREN474=(IToken)Match(input,RPAREN,Follow._RPAREN_in_memberFunctionCallSignature8956); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN474);

			DebugLocation(1651, 91);
			// TypeScript.g3:1651:91: ( typeAnnotation )?
			int alt143=2;
			try { DebugEnterSubRule(143);
			try { DebugEnterDecision(143, false);
			int LA143_1 = input.LA(1);

			if ((LA143_1==COLON))
			{
				alt143 = 1;
			}
			} finally { DebugExitDecision(143); }
			switch (alt143)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1651:91: typeAnnotation
				{
				DebugLocation(1651, 91);
				PushFollow(Follow._typeAnnotation_in_memberFunctionCallSignature8958);
				typeAnnotation475=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation475.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(143); }



			{
			// AST REWRITE
			// elements: accessibilityModifier, STATIC, identifier, typeParameters, parameterList, typeAnnotation
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1651:107: -> ^( METH_SIG ( accessibilityModifier )? ( STATIC )? identifier ( typeParameters )? ( parameterList )? ( typeAnnotation )? )
			{
				DebugLocation(1651, 110);
				// TypeScript.g3:1651:110: ^( METH_SIG ( accessibilityModifier )? ( STATIC )? identifier ( typeParameters )? ( parameterList )? ( typeAnnotation )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1651, 112);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(METH_SIG, "METH_SIG"), root_1);

				DebugLocation(1651, 121);
				// TypeScript.g3:1651:121: ( accessibilityModifier )?
				if (stream_accessibilityModifier.HasNext)
				{
					DebugLocation(1651, 121);
					adaptor.AddChild(root_1, stream_accessibilityModifier.NextTree());

				}
				stream_accessibilityModifier.Reset();
				DebugLocation(1651, 144);
				// TypeScript.g3:1651:144: ( STATIC )?
				if (stream_STATIC.HasNext)
				{
					DebugLocation(1651, 144);
					adaptor.AddChild(root_1, stream_STATIC.NextNode());

				}
				stream_STATIC.Reset();
				DebugLocation(1651, 152);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(1651, 163);
				// TypeScript.g3:1651:163: ( typeParameters )?
				if (stream_typeParameters.HasNext)
				{
					DebugLocation(1651, 163);
					adaptor.AddChild(root_1, stream_typeParameters.NextTree());

				}
				stream_typeParameters.Reset();
				DebugLocation(1651, 179);
				// TypeScript.g3:1651:179: ( parameterList )?
				if (stream_parameterList.HasNext)
				{
					DebugLocation(1651, 179);
					adaptor.AddChild(root_1, stream_parameterList.NextTree());

				}
				stream_parameterList.Reset();
				DebugLocation(1651, 194);
				// TypeScript.g3:1651:194: ( typeAnnotation )?
				if (stream_typeAnnotation.HasNext)
				{
					DebugLocation(1651, 194);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

				}
				stream_typeAnnotation.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("memberFunctionCallSignature", 123);
			LeaveRule("memberFunctionCallSignature", 123);
			LeaveRule_memberFunctionCallSignature();
		}
		DebugLocation(1652, 1);
		} finally { DebugExitRule(GrammarFileName, "memberFunctionCallSignature"); }
		return retval;

	}
	// $ANTLR end "memberFunctionCallSignature"

	partial void EnterRule_getAccessor();
	partial void LeaveRule_getAccessor();
	// $ANTLR start "getAccessor"
	// TypeScript.g3:1654:1: getAccessor : ( accessibilityModifier )? ( STATIC )? GET identifier LPAREN RPAREN ( typeAnnotation )? functionBody -> ^( GET ( accessibilityModifier )? ( STATIC )? identifier ( typeAnnotation )? functionBody ) ;
	[GrammarRule("getAccessor")]
	private AstParserRuleReturnScope<object, IToken> getAccessor()
	{
		EnterRule_getAccessor();
		EnterRule("getAccessor", 124);
		TraceIn("getAccessor", 124);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken STATIC477 = default(IToken);
		IToken GET478 = default(IToken);
		IToken LPAREN480 = default(IToken);
		IToken RPAREN481 = default(IToken);
		AstParserRuleReturnScope<object, IToken> accessibilityModifier476 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> identifier479 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation482 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionBody483 = default(AstParserRuleReturnScope<object, IToken>);

		object STATIC477_tree = default(object);
		object GET478_tree = default(object);
		object LPAREN480_tree = default(object);
		object RPAREN481_tree = default(object);
		RewriteRuleITokenStream stream_STATIC=new RewriteRuleITokenStream(adaptor,"token STATIC");
		RewriteRuleITokenStream stream_GET=new RewriteRuleITokenStream(adaptor,"token GET");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_accessibilityModifier=new RewriteRuleSubtreeStream(adaptor,"rule accessibilityModifier");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_typeAnnotation=new RewriteRuleSubtreeStream(adaptor,"rule typeAnnotation");
		RewriteRuleSubtreeStream stream_functionBody=new RewriteRuleSubtreeStream(adaptor,"rule functionBody");
		try { DebugEnterRule(GrammarFileName, "getAccessor");
		DebugLocation(1654, 1);
		try
		{
			// TypeScript.g3:1655:2: ( ( accessibilityModifier )? ( STATIC )? GET identifier LPAREN RPAREN ( typeAnnotation )? functionBody -> ^( GET ( accessibilityModifier )? ( STATIC )? identifier ( typeAnnotation )? functionBody ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1655:4: ( accessibilityModifier )? ( STATIC )? GET identifier LPAREN RPAREN ( typeAnnotation )? functionBody
			{
			DebugLocation(1655, 4);
			// TypeScript.g3:1655:4: ( accessibilityModifier )?
			int alt144=2;
			try { DebugEnterSubRule(144);
			try { DebugEnterDecision(144, false);
			int LA144_1 = input.LA(1);

			if ((LA144_1==PRIVATE||LA144_1==PROTECTED||LA144_1==PUBLIC))
			{
				alt144 = 1;
			}
			} finally { DebugExitDecision(144); }
			switch (alt144)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1655:4: accessibilityModifier
				{
				DebugLocation(1655, 4);
				PushFollow(Follow._accessibilityModifier_in_getAccessor8994);
				accessibilityModifier476=accessibilityModifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_accessibilityModifier.Add(accessibilityModifier476.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(144); }

			DebugLocation(1655, 27);
			// TypeScript.g3:1655:27: ( STATIC )?
			int alt145=2;
			try { DebugEnterSubRule(145);
			try { DebugEnterDecision(145, false);
			int LA145_1 = input.LA(1);

			if ((LA145_1==STATIC))
			{
				alt145 = 1;
			}
			} finally { DebugExitDecision(145); }
			switch (alt145)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1655:27: STATIC
				{
				DebugLocation(1655, 27);
				STATIC477=(IToken)Match(input,STATIC,Follow._STATIC_in_getAccessor8997); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STATIC.Add(STATIC477);


				}
				break;

			}
			} finally { DebugExitSubRule(145); }

			DebugLocation(1655, 35);
			GET478=(IToken)Match(input,GET,Follow._GET_in_getAccessor9000); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_GET.Add(GET478);

			DebugLocation(1655, 39);
			PushFollow(Follow._identifier_in_getAccessor9002);
			identifier479=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier479.Tree);
			DebugLocation(1655, 50);
			LPAREN480=(IToken)Match(input,LPAREN,Follow._LPAREN_in_getAccessor9004); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN480);

			DebugLocation(1655, 57);
			RPAREN481=(IToken)Match(input,RPAREN,Follow._RPAREN_in_getAccessor9006); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN481);

			DebugLocation(1655, 64);
			// TypeScript.g3:1655:64: ( typeAnnotation )?
			int alt146=2;
			try { DebugEnterSubRule(146);
			try { DebugEnterDecision(146, false);
			int LA146_1 = input.LA(1);

			if ((LA146_1==COLON))
			{
				alt146 = 1;
			}
			} finally { DebugExitDecision(146); }
			switch (alt146)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1655:64: typeAnnotation
				{
				DebugLocation(1655, 64);
				PushFollow(Follow._typeAnnotation_in_getAccessor9008);
				typeAnnotation482=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation482.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(146); }

			DebugLocation(1655, 80);
			PushFollow(Follow._functionBody_in_getAccessor9011);
			functionBody483=functionBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functionBody.Add(functionBody483.Tree);


			{
			// AST REWRITE
			// elements: GET, accessibilityModifier, STATIC, identifier, typeAnnotation, functionBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1655:93: -> ^( GET ( accessibilityModifier )? ( STATIC )? identifier ( typeAnnotation )? functionBody )
			{
				DebugLocation(1655, 96);
				// TypeScript.g3:1655:96: ^( GET ( accessibilityModifier )? ( STATIC )? identifier ( typeAnnotation )? functionBody )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1655, 98);
				root_1 = (object)adaptor.BecomeRoot(stream_GET.NextNode(), root_1);

				DebugLocation(1655, 102);
				// TypeScript.g3:1655:102: ( accessibilityModifier )?
				if (stream_accessibilityModifier.HasNext)
				{
					DebugLocation(1655, 102);
					adaptor.AddChild(root_1, stream_accessibilityModifier.NextTree());

				}
				stream_accessibilityModifier.Reset();
				DebugLocation(1655, 125);
				// TypeScript.g3:1655:125: ( STATIC )?
				if (stream_STATIC.HasNext)
				{
					DebugLocation(1655, 125);
					adaptor.AddChild(root_1, stream_STATIC.NextNode());

				}
				stream_STATIC.Reset();
				DebugLocation(1655, 133);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(1655, 144);
				// TypeScript.g3:1655:144: ( typeAnnotation )?
				if (stream_typeAnnotation.HasNext)
				{
					DebugLocation(1655, 144);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

				}
				stream_typeAnnotation.Reset();
				DebugLocation(1655, 160);
				adaptor.AddChild(root_1, stream_functionBody.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("getAccessor", 124);
			LeaveRule("getAccessor", 124);
			LeaveRule_getAccessor();
		}
		DebugLocation(1656, 1);
		} finally { DebugExitRule(GrammarFileName, "getAccessor"); }
		return retval;

	}
	// $ANTLR end "getAccessor"

	partial void EnterRule_setAccessor();
	partial void LeaveRule_setAccessor();
	// $ANTLR start "setAccessor"
	// TypeScript.g3:1658:1: setAccessor : ( accessibilityModifier )? ( STATIC )? SET identifier LPAREN parameter RPAREN ( typeAnnotation )? functionBody -> ^( SET ( accessibilityModifier )? ( STATIC )? identifier parameter ( typeAnnotation )? functionBody ) ;
	[GrammarRule("setAccessor")]
	private AstParserRuleReturnScope<object, IToken> setAccessor()
	{
		EnterRule_setAccessor();
		EnterRule("setAccessor", 125);
		TraceIn("setAccessor", 125);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken STATIC485 = default(IToken);
		IToken SET486 = default(IToken);
		IToken LPAREN488 = default(IToken);
		IToken RPAREN490 = default(IToken);
		AstParserRuleReturnScope<object, IToken> accessibilityModifier484 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> identifier487 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parameter489 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation491 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionBody492 = default(AstParserRuleReturnScope<object, IToken>);

		object STATIC485_tree = default(object);
		object SET486_tree = default(object);
		object LPAREN488_tree = default(object);
		object RPAREN490_tree = default(object);
		RewriteRuleITokenStream stream_STATIC=new RewriteRuleITokenStream(adaptor,"token STATIC");
		RewriteRuleITokenStream stream_SET=new RewriteRuleITokenStream(adaptor,"token SET");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_accessibilityModifier=new RewriteRuleSubtreeStream(adaptor,"rule accessibilityModifier");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_parameter=new RewriteRuleSubtreeStream(adaptor,"rule parameter");
		RewriteRuleSubtreeStream stream_typeAnnotation=new RewriteRuleSubtreeStream(adaptor,"rule typeAnnotation");
		RewriteRuleSubtreeStream stream_functionBody=new RewriteRuleSubtreeStream(adaptor,"rule functionBody");
		try { DebugEnterRule(GrammarFileName, "setAccessor");
		DebugLocation(1658, 1);
		try
		{
			// TypeScript.g3:1659:2: ( ( accessibilityModifier )? ( STATIC )? SET identifier LPAREN parameter RPAREN ( typeAnnotation )? functionBody -> ^( SET ( accessibilityModifier )? ( STATIC )? identifier parameter ( typeAnnotation )? functionBody ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1659:4: ( accessibilityModifier )? ( STATIC )? SET identifier LPAREN parameter RPAREN ( typeAnnotation )? functionBody
			{
			DebugLocation(1659, 4);
			// TypeScript.g3:1659:4: ( accessibilityModifier )?
			int alt147=2;
			try { DebugEnterSubRule(147);
			try { DebugEnterDecision(147, false);
			int LA147_1 = input.LA(1);

			if ((LA147_1==PRIVATE||LA147_1==PROTECTED||LA147_1==PUBLIC))
			{
				alt147 = 1;
			}
			} finally { DebugExitDecision(147); }
			switch (alt147)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1659:4: accessibilityModifier
				{
				DebugLocation(1659, 4);
				PushFollow(Follow._accessibilityModifier_in_setAccessor9042);
				accessibilityModifier484=accessibilityModifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_accessibilityModifier.Add(accessibilityModifier484.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(147); }

			DebugLocation(1659, 27);
			// TypeScript.g3:1659:27: ( STATIC )?
			int alt148=2;
			try { DebugEnterSubRule(148);
			try { DebugEnterDecision(148, false);
			int LA148_1 = input.LA(1);

			if ((LA148_1==STATIC))
			{
				alt148 = 1;
			}
			} finally { DebugExitDecision(148); }
			switch (alt148)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1659:27: STATIC
				{
				DebugLocation(1659, 27);
				STATIC485=(IToken)Match(input,STATIC,Follow._STATIC_in_setAccessor9045); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STATIC.Add(STATIC485);


				}
				break;

			}
			} finally { DebugExitSubRule(148); }

			DebugLocation(1659, 35);
			SET486=(IToken)Match(input,SET,Follow._SET_in_setAccessor9048); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SET.Add(SET486);

			DebugLocation(1659, 39);
			PushFollow(Follow._identifier_in_setAccessor9050);
			identifier487=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier487.Tree);
			DebugLocation(1659, 50);
			LPAREN488=(IToken)Match(input,LPAREN,Follow._LPAREN_in_setAccessor9052); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN488);

			DebugLocation(1659, 57);
			PushFollow(Follow._parameter_in_setAccessor9054);
			parameter489=parameter();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_parameter.Add(parameter489.Tree);
			DebugLocation(1659, 67);
			RPAREN490=(IToken)Match(input,RPAREN,Follow._RPAREN_in_setAccessor9056); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN490);

			DebugLocation(1659, 74);
			// TypeScript.g3:1659:74: ( typeAnnotation )?
			int alt149=2;
			try { DebugEnterSubRule(149);
			try { DebugEnterDecision(149, false);
			int LA149_1 = input.LA(1);

			if ((LA149_1==COLON))
			{
				alt149 = 1;
			}
			} finally { DebugExitDecision(149); }
			switch (alt149)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1659:74: typeAnnotation
				{
				DebugLocation(1659, 74);
				PushFollow(Follow._typeAnnotation_in_setAccessor9058);
				typeAnnotation491=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation491.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(149); }

			DebugLocation(1659, 90);
			PushFollow(Follow._functionBody_in_setAccessor9061);
			functionBody492=functionBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functionBody.Add(functionBody492.Tree);


			{
			// AST REWRITE
			// elements: SET, accessibilityModifier, STATIC, identifier, parameter, typeAnnotation, functionBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1659:103: -> ^( SET ( accessibilityModifier )? ( STATIC )? identifier parameter ( typeAnnotation )? functionBody )
			{
				DebugLocation(1659, 106);
				// TypeScript.g3:1659:106: ^( SET ( accessibilityModifier )? ( STATIC )? identifier parameter ( typeAnnotation )? functionBody )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1659, 108);
				root_1 = (object)adaptor.BecomeRoot(stream_SET.NextNode(), root_1);

				DebugLocation(1659, 112);
				// TypeScript.g3:1659:112: ( accessibilityModifier )?
				if (stream_accessibilityModifier.HasNext)
				{
					DebugLocation(1659, 112);
					adaptor.AddChild(root_1, stream_accessibilityModifier.NextTree());

				}
				stream_accessibilityModifier.Reset();
				DebugLocation(1659, 135);
				// TypeScript.g3:1659:135: ( STATIC )?
				if (stream_STATIC.HasNext)
				{
					DebugLocation(1659, 135);
					adaptor.AddChild(root_1, stream_STATIC.NextNode());

				}
				stream_STATIC.Reset();
				DebugLocation(1659, 143);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(1659, 154);
				adaptor.AddChild(root_1, stream_parameter.NextTree());
				DebugLocation(1659, 164);
				// TypeScript.g3:1659:164: ( typeAnnotation )?
				if (stream_typeAnnotation.HasNext)
				{
					DebugLocation(1659, 164);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

				}
				stream_typeAnnotation.Reset();
				DebugLocation(1659, 180);
				adaptor.AddChild(root_1, stream_functionBody.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("setAccessor", 125);
			LeaveRule("setAccessor", 125);
			LeaveRule_setAccessor();
		}
		DebugLocation(1660, 1);
		} finally { DebugExitRule(GrammarFileName, "setAccessor"); }
		return retval;

	}
	// $ANTLR end "setAccessor"

	partial void EnterRule_enumDeclaration();
	partial void LeaveRule_enumDeclaration();
	// $ANTLR start "enumDeclaration"
	// TypeScript.g3:1666:1: enumDeclaration : ( CONST )? ENUM identifier LBRACE enumBody RBRACE ;
	[GrammarRule("enumDeclaration")]
	private AstParserRuleReturnScope<object, IToken> enumDeclaration()
	{
		EnterRule_enumDeclaration();
		EnterRule("enumDeclaration", 126);
		TraceIn("enumDeclaration", 126);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CONST493 = default(IToken);
		IToken ENUM494 = default(IToken);
		IToken LBRACE496 = default(IToken);
		IToken RBRACE498 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier495 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enumBody497 = default(AstParserRuleReturnScope<object, IToken>);

		object CONST493_tree = default(object);
		object ENUM494_tree = default(object);
		object LBRACE496_tree = default(object);
		object RBRACE498_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enumDeclaration");
		DebugLocation(1666, 1);
		try
		{
			// TypeScript.g3:1667:2: ( ( CONST )? ENUM identifier LBRACE enumBody RBRACE )
			DebugEnterAlt(1);
			// TypeScript.g3:1667:4: ( CONST )? ENUM identifier LBRACE enumBody RBRACE
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1667, 4);
			// TypeScript.g3:1667:4: ( CONST )?
			int alt150=2;
			try { DebugEnterSubRule(150);
			try { DebugEnterDecision(150, false);
			int LA150_1 = input.LA(1);

			if ((LA150_1==CONST))
			{
				alt150 = 1;
			}
			} finally { DebugExitDecision(150); }
			switch (alt150)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1667:4: CONST
				{
				DebugLocation(1667, 4);
				CONST493=(IToken)Match(input,CONST,Follow._CONST_in_enumDeclaration9098); if (state.failed) return retval;
				if (state.backtracking == 0) {
				CONST493_tree = (object)adaptor.Create(CONST493);
				adaptor.AddChild(root_0, CONST493_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(150); }

			DebugLocation(1667, 11);
			ENUM494=(IToken)Match(input,ENUM,Follow._ENUM_in_enumDeclaration9101); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ENUM494_tree = (object)adaptor.Create(ENUM494);
			adaptor.AddChild(root_0, ENUM494_tree);
			}
			DebugLocation(1667, 16);
			PushFollow(Follow._identifier_in_enumDeclaration9103);
			identifier495=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, identifier495.Tree);
			DebugLocation(1667, 27);
			LBRACE496=(IToken)Match(input,LBRACE,Follow._LBRACE_in_enumDeclaration9105); if (state.failed) return retval;
			if (state.backtracking == 0) {
			LBRACE496_tree = (object)adaptor.Create(LBRACE496);
			adaptor.AddChild(root_0, LBRACE496_tree);
			}
			DebugLocation(1667, 34);
			PushFollow(Follow._enumBody_in_enumDeclaration9107);
			enumBody497=enumBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, enumBody497.Tree);
			DebugLocation(1667, 43);
			RBRACE498=(IToken)Match(input,RBRACE,Follow._RBRACE_in_enumDeclaration9109); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RBRACE498_tree = (object)adaptor.Create(RBRACE498);
			adaptor.AddChild(root_0, RBRACE498_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enumDeclaration", 126);
			LeaveRule("enumDeclaration", 126);
			LeaveRule_enumDeclaration();
		}
		DebugLocation(1668, 1);
		} finally { DebugExitRule(GrammarFileName, "enumDeclaration"); }
		return retval;

	}
	// $ANTLR end "enumDeclaration"

	partial void EnterRule_enumBody();
	partial void LeaveRule_enumBody();
	// $ANTLR start "enumBody"
	// TypeScript.g3:1670:1: enumBody : ( enumMember COMMA )* enumMember ;
	[GrammarRule("enumBody")]
	private AstParserRuleReturnScope<object, IToken> enumBody()
	{
		EnterRule_enumBody();
		EnterRule("enumBody", 127);
		TraceIn("enumBody", 127);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA500 = default(IToken);
		AstParserRuleReturnScope<object, IToken> enumMember499 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enumMember501 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA500_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enumBody");
		DebugLocation(1670, 1);
		try
		{
			// TypeScript.g3:1671:2: ( ( enumMember COMMA )* enumMember )
			DebugEnterAlt(1);
			// TypeScript.g3:1671:4: ( enumMember COMMA )* enumMember
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1671, 4);
			// TypeScript.g3:1671:4: ( enumMember COMMA )*
			try { DebugEnterSubRule(151);
			while (true)
			{
				int alt151=2;
				try { DebugEnterDecision(151, false);
				int LA151_1 = input.LA(1);

				if ((LA151_1==ANY||LA151_1==CONSTRUCTOR||LA151_1==DECLARE||LA151_1==FINAL||LA151_1==GET||LA151_1==MODULE||LA151_1==NUMBER||LA151_1==REQUIRE||LA151_1==SET||LA151_1==STRING||LA151_1==THROWS||LA151_1==TYPE))
				{
					int LA151_2 = input.LA(2);

					if ((LA151_2==ASSIGN))
					{
						switch (input.LA(3))
						{
						case THIS:
							{
							alt151 = 1;
							}
							break;
						case ANY:
						case CONSTRUCTOR:
						case DECLARE:
						case FINAL:
						case GET:
						case MODULE:
						case NUMBER:
						case REQUIRE:
						case SET:
						case STRING:
						case THROWS:
						case TYPE:
							{
							alt151 = 1;
							}
							break;
						case Identifier:
							{
							alt151 = 1;
							}
							break;
						case NULL:
							{
							alt151 = 1;
							}
							break;
						case FALSE:
						case TRUE:
							{
							alt151 = 1;
							}
							break;
						case DecimalLiteral:
						case HexIntegerLiteral:
						case OctalIntegerLiteral:
							{
							alt151 = 1;
							}
							break;
						case StringLiteral:
							{
							alt151 = 1;
							}
							break;
						case RegularExpressionLiteral:
							{
							alt151 = 1;
							}
							break;
						case LBRACK:
							{
							alt151 = 1;
							}
							break;
						case LBRACE:
							{
							alt151 = 1;
							}
							break;
						case LPAREN:
							{
							alt151 = 1;
							}
							break;
						case FUNCTION:
							{
							alt151 = 1;
							}
							break;
						case NEW:
							{
							alt151 = 1;
							}
							break;
						case DELETE:
							{
							alt151 = 1;
							}
							break;
						case VOID:
							{
							alt151 = 1;
							}
							break;
						case TYPEOF:
							{
							alt151 = 1;
							}
							break;
						case INC:
							{
							alt151 = 1;
							}
							break;
						case DEC:
							{
							alt151 = 1;
							}
							break;
						case ADD:
							{
							alt151 = 1;
							}
							break;
						case SUB:
							{
							alt151 = 1;
							}
							break;
						case INV:
							{
							alt151 = 1;
							}
							break;
						case NOT:
							{
							alt151 = 1;
							}
							break;
						}

					}
					else if ((LA151_2==COMMA))
					{
						alt151 = 1;
					}


				}
				else if ((LA151_1==Identifier))
				{
					int LA151_2 = input.LA(2);

					if ((LA151_2==ASSIGN))
					{
						switch (input.LA(3))
						{
						case THIS:
							{
							alt151 = 1;
							}
							break;
						case ANY:
						case CONSTRUCTOR:
						case DECLARE:
						case FINAL:
						case GET:
						case MODULE:
						case NUMBER:
						case REQUIRE:
						case SET:
						case STRING:
						case THROWS:
						case TYPE:
							{
							alt151 = 1;
							}
							break;
						case Identifier:
							{
							alt151 = 1;
							}
							break;
						case NULL:
							{
							alt151 = 1;
							}
							break;
						case FALSE:
						case TRUE:
							{
							alt151 = 1;
							}
							break;
						case DecimalLiteral:
						case HexIntegerLiteral:
						case OctalIntegerLiteral:
							{
							alt151 = 1;
							}
							break;
						case StringLiteral:
							{
							alt151 = 1;
							}
							break;
						case RegularExpressionLiteral:
							{
							alt151 = 1;
							}
							break;
						case LBRACK:
							{
							alt151 = 1;
							}
							break;
						case LBRACE:
							{
							alt151 = 1;
							}
							break;
						case LPAREN:
							{
							alt151 = 1;
							}
							break;
						case FUNCTION:
							{
							alt151 = 1;
							}
							break;
						case NEW:
							{
							alt151 = 1;
							}
							break;
						case DELETE:
							{
							alt151 = 1;
							}
							break;
						case VOID:
							{
							alt151 = 1;
							}
							break;
						case TYPEOF:
							{
							alt151 = 1;
							}
							break;
						case INC:
							{
							alt151 = 1;
							}
							break;
						case DEC:
							{
							alt151 = 1;
							}
							break;
						case ADD:
							{
							alt151 = 1;
							}
							break;
						case SUB:
							{
							alt151 = 1;
							}
							break;
						case INV:
							{
							alt151 = 1;
							}
							break;
						case NOT:
							{
							alt151 = 1;
							}
							break;
						}

					}
					else if ((LA151_2==COMMA))
					{
						alt151 = 1;
					}


				}


				} finally { DebugExitDecision(151); }
				switch ( alt151 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1671:5: enumMember COMMA
					{
					DebugLocation(1671, 5);
					PushFollow(Follow._enumMember_in_enumBody9122);
					enumMember499=enumMember();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, enumMember499.Tree);
					DebugLocation(1671, 16);
					COMMA500=(IToken)Match(input,COMMA,Follow._COMMA_in_enumBody9124); if (state.failed) return retval;
					if (state.backtracking == 0) {
					COMMA500_tree = (object)adaptor.Create(COMMA500);
					adaptor.AddChild(root_0, COMMA500_tree);
					}

					}
					break;

				default:
					goto loop151;
				}
			}

			loop151:
				;

			} finally { DebugExitSubRule(151); }

			DebugLocation(1671, 24);
			PushFollow(Follow._enumMember_in_enumBody9128);
			enumMember501=enumMember();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, enumMember501.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enumBody", 127);
			LeaveRule("enumBody", 127);
			LeaveRule_enumBody();
		}
		DebugLocation(1672, 1);
		} finally { DebugExitRule(GrammarFileName, "enumBody"); }
		return retval;

	}
	// $ANTLR end "enumBody"

	partial void EnterRule_enumMember();
	partial void LeaveRule_enumMember();
	// $ANTLR start "enumMember"
	// TypeScript.g3:1674:1: enumMember : identifier ( ASSIGN ^ assignmentExpression )? ;
	[GrammarRule("enumMember")]
	private AstParserRuleReturnScope<object, IToken> enumMember()
	{
		EnterRule_enumMember();
		EnterRule("enumMember", 128);
		TraceIn("enumMember", 128);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASSIGN503 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier502 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression504 = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN503_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enumMember");
		DebugLocation(1674, 1);
		try
		{
			// TypeScript.g3:1675:2: ( identifier ( ASSIGN ^ assignmentExpression )? )
			DebugEnterAlt(1);
			// TypeScript.g3:1675:4: identifier ( ASSIGN ^ assignmentExpression )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1675, 4);
			PushFollow(Follow._identifier_in_enumMember9139);
			identifier502=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, identifier502.Tree);
			DebugLocation(1675, 14);
			// TypeScript.g3:1675:14: ( ASSIGN ^ assignmentExpression )?
			int alt152=2;
			try { DebugEnterSubRule(152);
			try { DebugEnterDecision(152, false);
			int LA152_1 = input.LA(1);

			if ((LA152_1==ASSIGN))
			{
				alt152 = 1;
			}
			} finally { DebugExitDecision(152); }
			switch (alt152)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1675:16: ASSIGN ^ assignmentExpression
				{
				DebugLocation(1675, 22);
				ASSIGN503=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_enumMember9142); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ASSIGN503_tree = (object)adaptor.Create(ASSIGN503);
				root_0 = (object)adaptor.BecomeRoot(ASSIGN503_tree, root_0);
				}
				DebugLocation(1675, 24);
				PushFollow(Follow._assignmentExpression_in_enumMember9145);
				assignmentExpression504=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression504.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(152); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enumMember", 128);
			LeaveRule("enumMember", 128);
			LeaveRule_enumMember();
		}
		DebugLocation(1676, 1);
		} finally { DebugExitRule(GrammarFileName, "enumMember"); }
		return retval;

	}
	// $ANTLR end "enumMember"

	partial void EnterRule_moduleDeclaration();
	partial void LeaveRule_moduleDeclaration();
	// $ANTLR start "moduleDeclaration"
	// TypeScript.g3:1682:1: moduleDeclaration options {k=2; } : ( MODULE StringLiteral LBRACE ( moduleElement )* RBRACE -> ^( MODULE StringLiteral ( moduleElement )* ) | MODULE identifier LBRACE ( moduleElement )* RBRACE -> ^( MODULE identifier ( moduleElement )* ) );
	[GrammarRule("moduleDeclaration")]
	private AstParserRuleReturnScope<object, IToken> moduleDeclaration()
	{
		EnterRule_moduleDeclaration();
		EnterRule("moduleDeclaration", 129);
		TraceIn("moduleDeclaration", 129);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken MODULE505 = default(IToken);
		IToken StringLiteral506 = default(IToken);
		IToken LBRACE507 = default(IToken);
		IToken RBRACE509 = default(IToken);
		IToken MODULE510 = default(IToken);
		IToken LBRACE512 = default(IToken);
		IToken RBRACE514 = default(IToken);
		AstParserRuleReturnScope<object, IToken> moduleElement508 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> identifier511 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> moduleElement513 = default(AstParserRuleReturnScope<object, IToken>);

		object MODULE505_tree = default(object);
		object StringLiteral506_tree = default(object);
		object LBRACE507_tree = default(object);
		object RBRACE509_tree = default(object);
		object MODULE510_tree = default(object);
		object LBRACE512_tree = default(object);
		object RBRACE514_tree = default(object);
		RewriteRuleITokenStream stream_MODULE=new RewriteRuleITokenStream(adaptor,"token MODULE");
		RewriteRuleITokenStream stream_StringLiteral=new RewriteRuleITokenStream(adaptor,"token StringLiteral");
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_moduleElement=new RewriteRuleSubtreeStream(adaptor,"rule moduleElement");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "moduleDeclaration");
		DebugLocation(1682, 1);
		try
		{
			// TypeScript.g3:1687:2: ( MODULE StringLiteral LBRACE ( moduleElement )* RBRACE -> ^( MODULE StringLiteral ( moduleElement )* ) | MODULE identifier LBRACE ( moduleElement )* RBRACE -> ^( MODULE identifier ( moduleElement )* ) )
			int alt155=2;
			try { DebugEnterDecision(155, false);
			int LA155_1 = input.LA(1);

			if ((LA155_1==MODULE))
			{
				int LA155_2 = input.LA(2);

				if ((LA155_2==StringLiteral))
				{
					alt155 = 1;
				}
				else if ((LA155_2==ANY||LA155_2==CONSTRUCTOR||LA155_2==DECLARE||LA155_2==FINAL||LA155_2==GET||LA155_2==Identifier||LA155_2==MODULE||LA155_2==NUMBER||LA155_2==REQUIRE||LA155_2==SET||LA155_2==STRING||LA155_2==THROWS||LA155_2==TYPE))
				{
					alt155 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 155, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 155, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(155); }
			switch (alt155)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1687:4: MODULE StringLiteral LBRACE ( moduleElement )* RBRACE
				{
				DebugLocation(1687, 4);
				MODULE505=(IToken)Match(input,MODULE,Follow._MODULE_in_moduleDeclaration9176); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MODULE.Add(MODULE505);

				DebugLocation(1687, 11);
				StringLiteral506=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_moduleDeclaration9178); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_StringLiteral.Add(StringLiteral506);

				DebugLocation(1687, 25);
				LBRACE507=(IToken)Match(input,LBRACE,Follow._LBRACE_in_moduleDeclaration9180); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LBRACE.Add(LBRACE507);

				DebugLocation(1687, 32);
				// TypeScript.g3:1687:32: ( moduleElement )*
				try { DebugEnterSubRule(153);
				while (true)
				{
					int alt153=2;
					try { DebugEnterDecision(153, false);
					int LA153_1 = input.LA(1);

					if ((LA153_1==ADD||LA153_1==ANY||LA153_1==BREAK||LA153_1==CLASS||(LA153_1>=CONST && LA153_1<=CONSTRUCTOR)||LA153_1==CONTINUE||(LA153_1>=DEC && LA153_1<=DECLARE)||LA153_1==DELETE||LA153_1==DO||LA153_1==DecimalLiteral||LA153_1==ENUM||LA153_1==EXPORT||LA153_1==FALSE||LA153_1==FINAL||LA153_1==FOR||LA153_1==FUNCTION||LA153_1==GET||(LA153_1>=HexIntegerLiteral && LA153_1<=IF)||LA153_1==IMPORT||LA153_1==INC||(LA153_1>=INTERFACE && LA153_1<=INV)||LA153_1==Identifier||(LA153_1>=LBRACE && LA153_1<=LBRACK)||LA153_1==LPAREN||LA153_1==MODULE||(LA153_1>=NEW && LA153_1<=NOT)||(LA153_1>=NULL && LA153_1<=NUMBER)||LA153_1==OctalIntegerLiteral||(LA153_1>=REQUIRE && LA153_1<=RETURN)||LA153_1==RegularExpressionLiteral||(LA153_1>=SEMIC && LA153_1<=SET)||(LA153_1>=STRING && LA153_1<=SUB)||LA153_1==SWITCH||LA153_1==StringLiteral||(LA153_1>=THIS && LA153_1<=THROWS)||(LA153_1>=TRUE && LA153_1<=TRY)||(LA153_1>=TYPE && LA153_1<=TYPEOF)||LA153_1==VAR||LA153_1==VOID||(LA153_1>=WHILE && LA153_1<=WITH)))
					{
						alt153 = 1;
					}


					} finally { DebugExitDecision(153); }
					switch ( alt153 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScript.g3:1687:33: moduleElement
						{
						DebugLocation(1687, 33);
						PushFollow(Follow._moduleElement_in_moduleDeclaration9183);
						moduleElement508=moduleElement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_moduleElement.Add(moduleElement508.Tree);

						}
						break;

					default:
						goto loop153;
					}
				}

				loop153:
					;

				} finally { DebugExitSubRule(153); }

				DebugLocation(1687, 49);
				RBRACE509=(IToken)Match(input,RBRACE,Follow._RBRACE_in_moduleDeclaration9187); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RBRACE.Add(RBRACE509);



				{
				// AST REWRITE
				// elements: MODULE, StringLiteral, moduleElement
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1687:56: -> ^( MODULE StringLiteral ( moduleElement )* )
				{
					DebugLocation(1687, 59);
					// TypeScript.g3:1687:59: ^( MODULE StringLiteral ( moduleElement )* )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1687, 61);
					root_1 = (object)adaptor.BecomeRoot(stream_MODULE.NextNode(), root_1);

					DebugLocation(1687, 68);
					adaptor.AddChild(root_1, stream_StringLiteral.NextNode());
					DebugLocation(1687, 82);
					// TypeScript.g3:1687:82: ( moduleElement )*
					while ( stream_moduleElement.HasNext )
					{
						DebugLocation(1687, 82);
						adaptor.AddChild(root_1, stream_moduleElement.NextTree());

					}
					stream_moduleElement.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1688:7: MODULE identifier LBRACE ( moduleElement )* RBRACE
				{
				DebugLocation(1688, 7);
				MODULE510=(IToken)Match(input,MODULE,Follow._MODULE_in_moduleDeclaration9206); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MODULE.Add(MODULE510);

				DebugLocation(1688, 14);
				PushFollow(Follow._identifier_in_moduleDeclaration9208);
				identifier511=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_identifier.Add(identifier511.Tree);
				DebugLocation(1688, 25);
				LBRACE512=(IToken)Match(input,LBRACE,Follow._LBRACE_in_moduleDeclaration9210); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LBRACE.Add(LBRACE512);

				DebugLocation(1688, 32);
				// TypeScript.g3:1688:32: ( moduleElement )*
				try { DebugEnterSubRule(154);
				while (true)
				{
					int alt154=2;
					try { DebugEnterDecision(154, false);
					int LA154_1 = input.LA(1);

					if ((LA154_1==ADD||LA154_1==ANY||LA154_1==BREAK||LA154_1==CLASS||(LA154_1>=CONST && LA154_1<=CONSTRUCTOR)||LA154_1==CONTINUE||(LA154_1>=DEC && LA154_1<=DECLARE)||LA154_1==DELETE||LA154_1==DO||LA154_1==DecimalLiteral||LA154_1==ENUM||LA154_1==EXPORT||LA154_1==FALSE||LA154_1==FINAL||LA154_1==FOR||LA154_1==FUNCTION||LA154_1==GET||(LA154_1>=HexIntegerLiteral && LA154_1<=IF)||LA154_1==IMPORT||LA154_1==INC||(LA154_1>=INTERFACE && LA154_1<=INV)||LA154_1==Identifier||(LA154_1>=LBRACE && LA154_1<=LBRACK)||LA154_1==LPAREN||LA154_1==MODULE||(LA154_1>=NEW && LA154_1<=NOT)||(LA154_1>=NULL && LA154_1<=NUMBER)||LA154_1==OctalIntegerLiteral||(LA154_1>=REQUIRE && LA154_1<=RETURN)||LA154_1==RegularExpressionLiteral||(LA154_1>=SEMIC && LA154_1<=SET)||(LA154_1>=STRING && LA154_1<=SUB)||LA154_1==SWITCH||LA154_1==StringLiteral||(LA154_1>=THIS && LA154_1<=THROWS)||(LA154_1>=TRUE && LA154_1<=TRY)||(LA154_1>=TYPE && LA154_1<=TYPEOF)||LA154_1==VAR||LA154_1==VOID||(LA154_1>=WHILE && LA154_1<=WITH)))
					{
						alt154 = 1;
					}


					} finally { DebugExitDecision(154); }
					switch ( alt154 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScript.g3:1688:33: moduleElement
						{
						DebugLocation(1688, 33);
						PushFollow(Follow._moduleElement_in_moduleDeclaration9213);
						moduleElement513=moduleElement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_moduleElement.Add(moduleElement513.Tree);

						}
						break;

					default:
						goto loop154;
					}
				}

				loop154:
					;

				} finally { DebugExitSubRule(154); }

				DebugLocation(1688, 49);
				RBRACE514=(IToken)Match(input,RBRACE,Follow._RBRACE_in_moduleDeclaration9217); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RBRACE.Add(RBRACE514);



				{
				// AST REWRITE
				// elements: MODULE, identifier, moduleElement
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1688:56: -> ^( MODULE identifier ( moduleElement )* )
				{
					DebugLocation(1688, 59);
					// TypeScript.g3:1688:59: ^( MODULE identifier ( moduleElement )* )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1688, 61);
					root_1 = (object)adaptor.BecomeRoot(stream_MODULE.NextNode(), root_1);

					DebugLocation(1688, 68);
					adaptor.AddChild(root_1, stream_identifier.NextTree());
					DebugLocation(1688, 79);
					// TypeScript.g3:1688:79: ( moduleElement )*
					while ( stream_moduleElement.HasNext )
					{
						DebugLocation(1688, 79);
						adaptor.AddChild(root_1, stream_moduleElement.NextTree());

					}
					stream_moduleElement.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("moduleDeclaration", 129);
			LeaveRule("moduleDeclaration", 129);
			LeaveRule_moduleDeclaration();
		}
		DebugLocation(1689, 1);
		} finally { DebugExitRule(GrammarFileName, "moduleDeclaration"); }
		return retval;

	}
	// $ANTLR end "moduleDeclaration"

	partial void EnterRule_moduleElement();
	partial void LeaveRule_moduleElement();
	// $ANTLR start "moduleElement"
	// TypeScript.g3:1691:8: public moduleElement options {k=1; } : ( importDeclaration | ambientDeclaration | moduleDeclaration |{...}? functionDeclaration | statement | interfaceDeclaration | classDeclaration | enumDeclaration | exportDeclaration );
	[GrammarRule("moduleElement")]
	public AstParserRuleReturnScope<object, IToken> moduleElement()
	{
		EnterRule_moduleElement();
		EnterRule("moduleElement", 130);
		TraceIn("moduleElement", 130);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> importDeclaration515 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ambientDeclaration516 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> moduleDeclaration517 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionDeclaration518 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement519 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> interfaceDeclaration520 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classDeclaration521 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enumDeclaration522 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exportDeclaration523 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "moduleElement");
		DebugLocation(1691, 4);
		try
		{
			// TypeScript.g3:1696:5: ( importDeclaration | ambientDeclaration | moduleDeclaration |{...}? functionDeclaration | statement | interfaceDeclaration | classDeclaration | enumDeclaration | exportDeclaration )
			int alt156=9;
			try { DebugEnterDecision(156, false);
			switch (input.LA(1))
			{
			case IMPORT:
				{
				alt156 = 1;
				}
				break;
			case DECLARE:
				{
				alt156 = 2;
				}
				break;
			case MODULE:
				{
				alt156 = 3;
				}
				break;
			case FUNCTION:
				{
				int LA156_2 = input.LA(2);

				if ((( input.LA(1) == FUNCTION )))
				{
					alt156 = 4;
				}
				else if ((true))
				{
					alt156 = 5;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 156, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ADD:
			case ANY:
			case BREAK:
			case CONSTRUCTOR:
			case CONTINUE:
			case DEC:
			case DELETE:
			case DO:
			case DecimalLiteral:
			case FALSE:
			case FINAL:
			case FOR:
			case GET:
			case HexIntegerLiteral:
			case IF:
			case INC:
			case INV:
			case Identifier:
			case LBRACE:
			case LBRACK:
			case LPAREN:
			case NEW:
			case NOT:
			case NULL:
			case NUMBER:
			case OctalIntegerLiteral:
			case REQUIRE:
			case RETURN:
			case RegularExpressionLiteral:
			case SEMIC:
			case SET:
			case STRING:
			case SUB:
			case SWITCH:
			case StringLiteral:
			case THIS:
			case THROW:
			case THROWS:
			case TRUE:
			case TRY:
			case TYPE:
			case TYPEOF:
			case VAR:
			case VOID:
			case WHILE:
			case WITH:
				{
				alt156 = 5;
				}
				break;
			case INTERFACE:
				{
				alt156 = 6;
				}
				break;
			case CLASS:
				{
				alt156 = 7;
				}
				break;
			case CONST:
			case ENUM:
				{
				alt156 = 8;
				}
				break;
			case EXPORT:
				{
				alt156 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 156, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(156); }
			switch (alt156)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1696:7: importDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1696, 7);
				PushFollow(Follow._importDeclaration_in_moduleElement9257);
				importDeclaration515=importDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, importDeclaration515.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1697:7: ambientDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1697, 7);
				PushFollow(Follow._ambientDeclaration_in_moduleElement9265);
				ambientDeclaration516=ambientDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ambientDeclaration516.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:1698:7: moduleDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1698, 7);
				PushFollow(Follow._moduleDeclaration_in_moduleElement9273);
				moduleDeclaration517=moduleDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, moduleDeclaration517.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:1699:7: {...}? functionDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1699, 7);
				if (!(( input.LA(1) == FUNCTION )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "moduleElement", " input.LA(1) == FUNCTION ");
				}
				DebugLocation(1699, 36);
				PushFollow(Follow._functionDeclaration_in_moduleElement9283);
				functionDeclaration518=functionDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, functionDeclaration518.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:1700:7: statement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1700, 7);
				PushFollow(Follow._statement_in_moduleElement9291);
				statement519=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statement519.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScript.g3:1701:7: interfaceDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1701, 7);
				PushFollow(Follow._interfaceDeclaration_in_moduleElement9299);
				interfaceDeclaration520=interfaceDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interfaceDeclaration520.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// TypeScript.g3:1702:7: classDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1702, 7);
				PushFollow(Follow._classDeclaration_in_moduleElement9307);
				classDeclaration521=classDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classDeclaration521.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// TypeScript.g3:1703:7: enumDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1703, 7);
				PushFollow(Follow._enumDeclaration_in_moduleElement9315);
				enumDeclaration522=enumDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, enumDeclaration522.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// TypeScript.g3:1704:7: exportDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1704, 7);
				PushFollow(Follow._exportDeclaration_in_moduleElement9323);
				exportDeclaration523=exportDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, exportDeclaration523.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("moduleElement", 130);
			LeaveRule("moduleElement", 130);
			LeaveRule_moduleElement();
		}
		DebugLocation(1705, 4);
		} finally { DebugExitRule(GrammarFileName, "moduleElement"); }
		return retval;

	}
	// $ANTLR end "moduleElement"

	partial void EnterRule_importDeclaration();
	partial void LeaveRule_importDeclaration();
	// $ANTLR start "importDeclaration"
	// TypeScript.g3:1707:1: importDeclaration : IMPORT identifier ASSIGN MODULE LPAREN StringLiteral RPAREN semic -> ^( IMPORT identifier StringLiteral ) ;
	[GrammarRule("importDeclaration")]
	private AstParserRuleReturnScope<object, IToken> importDeclaration()
	{
		EnterRule_importDeclaration();
		EnterRule("importDeclaration", 131);
		TraceIn("importDeclaration", 131);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IMPORT524 = default(IToken);
		IToken ASSIGN526 = default(IToken);
		IToken MODULE527 = default(IToken);
		IToken LPAREN528 = default(IToken);
		IToken StringLiteral529 = default(IToken);
		IToken RPAREN530 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier525 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic531 = default(AstParserRuleReturnScope<object, IToken>);

		object IMPORT524_tree = default(object);
		object ASSIGN526_tree = default(object);
		object MODULE527_tree = default(object);
		object LPAREN528_tree = default(object);
		object StringLiteral529_tree = default(object);
		object RPAREN530_tree = default(object);
		RewriteRuleITokenStream stream_IMPORT=new RewriteRuleITokenStream(adaptor,"token IMPORT");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleITokenStream stream_MODULE=new RewriteRuleITokenStream(adaptor,"token MODULE");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_StringLiteral=new RewriteRuleITokenStream(adaptor,"token StringLiteral");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		try { DebugEnterRule(GrammarFileName, "importDeclaration");
		DebugLocation(1707, 1);
		try
		{
			// TypeScript.g3:1708:2: ( IMPORT identifier ASSIGN MODULE LPAREN StringLiteral RPAREN semic -> ^( IMPORT identifier StringLiteral ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1708:4: IMPORT identifier ASSIGN MODULE LPAREN StringLiteral RPAREN semic
			{
			DebugLocation(1708, 4);
			IMPORT524=(IToken)Match(input,IMPORT,Follow._IMPORT_in_importDeclaration9338); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IMPORT.Add(IMPORT524);

			DebugLocation(1708, 11);
			PushFollow(Follow._identifier_in_importDeclaration9340);
			identifier525=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier525.Tree);
			DebugLocation(1708, 22);
			ASSIGN526=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_importDeclaration9342); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN526);

			DebugLocation(1708, 29);
			MODULE527=(IToken)Match(input,MODULE,Follow._MODULE_in_importDeclaration9344); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_MODULE.Add(MODULE527);

			DebugLocation(1708, 36);
			LPAREN528=(IToken)Match(input,LPAREN,Follow._LPAREN_in_importDeclaration9346); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN528);

			DebugLocation(1708, 43);
			StringLiteral529=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_importDeclaration9348); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_StringLiteral.Add(StringLiteral529);

			DebugLocation(1708, 57);
			RPAREN530=(IToken)Match(input,RPAREN,Follow._RPAREN_in_importDeclaration9350); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN530);

			DebugLocation(1708, 64);
			PushFollow(Follow._semic_in_importDeclaration9352);
			semic531=semic();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semic.Add(semic531.Tree);


			{
			// AST REWRITE
			// elements: IMPORT, identifier, StringLiteral
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1708:70: -> ^( IMPORT identifier StringLiteral )
			{
				DebugLocation(1708, 73);
				// TypeScript.g3:1708:73: ^( IMPORT identifier StringLiteral )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1708, 75);
				root_1 = (object)adaptor.BecomeRoot(stream_IMPORT.NextNode(), root_1);

				DebugLocation(1708, 82);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(1708, 93);
				adaptor.AddChild(root_1, stream_StringLiteral.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("importDeclaration", 131);
			LeaveRule("importDeclaration", 131);
			LeaveRule_importDeclaration();
		}
		DebugLocation(1709, 1);
		} finally { DebugExitRule(GrammarFileName, "importDeclaration"); }
		return retval;

	}
	// $ANTLR end "importDeclaration"

	partial void EnterRule_exportDeclaration();
	partial void LeaveRule_exportDeclaration();
	// $ANTLR start "exportDeclaration"
	// TypeScript.g3:1711:1: exportDeclaration : EXPORT exportableElement -> ^( EXPORT exportableElement ) ;
	[GrammarRule("exportDeclaration")]
	private AstParserRuleReturnScope<object, IToken> exportDeclaration()
	{
		EnterRule_exportDeclaration();
		EnterRule("exportDeclaration", 132);
		TraceIn("exportDeclaration", 132);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EXPORT532 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exportableElement533 = default(AstParserRuleReturnScope<object, IToken>);

		object EXPORT532_tree = default(object);
		RewriteRuleITokenStream stream_EXPORT=new RewriteRuleITokenStream(adaptor,"token EXPORT");
		RewriteRuleSubtreeStream stream_exportableElement=new RewriteRuleSubtreeStream(adaptor,"rule exportableElement");
		try { DebugEnterRule(GrammarFileName, "exportDeclaration");
		DebugLocation(1711, 4);
		try
		{
			// TypeScript.g3:1712:5: ( EXPORT exportableElement -> ^( EXPORT exportableElement ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1712:7: EXPORT exportableElement
			{
			DebugLocation(1712, 7);
			EXPORT532=(IToken)Match(input,EXPORT,Follow._EXPORT_in_exportDeclaration9376); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EXPORT.Add(EXPORT532);

			DebugLocation(1712, 14);
			PushFollow(Follow._exportableElement_in_exportDeclaration9378);
			exportableElement533=exportableElement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exportableElement.Add(exportableElement533.Tree);


			{
			// AST REWRITE
			// elements: EXPORT, exportableElement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1712:32: -> ^( EXPORT exportableElement )
			{
				DebugLocation(1712, 35);
				// TypeScript.g3:1712:35: ^( EXPORT exportableElement )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1712, 37);
				root_1 = (object)adaptor.BecomeRoot(stream_EXPORT.NextNode(), root_1);

				DebugLocation(1712, 44);
				adaptor.AddChild(root_1, stream_exportableElement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exportDeclaration", 132);
			LeaveRule("exportDeclaration", 132);
			LeaveRule_exportDeclaration();
		}
		DebugLocation(1713, 4);
		} finally { DebugExitRule(GrammarFileName, "exportDeclaration"); }
		return retval;

	}
	// $ANTLR end "exportDeclaration"

	partial void EnterRule_exportableElement();
	partial void LeaveRule_exportableElement();
	// $ANTLR start "exportableElement"
	// TypeScript.g3:1715:1: exportableElement : ( interfaceDeclaration | classDeclaration | moduleDeclaration | importDeclaration | enumDeclaration | ambientDeclaration | variableStatement | functionDeclaration );
	[GrammarRule("exportableElement")]
	private AstParserRuleReturnScope<object, IToken> exportableElement()
	{
		EnterRule_exportableElement();
		EnterRule("exportableElement", 133);
		TraceIn("exportableElement", 133);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> interfaceDeclaration534 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classDeclaration535 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> moduleDeclaration536 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> importDeclaration537 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enumDeclaration538 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ambientDeclaration539 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableStatement540 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionDeclaration541 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "exportableElement");
		DebugLocation(1715, 4);
		try
		{
			// TypeScript.g3:1716:5: ( interfaceDeclaration | classDeclaration | moduleDeclaration | importDeclaration | enumDeclaration | ambientDeclaration | variableStatement | functionDeclaration )
			int alt157=8;
			try { DebugEnterDecision(157, false);
			switch (input.LA(1))
			{
			case INTERFACE:
				{
				alt157 = 1;
				}
				break;
			case CLASS:
				{
				alt157 = 2;
				}
				break;
			case MODULE:
				{
				alt157 = 3;
				}
				break;
			case IMPORT:
				{
				alt157 = 4;
				}
				break;
			case CONST:
			case ENUM:
				{
				alt157 = 5;
				}
				break;
			case DECLARE:
				{
				alt157 = 6;
				}
				break;
			case VAR:
				{
				alt157 = 7;
				}
				break;
			case FUNCTION:
				{
				alt157 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 157, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(157); }
			switch (alt157)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1716:7: interfaceDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1716, 7);
				PushFollow(Follow._interfaceDeclaration_in_exportableElement9403);
				interfaceDeclaration534=interfaceDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interfaceDeclaration534.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1717:7: classDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1717, 7);
				PushFollow(Follow._classDeclaration_in_exportableElement9411);
				classDeclaration535=classDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classDeclaration535.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:1718:7: moduleDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1718, 7);
				PushFollow(Follow._moduleDeclaration_in_exportableElement9419);
				moduleDeclaration536=moduleDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, moduleDeclaration536.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:1719:7: importDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1719, 7);
				PushFollow(Follow._importDeclaration_in_exportableElement9427);
				importDeclaration537=importDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, importDeclaration537.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:1720:7: enumDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1720, 7);
				PushFollow(Follow._enumDeclaration_in_exportableElement9435);
				enumDeclaration538=enumDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, enumDeclaration538.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScript.g3:1721:7: ambientDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1721, 7);
				PushFollow(Follow._ambientDeclaration_in_exportableElement9443);
				ambientDeclaration539=ambientDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ambientDeclaration539.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// TypeScript.g3:1722:7: variableStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1722, 7);
				PushFollow(Follow._variableStatement_in_exportableElement9451);
				variableStatement540=variableStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableStatement540.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// TypeScript.g3:1723:7: functionDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1723, 7);
				PushFollow(Follow._functionDeclaration_in_exportableElement9459);
				functionDeclaration541=functionDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, functionDeclaration541.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exportableElement", 133);
			LeaveRule("exportableElement", 133);
			LeaveRule_exportableElement();
		}
		DebugLocation(1724, 4);
		} finally { DebugExitRule(GrammarFileName, "exportableElement"); }
		return retval;

	}
	// $ANTLR end "exportableElement"

	partial void EnterRule_ambientDeclaration();
	partial void LeaveRule_ambientDeclaration();
	// $ANTLR start "ambientDeclaration"
	// TypeScript.g3:1726:1: ambientDeclaration : DECLARE ambientElement -> ^( DECLARE ambientElement ) ;
	[GrammarRule("ambientDeclaration")]
	private AstParserRuleReturnScope<object, IToken> ambientDeclaration()
	{
		EnterRule_ambientDeclaration();
		EnterRule("ambientDeclaration", 134);
		TraceIn("ambientDeclaration", 134);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DECLARE542 = default(IToken);
		AstParserRuleReturnScope<object, IToken> ambientElement543 = default(AstParserRuleReturnScope<object, IToken>);

		object DECLARE542_tree = default(object);
		RewriteRuleITokenStream stream_DECLARE=new RewriteRuleITokenStream(adaptor,"token DECLARE");
		RewriteRuleSubtreeStream stream_ambientElement=new RewriteRuleSubtreeStream(adaptor,"rule ambientElement");
		try { DebugEnterRule(GrammarFileName, "ambientDeclaration");
		DebugLocation(1726, 4);
		try
		{
			// TypeScript.g3:1727:5: ( DECLARE ambientElement -> ^( DECLARE ambientElement ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1727:7: DECLARE ambientElement
			{
			DebugLocation(1727, 7);
			DECLARE542=(IToken)Match(input,DECLARE,Follow._DECLARE_in_ambientDeclaration9476); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DECLARE.Add(DECLARE542);

			DebugLocation(1727, 15);
			PushFollow(Follow._ambientElement_in_ambientDeclaration9478);
			ambientElement543=ambientElement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ambientElement.Add(ambientElement543.Tree);


			{
			// AST REWRITE
			// elements: DECLARE, ambientElement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1727:30: -> ^( DECLARE ambientElement )
			{
				DebugLocation(1727, 33);
				// TypeScript.g3:1727:33: ^( DECLARE ambientElement )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1727, 35);
				root_1 = (object)adaptor.BecomeRoot(stream_DECLARE.NextNode(), root_1);

				DebugLocation(1727, 43);
				adaptor.AddChild(root_1, stream_ambientElement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ambientDeclaration", 134);
			LeaveRule("ambientDeclaration", 134);
			LeaveRule_ambientDeclaration();
		}
		DebugLocation(1728, 4);
		} finally { DebugExitRule(GrammarFileName, "ambientDeclaration"); }
		return retval;

	}
	// $ANTLR end "ambientDeclaration"

	partial void EnterRule_ambientElement();
	partial void LeaveRule_ambientElement();
	// $ANTLR start "ambientElement"
	// TypeScript.g3:1730:1: ambientElement : ( interfaceDeclaration | ambientClassDeclaration | moduleDeclaration | importDeclaration | enumDeclaration | variableStatement | ambientFunctionDeclaration );
	[GrammarRule("ambientElement")]
	private AstParserRuleReturnScope<object, IToken> ambientElement()
	{
		EnterRule_ambientElement();
		EnterRule("ambientElement", 135);
		TraceIn("ambientElement", 135);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> interfaceDeclaration544 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ambientClassDeclaration545 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> moduleDeclaration546 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> importDeclaration547 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enumDeclaration548 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableStatement549 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ambientFunctionDeclaration550 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "ambientElement");
		DebugLocation(1730, 4);
		try
		{
			// TypeScript.g3:1731:5: ( interfaceDeclaration | ambientClassDeclaration | moduleDeclaration | importDeclaration | enumDeclaration | variableStatement | ambientFunctionDeclaration )
			int alt158=7;
			try { DebugEnterDecision(158, false);
			switch (input.LA(1))
			{
			case INTERFACE:
				{
				alt158 = 1;
				}
				break;
			case CLASS:
				{
				alt158 = 2;
				}
				break;
			case MODULE:
				{
				alt158 = 3;
				}
				break;
			case IMPORT:
				{
				alt158 = 4;
				}
				break;
			case CONST:
			case ENUM:
				{
				alt158 = 5;
				}
				break;
			case VAR:
				{
				alt158 = 6;
				}
				break;
			case FUNCTION:
				{
				alt158 = 7;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 158, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(158); }
			switch (alt158)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1731:7: interfaceDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1731, 7);
				PushFollow(Follow._interfaceDeclaration_in_ambientElement9503);
				interfaceDeclaration544=interfaceDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interfaceDeclaration544.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScript.g3:1732:7: ambientClassDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1732, 7);
				PushFollow(Follow._ambientClassDeclaration_in_ambientElement9511);
				ambientClassDeclaration545=ambientClassDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ambientClassDeclaration545.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScript.g3:1733:7: moduleDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1733, 7);
				PushFollow(Follow._moduleDeclaration_in_ambientElement9519);
				moduleDeclaration546=moduleDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, moduleDeclaration546.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScript.g3:1734:7: importDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1734, 7);
				PushFollow(Follow._importDeclaration_in_ambientElement9527);
				importDeclaration547=importDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, importDeclaration547.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScript.g3:1735:7: enumDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1735, 7);
				PushFollow(Follow._enumDeclaration_in_ambientElement9535);
				enumDeclaration548=enumDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, enumDeclaration548.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScript.g3:1736:7: variableStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1736, 7);
				PushFollow(Follow._variableStatement_in_ambientElement9543);
				variableStatement549=variableStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableStatement549.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// TypeScript.g3:1737:7: ambientFunctionDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1737, 7);
				PushFollow(Follow._ambientFunctionDeclaration_in_ambientElement9551);
				ambientFunctionDeclaration550=ambientFunctionDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ambientFunctionDeclaration550.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ambientElement", 135);
			LeaveRule("ambientElement", 135);
			LeaveRule_ambientElement();
		}
		DebugLocation(1738, 4);
		} finally { DebugExitRule(GrammarFileName, "ambientElement"); }
		return retval;

	}
	// $ANTLR end "ambientElement"

	partial void EnterRule_ambientClassDeclaration();
	partial void LeaveRule_ambientClassDeclaration();
	// $ANTLR start "ambientClassDeclaration"
	// TypeScript.g3:1740:1: ambientClassDeclaration : CLASS identifier ( typeParameters )? ( extendsClause )? LBRACE ( typeMember semic )* RBRACE -> ^( CLASS identifier ( typeParameters )? ( extendsClause )? ( typeMember )* ) ;
	[GrammarRule("ambientClassDeclaration")]
	private AstParserRuleReturnScope<object, IToken> ambientClassDeclaration()
	{
		EnterRule_ambientClassDeclaration();
		EnterRule("ambientClassDeclaration", 136);
		TraceIn("ambientClassDeclaration", 136);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CLASS551 = default(IToken);
		IToken LBRACE555 = default(IToken);
		IToken RBRACE558 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier552 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeParameters553 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> extendsClause554 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeMember556 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic557 = default(AstParserRuleReturnScope<object, IToken>);

		object CLASS551_tree = default(object);
		object LBRACE555_tree = default(object);
		object RBRACE558_tree = default(object);
		RewriteRuleITokenStream stream_CLASS=new RewriteRuleITokenStream(adaptor,"token CLASS");
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_typeParameters=new RewriteRuleSubtreeStream(adaptor,"rule typeParameters");
		RewriteRuleSubtreeStream stream_extendsClause=new RewriteRuleSubtreeStream(adaptor,"rule extendsClause");
		RewriteRuleSubtreeStream stream_typeMember=new RewriteRuleSubtreeStream(adaptor,"rule typeMember");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		try { DebugEnterRule(GrammarFileName, "ambientClassDeclaration");
		DebugLocation(1740, 1);
		try
		{
			// TypeScript.g3:1741:2: ( CLASS identifier ( typeParameters )? ( extendsClause )? LBRACE ( typeMember semic )* RBRACE -> ^( CLASS identifier ( typeParameters )? ( extendsClause )? ( typeMember )* ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1741:4: CLASS identifier ( typeParameters )? ( extendsClause )? LBRACE ( typeMember semic )* RBRACE
			{
			DebugLocation(1741, 4);
			CLASS551=(IToken)Match(input,CLASS,Follow._CLASS_in_ambientClassDeclaration9565); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CLASS.Add(CLASS551);

			DebugLocation(1741, 10);
			PushFollow(Follow._identifier_in_ambientClassDeclaration9567);
			identifier552=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier552.Tree);
			DebugLocation(1741, 21);
			// TypeScript.g3:1741:21: ( typeParameters )?
			int alt159=2;
			try { DebugEnterSubRule(159);
			try { DebugEnterDecision(159, false);
			int LA159_1 = input.LA(1);

			if ((LA159_1==LT))
			{
				alt159 = 1;
			}
			} finally { DebugExitDecision(159); }
			switch (alt159)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1741:21: typeParameters
				{
				DebugLocation(1741, 21);
				PushFollow(Follow._typeParameters_in_ambientClassDeclaration9569);
				typeParameters553=typeParameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeParameters.Add(typeParameters553.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(159); }

			DebugLocation(1741, 37);
			// TypeScript.g3:1741:37: ( extendsClause )?
			int alt160=2;
			try { DebugEnterSubRule(160);
			try { DebugEnterDecision(160, false);
			int LA160_1 = input.LA(1);

			if ((LA160_1==EXTENDS))
			{
				alt160 = 1;
			}
			} finally { DebugExitDecision(160); }
			switch (alt160)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1741:37: extendsClause
				{
				DebugLocation(1741, 37);
				PushFollow(Follow._extendsClause_in_ambientClassDeclaration9572);
				extendsClause554=extendsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_extendsClause.Add(extendsClause554.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(160); }

			DebugLocation(1741, 52);
			LBRACE555=(IToken)Match(input,LBRACE,Follow._LBRACE_in_ambientClassDeclaration9575); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACE.Add(LBRACE555);

			DebugLocation(1741, 59);
			// TypeScript.g3:1741:59: ( typeMember semic )*
			try { DebugEnterSubRule(161);
			while (true)
			{
				int alt161=2;
				try { DebugEnterDecision(161, false);
				int LA161_1 = input.LA(1);

				if ((LA161_1==ANY||LA161_1==CONSTRUCTOR||LA161_1==DECLARE||LA161_1==DecimalLiteral||LA161_1==FINAL||LA161_1==GET||LA161_1==HexIntegerLiteral||LA161_1==Identifier||LA161_1==LBRACK||LA161_1==LPAREN||LA161_1==LT||LA161_1==MODULE||LA161_1==NEW||LA161_1==NUMBER||LA161_1==OctalIntegerLiteral||LA161_1==REQUIRE||LA161_1==SET||LA161_1==STRING||LA161_1==StringLiteral||LA161_1==THROWS||LA161_1==TYPE))
				{
					alt161 = 1;
				}


				} finally { DebugExitDecision(161); }
				switch ( alt161 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScript.g3:1741:60: typeMember semic
					{
					DebugLocation(1741, 60);
					PushFollow(Follow._typeMember_in_ambientClassDeclaration9578);
					typeMember556=typeMember();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_typeMember.Add(typeMember556.Tree);
					DebugLocation(1741, 71);
					PushFollow(Follow._semic_in_ambientClassDeclaration9580);
					semic557=semic();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_semic.Add(semic557.Tree);

					}
					break;

				default:
					goto loop161;
				}
			}

			loop161:
				;

			} finally { DebugExitSubRule(161); }

			DebugLocation(1741, 79);
			RBRACE558=(IToken)Match(input,RBRACE,Follow._RBRACE_in_ambientClassDeclaration9584); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACE.Add(RBRACE558);



			{
			// AST REWRITE
			// elements: CLASS, identifier, typeParameters, extendsClause, typeMember
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1741:86: -> ^( CLASS identifier ( typeParameters )? ( extendsClause )? ( typeMember )* )
			{
				DebugLocation(1741, 89);
				// TypeScript.g3:1741:89: ^( CLASS identifier ( typeParameters )? ( extendsClause )? ( typeMember )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1741, 91);
				root_1 = (object)adaptor.BecomeRoot(stream_CLASS.NextNode(), root_1);

				DebugLocation(1741, 97);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(1741, 108);
				// TypeScript.g3:1741:108: ( typeParameters )?
				if (stream_typeParameters.HasNext)
				{
					DebugLocation(1741, 108);
					adaptor.AddChild(root_1, stream_typeParameters.NextTree());

				}
				stream_typeParameters.Reset();
				DebugLocation(1741, 124);
				// TypeScript.g3:1741:124: ( extendsClause )?
				if (stream_extendsClause.HasNext)
				{
					DebugLocation(1741, 124);
					adaptor.AddChild(root_1, stream_extendsClause.NextTree());

				}
				stream_extendsClause.Reset();
				DebugLocation(1741, 139);
				// TypeScript.g3:1741:139: ( typeMember )*
				while ( stream_typeMember.HasNext )
				{
					DebugLocation(1741, 139);
					adaptor.AddChild(root_1, stream_typeMember.NextTree());

				}
				stream_typeMember.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ambientClassDeclaration", 136);
			LeaveRule("ambientClassDeclaration", 136);
			LeaveRule_ambientClassDeclaration();
		}
		DebugLocation(1742, 1);
		} finally { DebugExitRule(GrammarFileName, "ambientClassDeclaration"); }
		return retval;

	}
	// $ANTLR end "ambientClassDeclaration"

	partial void EnterRule_ambientFunctionDeclaration();
	partial void LeaveRule_ambientFunctionDeclaration();
	// $ANTLR start "ambientFunctionDeclaration"
	// TypeScript.g3:1745:1: ambientFunctionDeclaration : FUNCTION name= identifier ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? semic -> ^( AMBIENTFUNCTION $name ( typeParameters )? ( parameterList )? ( typeAnnotation )? ) ;
	[GrammarRule("ambientFunctionDeclaration")]
	private AstParserRuleReturnScope<object, IToken> ambientFunctionDeclaration()
	{
		EnterRule_ambientFunctionDeclaration();
		EnterRule("ambientFunctionDeclaration", 137);
		TraceIn("ambientFunctionDeclaration", 137);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FUNCTION559 = default(IToken);
		IToken LPAREN561 = default(IToken);
		IToken RPAREN563 = default(IToken);
		AstParserRuleReturnScope<object, IToken> name = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeParameters560 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parameterList562 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typeAnnotation564 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic565 = default(AstParserRuleReturnScope<object, IToken>);

		object FUNCTION559_tree = default(object);
		object LPAREN561_tree = default(object);
		object RPAREN563_tree = default(object);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_typeParameters=new RewriteRuleSubtreeStream(adaptor,"rule typeParameters");
		RewriteRuleSubtreeStream stream_parameterList=new RewriteRuleSubtreeStream(adaptor,"rule parameterList");
		RewriteRuleSubtreeStream stream_typeAnnotation=new RewriteRuleSubtreeStream(adaptor,"rule typeAnnotation");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		try { DebugEnterRule(GrammarFileName, "ambientFunctionDeclaration");
		DebugLocation(1745, 1);
		try
		{
			// TypeScript.g3:1746:2: ( FUNCTION name= identifier ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? semic -> ^( AMBIENTFUNCTION $name ( typeParameters )? ( parameterList )? ( typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScript.g3:1746:4: FUNCTION name= identifier ( typeParameters )? LPAREN ( parameterList )? RPAREN ( typeAnnotation )? semic
			{
			DebugLocation(1746, 4);
			FUNCTION559=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_ambientFunctionDeclaration9613); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION559);

			DebugLocation(1746, 17);
			PushFollow(Follow._identifier_in_ambientFunctionDeclaration9617);
			name=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(name.Tree);
			DebugLocation(1746, 29);
			// TypeScript.g3:1746:29: ( typeParameters )?
			int alt162=2;
			try { DebugEnterSubRule(162);
			try { DebugEnterDecision(162, false);
			int LA162_1 = input.LA(1);

			if ((LA162_1==LT))
			{
				alt162 = 1;
			}
			} finally { DebugExitDecision(162); }
			switch (alt162)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1746:29: typeParameters
				{
				DebugLocation(1746, 29);
				PushFollow(Follow._typeParameters_in_ambientFunctionDeclaration9619);
				typeParameters560=typeParameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeParameters.Add(typeParameters560.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(162); }

			DebugLocation(1746, 45);
			LPAREN561=(IToken)Match(input,LPAREN,Follow._LPAREN_in_ambientFunctionDeclaration9622); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN561);

			DebugLocation(1746, 52);
			// TypeScript.g3:1746:52: ( parameterList )?
			int alt163=2;
			try { DebugEnterSubRule(163);
			try { DebugEnterDecision(163, false);
			int LA163_1 = input.LA(1);

			if ((LA163_1==ANY||LA163_1==CONSTRUCTOR||LA163_1==DECLARE||LA163_1==ELLIPSIS||LA163_1==FINAL||LA163_1==GET||LA163_1==Identifier||LA163_1==MODULE||LA163_1==NUMBER||LA163_1==PRIVATE||LA163_1==PROTECTED||LA163_1==PUBLIC||LA163_1==REQUIRE||LA163_1==SET||LA163_1==STRING||LA163_1==THROWS||LA163_1==TYPE))
			{
				alt163 = 1;
			}
			} finally { DebugExitDecision(163); }
			switch (alt163)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1746:52: parameterList
				{
				DebugLocation(1746, 52);
				PushFollow(Follow._parameterList_in_ambientFunctionDeclaration9624);
				parameterList562=parameterList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterList.Add(parameterList562.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(163); }

			DebugLocation(1746, 67);
			RPAREN563=(IToken)Match(input,RPAREN,Follow._RPAREN_in_ambientFunctionDeclaration9627); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN563);

			DebugLocation(1746, 74);
			// TypeScript.g3:1746:74: ( typeAnnotation )?
			int alt164=2;
			try { DebugEnterSubRule(164);
			try { DebugEnterDecision(164, false);
			int LA164_1 = input.LA(1);

			if ((LA164_1==COLON))
			{
				alt164 = 1;
			}
			} finally { DebugExitDecision(164); }
			switch (alt164)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScript.g3:1746:74: typeAnnotation
				{
				DebugLocation(1746, 74);
				PushFollow(Follow._typeAnnotation_in_ambientFunctionDeclaration9629);
				typeAnnotation564=typeAnnotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeAnnotation.Add(typeAnnotation564.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(164); }

			DebugLocation(1746, 90);
			PushFollow(Follow._semic_in_ambientFunctionDeclaration9632);
			semic565=semic();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semic.Add(semic565.Tree);


			{
			// AST REWRITE
			// elements: name, typeParameters, parameterList, typeAnnotation
			// token labels: 
			// rule labels: name, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name",name!=null?name.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1747:2: -> ^( AMBIENTFUNCTION $name ( typeParameters )? ( parameterList )? ( typeAnnotation )? )
			{
				DebugLocation(1747, 5);
				// TypeScript.g3:1747:5: ^( AMBIENTFUNCTION $name ( typeParameters )? ( parameterList )? ( typeAnnotation )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1747, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(AMBIENTFUNCTION, "AMBIENTFUNCTION"), root_1);

				DebugLocation(1747, 25);
				adaptor.AddChild(root_1, stream_name.NextTree());
				DebugLocation(1747, 30);
				// TypeScript.g3:1747:30: ( typeParameters )?
				if (stream_typeParameters.HasNext)
				{
					DebugLocation(1747, 30);
					adaptor.AddChild(root_1, stream_typeParameters.NextTree());

				}
				stream_typeParameters.Reset();
				DebugLocation(1747, 46);
				// TypeScript.g3:1747:46: ( parameterList )?
				if (stream_parameterList.HasNext)
				{
					DebugLocation(1747, 46);
					adaptor.AddChild(root_1, stream_parameterList.NextTree());

				}
				stream_parameterList.Reset();
				DebugLocation(1747, 61);
				// TypeScript.g3:1747:61: ( typeAnnotation )?
				if (stream_typeAnnotation.HasNext)
				{
					DebugLocation(1747, 61);
					adaptor.AddChild(root_1, stream_typeAnnotation.NextTree());

				}
				stream_typeAnnotation.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ambientFunctionDeclaration", 137);
			LeaveRule("ambientFunctionDeclaration", 137);
			LeaveRule_ambientFunctionDeclaration();
		}
		DebugLocation(1748, 1);
		} finally { DebugExitRule(GrammarFileName, "ambientFunctionDeclaration"); }
		return retval;

	}
	// $ANTLR end "ambientFunctionDeclaration"

	partial void EnterRule_synpred1_TypeScript_fragment();
	partial void LeaveRule_synpred1_TypeScript_fragment();

	// $ANTLR start synpred1_TypeScript
	public void synpred1_TypeScript_fragment()
	{
		EnterRule_synpred1_TypeScript_fragment();
		EnterRule("synpred1_TypeScript_fragment", 138);
		TraceIn("synpred1_TypeScript_fragment", 138);
		try
		{
			// TypeScript.g3:1412:7: ( predefinedType )
			DebugEnterAlt(1);
			// TypeScript.g3:1412:7: predefinedType
			{
			DebugLocation(1412, 7);
			PushFollow(Follow._predefinedType_in_synpred1_TypeScript7440);
			predefinedType();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_TypeScript_fragment", 138);
			LeaveRule("synpred1_TypeScript_fragment", 138);
			LeaveRule_synpred1_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred1_TypeScript

	partial void EnterRule_synpred2_TypeScript_fragment();
	partial void LeaveRule_synpred2_TypeScript_fragment();

	// $ANTLR start synpred2_TypeScript
	public void synpred2_TypeScript_fragment()
	{
		EnterRule_synpred2_TypeScript_fragment();
		EnterRule("synpred2_TypeScript_fragment", 139);
		TraceIn("synpred2_TypeScript_fragment", 139);
		try
		{
			// TypeScript.g3:1413:7: ( typeReference )
			DebugEnterAlt(1);
			// TypeScript.g3:1413:7: typeReference
			{
			DebugLocation(1413, 7);
			PushFollow(Follow._typeReference_in_synpred2_TypeScript7448);
			typeReference();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_TypeScript_fragment", 139);
			LeaveRule("synpred2_TypeScript_fragment", 139);
			LeaveRule_synpred2_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred2_TypeScript
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA45 dfa45;
	private DFA52 dfa52;
	private DFA94 dfa94;
	private DFA132 dfa132;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa45 = new DFA45( this );
		dfa52 = new DFA52( this, SpecialStateTransition52 );
		dfa94 = new DFA94( this );
		dfa132 = new DFA132( this );
	}

	private class DFA45 : DFA
	{
		private const string DFA45_eotS =
			"\x54\xFFFF";
		private const string DFA45_eofS =
			"\x4\xFFFF\x2\x3\x4E\xFFFF";
		private const string DFA45_minS =
			"\x1\x5\x3\xFFFF\x2\x5\x4E\xFFFF";
		private const string DFA45_maxS =
			"\x1\xCA\x3\xFFFF\x2\xCD\x4E\xFFFF";
		private const string DFA45_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x15\xFFFF\x1\x4\x1\x5\x2\xFFFF\x1\x6\x1\x7"+
			"\x1\x8\x1\x9\x1\xB\x1\xC\x1\xD\x17\xFFFF\x1\xA\x18\xFFFF";
		private const string DFA45_specialS =
			"\x54\xFFFF}>";
		private static readonly string[] DFA45_transitionS =
			{
				"\x1\x3\x4\xFFFF\x1\x4\x8\xFFFF\x1\x1E\xF\xFFFF\x1\x4\x3\xFFFF\x1\x1D"+
				"\x2\xFFFF\x1\x3\x1\x4\x1\xFFFF\x1\x3\x2\xFFFF\x1\x1A\x5\xFFFF\x1\x3"+
				"\xA\xFFFF\x1\x3\x1\xFFFF\x1\x4\x2\xFFFF\x1\x1A\x2\xFFFF\x1\x3\x3\xFFFF"+
				"\x1\x4\x5\xFFFF\x1\x3\x1\x19\x3\xFFFF\x1\x3\x5\xFFFF\x1\x3\x1\xFFFF"+
				"\x1\x5\x5\xFFFF\x2\x3\x3\xFFFF\x1\x3\x8\xFFFF\x1\x4\x8\xFFFF\x2\x3\x1"+
				"\xFFFF\x1\x3\x1\x4\x6\xFFFF\x1\x3\x11\xFFFF\x1\x4\x1\x1F\x3\xFFFF\x1"+
				"\x3\x1\xFFFF\x1\x2\x1\x4\xA\xFFFF\x1\x4\x1\x3\x2\xFFFF\x1\x21\x2\xFFFF"+
				"\x1\x3\x1\xFFFF\x1\x3\x1\x22\x1\x4\x1\xFFFF\x1\x3\x1\x23\x1\xFFFF\x1"+
				"\x4\x1\x3\x5\xFFFF\x1\x1\x1\xFFFF\x1\x3\x2\xFFFF\x1\x1A\x1\x20",
				"",
				"",
				"",
				"\x2\x3\x1\xFFFF\x2\x3\x5\xFFFF\x1\x3\x10\xFFFF\x1\x3B\x1\x3\x8\xFFFF"+
				"\x1\x3\x3\xFFFF\x2\x3\x1\xFFFF\x1\x3\x8\xFFFF\x2\x3\x13\xFFFF\x2\x3"+
				"\x6\xFFFF\x2\x3\x2\xFFFF\x1\x3\x9\xFFFF\x1\x3\x1\xFFFF\x1\x3\x2\xFFFF"+
				"\x2\x3\x1\xFFFF\x2\x3\x3\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x1\x3\x2"+
				"\xFFFF\x1\x3\x4\xFFFF\x2\x3\x11\xFFFF\x2\x3\x7\xFFFF\x2\x3\x1\xFFFF"+
				"\x2\x3\x1\xFFFF\x4\x3\x4\xFFFF\x2\x3\x1C\xFFFF\x2\x3",
				"\x2\x3\x1\xFFFF\x2\x3\x5\xFFFF\x1\x3\x10\xFFFF\x1\x3B\x1\x3\x8\xFFFF"+
				"\x1\x3\x3\xFFFF\x2\x3\x1\xFFFF\x1\x3\x8\xFFFF\x2\x3\x13\xFFFF\x2\x3"+
				"\x6\xFFFF\x2\x3\x2\xFFFF\x1\x3\x9\xFFFF\x1\x3\x1\xFFFF\x1\x3\x2\xFFFF"+
				"\x2\x3\x1\xFFFF\x2\x3\x3\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x1\x3\x2"+
				"\xFFFF\x1\x3\x4\xFFFF\x2\x3\x11\xFFFF\x2\x3\x7\xFFFF\x2\x3\x1\xFFFF"+
				"\x2\x3\x1\xFFFF\x4\x3\x4\xFFFF\x2\x3\x1C\xFFFF\x2\x3",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA45_eot = DFA.UnpackEncodedString(DFA45_eotS);
		private static readonly short[] DFA45_eof = DFA.UnpackEncodedString(DFA45_eofS);
		private static readonly char[] DFA45_min = DFA.UnpackEncodedStringToUnsignedChars(DFA45_minS);
		private static readonly char[] DFA45_max = DFA.UnpackEncodedStringToUnsignedChars(DFA45_maxS);
		private static readonly short[] DFA45_accept = DFA.UnpackEncodedString(DFA45_acceptS);
		private static readonly short[] DFA45_special = DFA.UnpackEncodedString(DFA45_specialS);
		private static readonly short[][] DFA45_transition;

		static DFA45()
		{
			int numStates = DFA45_transitionS.Length;
			DFA45_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA45_transition[i] = DFA.UnpackEncodedString(DFA45_transitionS[i]);
			}
		}

		public DFA45( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 45;
			this.eot = DFA45_eot;
			this.eof = DFA45_eof;
			this.min = DFA45_min;
			this.max = DFA45_max;
			this.accept = DFA45_accept;
			this.special = DFA45_special;
			this.transition = DFA45_transition;
		}

		public override string Description { get { return "1008:1: statementTail : ( variableStatement | emptyStatement | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA52 : DFA
	{
		private const string DFA52_eotS =
			"\x55\xFFFF";
		private const string DFA52_eofS =
			"\x1\x2\x54\xFFFF";
		private const string DFA52_minS =
			"\x1\x5\x1\x0\x53\xFFFF";
		private const string DFA52_maxS =
			"\x1\xCA\x1\x0\x53\xFFFF";
		private const string DFA52_acceptS =
			"\x2\xFFFF\x1\x2\x51\xFFFF\x1\x1";
		private const string DFA52_specialS =
			"\x1\xFFFF\x1\x0\x53\xFFFF}>";
		private static readonly string[] DFA52_transitionS =
			{
				"\x1\x2\x4\xFFFF\x1\x2\x8\xFFFF\x1\x2\x7\xFFFF\x1\x2\x3\xFFFF\x1\x2\x2"+
				"\xFFFF\x2\x2\x3\xFFFF\x1\x2\x2\xFFFF\x4\x2\x2\xFFFF\x1\x2\x5\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x1\x1\x2\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x1\xFFFF\x1\x2"+
				"\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x1\x2\x5\xFFFF\x2\x2\x1\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x4\xFFFF\x2\x2\x1\xFFFF\x1\x2\x5\xFFFF\x2\x2\x3"+
				"\xFFFF\x1\x2\x8\xFFFF\x1\x2\x8\xFFFF\x2\x2\x1\xFFFF\x2\x2\x6\xFFFF\x1"+
				"\x2\xF\xFFFF\x1\x2\x1\xFFFF\x2\x2\x3\xFFFF\x1\x2\x1\xFFFF\x2\x2\xA\xFFFF"+
				"\x2\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x3\x2\x1\xFFFF\x2\x2\x1"+
				"\xFFFF\x2\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x2\x2",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA52_eot = DFA.UnpackEncodedString(DFA52_eotS);
		private static readonly short[] DFA52_eof = DFA.UnpackEncodedString(DFA52_eofS);
		private static readonly char[] DFA52_min = DFA.UnpackEncodedStringToUnsignedChars(DFA52_minS);
		private static readonly char[] DFA52_max = DFA.UnpackEncodedStringToUnsignedChars(DFA52_maxS);
		private static readonly short[] DFA52_accept = DFA.UnpackEncodedString(DFA52_acceptS);
		private static readonly short[] DFA52_special = DFA.UnpackEncodedString(DFA52_specialS);
		private static readonly short[][] DFA52_transition;

		static DFA52()
		{
			int numStates = DFA52_transitionS.Length;
			DFA52_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA52_transition[i] = DFA.UnpackEncodedString(DFA52_transitionS[i]);
			}
		}

		public DFA52( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 52;
			this.eot = DFA52_eot;
			this.eof = DFA52_eof;
			this.min = DFA52_min;
			this.max = DFA52_max;
			this.accept = DFA52_accept;
			this.special = DFA52_special;
			this.transition = DFA52_transition;
		}

		public override string Description { get { return "1076:42: ({...}? ELSE statement )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition52(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		s = -1;
		int LA52_1 = input.LA(1);
		int index52_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				input.Rewind();
				if ((( input.LA(1) == ELSE ))) {s = 84;}

				else if ((( input.LA(1) == ELSE ))) {s = 2;}

				input.Seek(index52_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 52, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA94 : DFA
	{
		private const string DFA94_eotS =
			"\x4D\xFFFF";
		private const string DFA94_eofS =
			"\x1\xFFFF\x4\xA\x4\xFFFF\x1\xA\x8\xFFFF\x1\xA\x8\xFFFF\x1\xA\x8\xFFFF"+
			"\x1\xA\x28\xFFFF";
		private const string DFA94_minS =
			"\x1\xA\x4\x20\x4\xFFFF\x1\x20\x8\xFFFF\x1\x20\x8\xFFFF\x1\x20\x8\xFFFF"+
			"\x1\x20\x28\xFFFF";
		private const string DFA94_maxS =
			"\x1\xBD\x4\xA1\x4\xFFFF\x1\xA1\x8\xFFFF\x1\xA1\x8\xFFFF\x1\xA1\x8\xFFFF"+
			"\x1\xA1\x28\xFFFF";
		private const string DFA94_acceptS =
			"\x5\xFFFF\x1\x2\x1\xFFFF\x1\x3\x1\x4\x1\xFFFF\x1\x1\x5\xFFFF\x1\x5\x3C"+
			"\xFFFF";
		private const string DFA94_specialS =
			"\x4D\xFFFF}>";
		private static readonly string[] DFA94_transitionS =
			{
				"\x1\x1\x18\xFFFF\x1\x1\x7\xFFFF\x1\x1\xA\xFFFF\x1\x4\xC\xFFFF\x1\x1"+
				"\x9\xFFFF\x1\x1\x5\xFFFF\x1\x4\xC\xFFFF\x1\x2\x6\xFFFF\x1\x8\x3\xFFFF"+
				"\x1\x5\x1\xFFFF\x1\x5\x6\xFFFF\x1\x1\x8\xFFFF\x1\x7\x3\xFFFF\x1\x1\x6"+
				"\xFFFF\x1\x4\x11\xFFFF\x1\x1\x7\xFFFF\x1\x1\xA\xFFFF\x1\x1\x6\xFFFF"+
				"\x1\x3\x3\xFFFF\x1\x1\x4\xFFFF\x1\x1",
				"\x1\xA\x19\xFFFF\x1\xA\x30\xFFFF\x1\x10\x1\xFFFF\x1\x10\x9\xFFFF\x1"+
				"\xA\x1F\xFFFF\x1\x9\x1\xA\x8\xFFFF\x1\xA",
				"\x1\xA\x19\xFFFF\x1\xA\x30\xFFFF\x1\x10\x1\xFFFF\x1\x10\x9\xFFFF\x1"+
				"\xA\x1F\xFFFF\x1\x12\x1\xA\x8\xFFFF\x1\xA",
				"\x1\xA\x19\xFFFF\x1\xA\x30\xFFFF\x1\x10\x1\xFFFF\x1\x10\x9\xFFFF\x1"+
				"\xA\x1F\xFFFF\x1\x1B\x1\xA\x8\xFFFF\x1\xA",
				"\x1\xA\x19\xFFFF\x1\xA\x30\xFFFF\x1\x10\x1\xFFFF\x1\x10\x9\xFFFF\x1"+
				"\xA\x1F\xFFFF\x1\x24\x1\xA\x8\xFFFF\x1\xA",
				"",
				"",
				"",
				"",
				"\x1\xA\x19\xFFFF\x1\xA\x30\xFFFF\x1\x10\x1\xFFFF\x1\x10\x9\xFFFF\x1"+
				"\xA\x20\xFFFF\x1\xA\x8\xFFFF\x1\xA",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xA\x19\xFFFF\x1\xA\x30\xFFFF\x1\x10\x1\xFFFF\x1\x10\x9\xFFFF\x1"+
				"\xA\x20\xFFFF\x1\xA\x8\xFFFF\x1\xA",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xA\x19\xFFFF\x1\xA\x30\xFFFF\x1\x10\x1\xFFFF\x1\x10\x9\xFFFF\x1"+
				"\xA\x20\xFFFF\x1\xA\x8\xFFFF\x1\xA",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xA\x19\xFFFF\x1\xA\x30\xFFFF\x1\x10\x1\xFFFF\x1\x10\x9\xFFFF\x1"+
				"\xA\x20\xFFFF\x1\xA\x8\xFFFF\x1\xA",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA94_eot = DFA.UnpackEncodedString(DFA94_eotS);
		private static readonly short[] DFA94_eof = DFA.UnpackEncodedString(DFA94_eofS);
		private static readonly char[] DFA94_min = DFA.UnpackEncodedStringToUnsignedChars(DFA94_minS);
		private static readonly char[] DFA94_max = DFA.UnpackEncodedStringToUnsignedChars(DFA94_maxS);
		private static readonly short[] DFA94_accept = DFA.UnpackEncodedString(DFA94_acceptS);
		private static readonly short[] DFA94_special = DFA.UnpackEncodedString(DFA94_specialS);
		private static readonly short[][] DFA94_transition;

		static DFA94()
		{
			int numStates = DFA94_transitionS.Length;
			DFA94_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA94_transition[i] = DFA.UnpackEncodedString(DFA94_transitionS[i]);
			}
		}

		public DFA94( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 94;
			this.eot = DFA94_eot;
			this.eof = DFA94_eof;
			this.min = DFA94_min;
			this.max = DFA94_max;
			this.accept = DFA94_accept;
			this.special = DFA94_special;
			this.transition = DFA94_transition;
		}

		public override string Description { get { return "1475:1: typeMember : ( propertySignature | callSignature | constructSignature | indexSignature | methodSignature );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA132 : DFA
	{
		private const string DFA132_eotS =
			"\xE8\xFFFF";
		private const string DFA132_eofS =
			"\x3\xFFFF\x5\x15\x2\xFFFF\x9\x15\x31\xFFFF\x4\x15\x5D\xFFFF\x1\xE2\x42"+
			"\xFFFF";
		private const string DFA132_minS =
			"\x5\xA\x3\xF\x1\xFFFF\x3\xA\x3\xF\x2\xA\x2\xF\x16\xFFFF\x1\xA\x1A\xFFFF"+
			"\x2\xA\x2\xF\x16\xFFFF\x1\xA\x42\xFFFF\x1\xA\x2\xF\x1\xA\x1\x20\x42\xFFFF";
		private const string DFA132_maxS =
			"\x5\xBD\x3\xA1\x1\xFFFF\x3\xBD\x3\xA1\x2\xBD\x2\xA1\x16\xFFFF\x1\xBD"+
			"\x1A\xFFFF\x2\xBD\x2\xA1\x16\xFFFF\x1\xBD\x42\xFFFF\x1\xBD\x2\x9C\x1"+
			"\xBD\x1\xA1\x42\xFFFF";
		private const string DFA132_acceptS =
			"\x8\xFFFF\x1\x6\xA\xFFFF\x1\x1\x1\xFFFF\x1\x4\x6\xFFFF\x1\x5\x1\xFFFF"+
			"\x1\x2\xAF\xFFFF\x19\x3\x1\xFFFF";
		private const string DFA132_specialS =
			"\xE8\xFFFF}>";
		private static readonly string[] DFA132_transitionS =
			{
				"\x1\x6\x18\xFFFF\x1\x5\x7\xFFFF\x1\x6\x17\xFFFF\x1\x6\x9\xFFFF\x1\x3"+
				"\x12\xFFFF\x1\x7\x6\xFFFF\x1\x8\xC\xFFFF\x1\x6\xC\xFFFF\x1\x6\x10\xFFFF"+
				"\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x3\xFFFF\x1\x6\x7\xFFFF\x1\x4\x9"+
				"\xFFFF\x1\x2\x1\x6\xA\xFFFF\x1\x6\x4\xFFFF\x1\x6",
				"\x1\xD\x18\xFFFF\x1\xC\x7\xFFFF\x1\xD\x17\xFFFF\x1\xD\x9\xFFFF\x1\xA"+
				"\x12\xFFFF\x1\xE\x13\xFFFF\x1\xD\xC\xFFFF\x1\xD\x18\xFFFF\x1\xD\x7\xFFFF"+
				"\x1\xB\x9\xFFFF\x1\x9\x1\xD\xA\xFFFF\x1\xD\x4\xFFFF\x1\xD",
				"\x1\x11\x18\xFFFF\x1\x11\x7\xFFFF\x1\x11\x17\xFFFF\x1\x11\x9\xFFFF\x1"+
				"\xF\x12\xFFFF\x1\x12\x13\xFFFF\x1\x11\xC\xFFFF\x1\x11\x18\xFFFF\x1\x11"+
				"\x7\xFFFF\x1\x10\xA\xFFFF\x1\x11\xA\xFFFF\x1\x11\x4\xFFFF\x1\x11",
				"\x1\x13\x4\xFFFF\x1\x15\x10\xFFFF\x1\x15\x2\xFFFF\x1\x13\x7\xFFFF\x1"+
				"\x13\xE\xFFFF\x1\x15\x8\xFFFF\x1\x13\x9\xFFFF\x1\x13\x12\xFFFF\x1\x13"+
				"\xA\xFFFF\x1\x1C\x1\xFFFF\x1\x1C\x6\xFFFF\x1\x13\x2\xFFFF\x1\x15\x9"+
				"\xFFFF\x1\x13\x16\xFFFF\x1\x15\x1\xFFFF\x1\x13\x6\xFFFF\x1\x15\x1\x13"+
				"\xA\xFFFF\x1\x13\xA\xFFFF\x1\x13\x4\xFFFF\x1\x13",
				"\x1\x1E\x4\xFFFF\x1\x15\x10\xFFFF\x1\x15\x2\xFFFF\x1\x1E\x7\xFFFF\x1"+
				"\x1E\xE\xFFFF\x1\x15\x8\xFFFF\x1\x1E\x9\xFFFF\x1\x1E\x12\xFFFF\x1\x1E"+
				"\xA\xFFFF\x1\x1C\x1\xFFFF\x1\x1C\x6\xFFFF\x1\x1E\x2\xFFFF\x1\x15\x9"+
				"\xFFFF\x1\x1E\x16\xFFFF\x1\x15\x1\xFFFF\x1\x1E\x6\xFFFF\x1\x15\x1\x1E"+
				"\xA\xFFFF\x1\x1E\xA\xFFFF\x1\x1E\x4\xFFFF\x1\x1E",
				"\x1\x15\x10\xFFFF\x1\x15\x19\xFFFF\x1\x15\x30\xFFFF\x1\x29\x1\xFFFF"+
				"\x1\x1C\x9\xFFFF\x1\x15\x20\xFFFF\x1\x15\x8\xFFFF\x1\x15",
				"\x1\x15\x10\xFFFF\x1\x15\x19\xFFFF\x1\x15\x30\xFFFF\x1\x1C\x1\xFFFF"+
				"\x1\x1C\x9\xFFFF\x1\x15\x20\xFFFF\x1\x15\x8\xFFFF\x1\x15",
				"\x1\x15\x10\xFFFF\x1\x15\x19\xFFFF\x1\x15\x30\xFFFF\x1\x1C\x1\xFFFF"+
				"\x1\x1C\x9\xFFFF\x1\x15\x20\xFFFF\x1\x15\x8\xFFFF\x1\x15",
				"",
				"\x1\x46\x18\xFFFF\x1\x46\x7\xFFFF\x1\x46\x17\xFFFF\x1\x46\x9\xFFFF\x1"+
				"\x44\x12\xFFFF\x1\x47\x13\xFFFF\x1\x46\xC\xFFFF\x1\x46\x18\xFFFF\x1"+
				"\x46\x7\xFFFF\x1\x45\xA\xFFFF\x1\x46\xA\xFFFF\x1\x46\x4\xFFFF\x1\x46",
				"\x1\x13\x4\xFFFF\x1\x15\x10\xFFFF\x1\x15\x2\xFFFF\x1\x13\x7\xFFFF\x1"+
				"\x13\xE\xFFFF\x1\x15\x8\xFFFF\x1\x13\x9\xFFFF\x1\x13\x12\xFFFF\x1\x13"+
				"\xA\xFFFF\x1\x1C\x1\xFFFF\x1\x1C\x6\xFFFF\x1\x13\x2\xFFFF\x1\x15\x9"+
				"\xFFFF\x1\x13\x16\xFFFF\x1\x15\x1\xFFFF\x1\x13\x6\xFFFF\x1\x15\x1\x13"+
				"\xA\xFFFF\x1\x13\xA\xFFFF\x1\x13\x4\xFFFF\x1\x13",
				"\x1\x1E\x4\xFFFF\x1\x15\x10\xFFFF\x1\x15\x2\xFFFF\x1\x1E\x7\xFFFF\x1"+
				"\x1E\xE\xFFFF\x1\x15\x8\xFFFF\x1\x1E\x9\xFFFF\x1\x1E\x12\xFFFF\x1\x1E"+
				"\xA\xFFFF\x1\x1C\x1\xFFFF\x1\x1C\x6\xFFFF\x1\x1E\x2\xFFFF\x1\x15\x9"+
				"\xFFFF\x1\x1E\x16\xFFFF\x1\x15\x1\xFFFF\x1\x1E\x6\xFFFF\x1\x15\x1\x1E"+
				"\xA\xFFFF\x1\x1E\xA\xFFFF\x1\x1E\x4\xFFFF\x1\x1E",
				"\x1\x15\x10\xFFFF\x1\x15\x19\xFFFF\x1\x15\x30\xFFFF\x1\x5E\x1\xFFFF"+
				"\x1\x1C\x9\xFFFF\x1\x15\x20\xFFFF\x1\x15\x8\xFFFF\x1\x15",
				"\x1\x15\x10\xFFFF\x1\x15\x19\xFFFF\x1\x15\x30\xFFFF\x1\x1C\x1\xFFFF"+
				"\x1\x1C\x9\xFFFF\x1\x15\x20\xFFFF\x1\x15\x8\xFFFF\x1\x15",
				"\x1\x15\x10\xFFFF\x1\x15\x19\xFFFF\x1\x15\x30\xFFFF\x1\x1C\x1\xFFFF"+
				"\x1\x1C\x9\xFFFF\x1\x15\x20\xFFFF\x1\x15\x8\xFFFF\x1\x15",
				"\x1\x13\x4\xFFFF\x1\x15\x10\xFFFF\x1\x15\x2\xFFFF\x1\x13\x7\xFFFF\x1"+
				"\x13\xE\xFFFF\x1\x15\x8\xFFFF\x1\x13\x9\xFFFF\x1\x13\x12\xFFFF\x1\x13"+
				"\xA\xFFFF\x1\x1C\x1\xFFFF\x1\x1C\x6\xFFFF\x1\x13\x2\xFFFF\x1\x15\x9"+
				"\xFFFF\x1\x13\x16\xFFFF\x1\x15\x1\xFFFF\x1\x13\x6\xFFFF\x1\x15\x1\x13"+
				"\xA\xFFFF\x1\x13\xA\xFFFF\x1\x13\x4\xFFFF\x1\x13",
				"\x1\x1E\x4\xFFFF\x1\x15\x10\xFFFF\x1\x15\x2\xFFFF\x1\x1E\x7\xFFFF\x1"+
				"\x1E\xE\xFFFF\x1\x15\x8\xFFFF\x1\x1E\x9\xFFFF\x1\x1E\x12\xFFFF\x1\x1E"+
				"\xA\xFFFF\x1\x1C\x1\xFFFF\x1\x1C\x6\xFFFF\x1\x1E\x2\xFFFF\x1\x15\x9"+
				"\xFFFF\x1\x1E\x16\xFFFF\x1\x15\x1\xFFFF\x1\x1E\x6\xFFFF\x1\x15\x1\x1E"+
				"\xA\xFFFF\x1\x1E\xA\xFFFF\x1\x1E\x4\xFFFF\x1\x1E",
				"\x1\x15\x10\xFFFF\x1\x15\x19\xFFFF\x1\x15\x30\xFFFF\x1\x1C\x1\xFFFF"+
				"\x1\x1C\x9\xFFFF\x1\x15\x20\xFFFF\x1\x15\x8\xFFFF\x1\x15",
				"\x1\x15\x10\xFFFF\x1\x15\x19\xFFFF\x1\x15\x30\xFFFF\x1\x1C\x1\xFFFF"+
				"\x1\x1C\x9\xFFFF\x1\x15\x20\xFFFF\x1\x15\x8\xFFFF\x1\x15",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xA2\x18\xFFFF\x1\xA2\x7\xFFFF\x1\xA2\xB\xFFFF\x1\xA4\xB\xFFFF\x1"+
				"\xA2\x9\xFFFF\x1\xA2\x12\xFFFF\x1\xA3\x13\xFFFF\x1\xA2\xC\xFFFF\x1\xA2"+
				"\x10\xFFFF\x1\xA1\x1\xFFFF\x1\xA1\x1\xFFFF\x1\xA1\x3\xFFFF\x1\xA2\x1"+
				"\xFFFF\x1\xA5\x5\xFFFF\x1\xA2\xA\xFFFF\x1\xA2\xA\xFFFF\x1\xA2\x4\xFFFF"+
				"\x1\xA2",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x13\x4\xFFFF\x1\x15\x10\xFFFF\x1\x15\x2\xFFFF\x1\x13\x7\xFFFF\x1"+
				"\x13\xE\xFFFF\x1\x15\x8\xFFFF\x1\x13\x9\xFFFF\x1\x13\x12\xFFFF\x1\x13"+
				"\xA\xFFFF\x1\x1C\x1\xFFFF\x1\x1C\x6\xFFFF\x1\x13\x2\xFFFF\x1\x15\x9"+
				"\xFFFF\x1\x13\x16\xFFFF\x1\x15\x1\xFFFF\x1\x13\x6\xFFFF\x1\x15\x1\x13"+
				"\xA\xFFFF\x1\x13\xA\xFFFF\x1\x13\x4\xFFFF\x1\x13",
				"\x1\x1E\x4\xFFFF\x1\x15\x10\xFFFF\x1\x15\x2\xFFFF\x1\x1E\x7\xFFFF\x1"+
				"\x1E\xE\xFFFF\x1\x15\x8\xFFFF\x1\x1E\x9\xFFFF\x1\x1E\x12\xFFFF\x1\x1E"+
				"\xA\xFFFF\x1\x1C\x1\xFFFF\x1\x1C\x6\xFFFF\x1\x1E\x2\xFFFF\x1\x15\x9"+
				"\xFFFF\x1\x1E\x16\xFFFF\x1\x15\x1\xFFFF\x1\x1E\x6\xFFFF\x1\x15\x1\x1E"+
				"\xA\xFFFF\x1\x1E\xA\xFFFF\x1\x1E\x4\xFFFF\x1\x1E",
				"\x1\x15\x10\xFFFF\x1\x15\x19\xFFFF\x1\x15\x30\xFFFF\x1\x1C\x1\xFFFF"+
				"\x1\x1C\x9\xFFFF\x1\x15\x20\xFFFF\x1\x15\x8\xFFFF\x1\x15",
				"\x1\x15\x10\xFFFF\x1\x15\x19\xFFFF\x1\x15\x30\xFFFF\x1\x1C\x1\xFFFF"+
				"\x1\x1C\x9\xFFFF\x1\x15\x20\xFFFF\x1\x15\x8\xFFFF\x1\x15",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xCF\x18\xFFFF\x1\xCF\x7\xFFFF\x1\xCF\xB\xFFFF\x1\xD1\xB\xFFFF\x1"+
				"\xCF\x9\xFFFF\x1\xCF\x12\xFFFF\x1\xD0\x13\xFFFF\x1\xCF\xC\xFFFF\x1\xCF"+
				"\x10\xFFFF\x1\xCE\x1\xFFFF\x1\xCE\x1\xFFFF\x1\xCE\x3\xFFFF\x1\xCF\x1"+
				"\xFFFF\x1\xD2\x5\xFFFF\x1\xCF\xA\xFFFF\x1\xCF\xA\xFFFF\x1\xCF\x4\xFFFF"+
				"\x1\xCF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xD3\x18\xFFFF\x1\xD3\x7\xFFFF\x1\xD3\x17\xFFFF\x1\xD3\x9\xFFFF\x1"+
				"\xD3\x12\xFFFF\x1\xD4\x13\xFFFF\x1\xD3\xC\xFFFF\x1\xD3\x18\xFFFF\x1"+
				"\xD3\x7\xFFFF\x1\xD3\xA\xFFFF\x1\xD3\xA\xFFFF\x1\xD3\x4\xFFFF\x1\xD3",
				"\x1\xD7\x10\xFFFF\x1\xD6\x1\xD8\x75\xFFFF\x1\xD5\x4\xFFFF\x1\xD9",
				"\x1\xDC\x10\xFFFF\x1\xDB\x1\xDD\x75\xFFFF\x1\xDA\x4\xFFFF\x1\xDE",
				"\x1\xDF\x18\xFFFF\x1\xDF\x7\xFFFF\x1\xDF\x17\xFFFF\x1\xDF\x9\xFFFF\x1"+
				"\xDF\x12\xFFFF\x1\xE0\x13\xFFFF\x1\xDF\xC\xFFFF\x1\xDF\x18\xFFFF\x1"+
				"\xDF\x7\xFFFF\x1\xDF\xA\xFFFF\x1\xDF\xA\xFFFF\x1\xDF\x4\xFFFF\x1\xDF",
				"\x1\x1C\x19\xFFFF\x1\xE4\x2B\xFFFF\x1\xE6\x10\xFFFF\x1\xE5\x20\xFFFF"+
				"\x1\xE3\x8\xFFFF\x1\xE1",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA132_eot = DFA.UnpackEncodedString(DFA132_eotS);
		private static readonly short[] DFA132_eof = DFA.UnpackEncodedString(DFA132_eofS);
		private static readonly char[] DFA132_min = DFA.UnpackEncodedStringToUnsignedChars(DFA132_minS);
		private static readonly char[] DFA132_max = DFA.UnpackEncodedStringToUnsignedChars(DFA132_maxS);
		private static readonly short[] DFA132_accept = DFA.UnpackEncodedString(DFA132_acceptS);
		private static readonly short[] DFA132_special = DFA.UnpackEncodedString(DFA132_specialS);
		private static readonly short[][] DFA132_transition;

		static DFA132()
		{
			int numStates = DFA132_transitionS.Length;
			DFA132_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA132_transition[i] = DFA.UnpackEncodedString(DFA132_transitionS[i]);
			}
		}

		public DFA132( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 132;
			this.eot = DFA132_eot;
			this.eof = DFA132_eof;
			this.min = DFA132_min;
			this.max = DFA132_max;
			this.accept = DFA132_accept;
			this.special = DFA132_special;
			this.transition = DFA132_transition;
		}

		public override string Description { get { return "1620:1: classElement options {k=4; } : ( getAccessor | setAccessor | constructorDeclaration | memberVariableDeclaration | memberFunctionDeclaration | indexSignature semic -> indexSignature );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _reservedWord_in_token2943 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifierAllowedKeyword_in_token2948 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_token2953 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _punctuator_in_token2958 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numericLiteral_in_token2963 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_token2968 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _keyword_in_reservedWord2981 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _futureReservedWord_in_reservedWord2986 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULL_in_reservedWord2991 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booleanLiteral_in_reservedWord2996 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifierAllowedKeyword_in_identifier3532 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_identifier3540 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULL_in_literal3808 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booleanLiteral_in_literal3813 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numericLiteral_in_literal3818 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_literal3823 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RegularExpressionLiteral_in_literal3828 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _THIS_in_primaryExpression4441 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_primaryExpression4446 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _literal_in_primaryExpression4451 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arrayLiteral_in_primaryExpression4456 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _objectLiteral_in_primaryExpression4461 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_primaryExpression4468 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_primaryExpression4470 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_primaryExpression4472 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_arrayLiteral4496 = new BitSet(new ulong[]{0x402C0A00000420UL,0x601008C14108220AUL,0x6550600486000103UL,0x40UL});
		public static readonly BitSet _arrayItem_in_arrayLiteral4500 = new BitSet(new ulong[]{0x200000000UL,0x0UL,0x2000000UL});
		public static readonly BitSet _COMMA_in_arrayLiteral4504 = new BitSet(new ulong[]{0x402C0A00000420UL,0x601008C14108220AUL,0x6550600486000103UL,0x40UL});
		public static readonly BitSet _arrayItem_in_arrayLiteral4506 = new BitSet(new ulong[]{0x200000000UL,0x0UL,0x2000000UL});
		public static readonly BitSet _RBRACK_in_arrayLiteral4514 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_arrayItem4542 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_objectLiteral4574 = new BitSet(new ulong[]{0x40080800000400UL,0x10000100082008UL,0x2110200405000102UL});
		public static readonly BitSet _nameValuePair_in_objectLiteral4578 = new BitSet(new ulong[]{0x200000000UL,0x0UL,0x1000000UL});
		public static readonly BitSet _COMMA_in_objectLiteral4582 = new BitSet(new ulong[]{0x40080800000400UL,0x10000100082008UL,0x2110200404000102UL});
		public static readonly BitSet _nameValuePair_in_objectLiteral4584 = new BitSet(new ulong[]{0x200000000UL,0x0UL,0x1000000UL});
		public static readonly BitSet _RBRACE_in_objectLiteral4592 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyName_in_nameValuePair4617 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _COLON_in_nameValuePair4619 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpression_in_nameValuePair4621 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_propertyName4645 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_propertyName4650 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numericLiteral_in_propertyName4655 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_memberExpression4673 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionExpression_in_memberExpression4678 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _newExpression_in_memberExpression4683 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_newExpression4694 = new BitSet(new ulong[]{0x40080800000400UL,0x1008C10008200AUL,0x2550200484000103UL});
		public static readonly BitSet _primaryExpression_in_newExpression4697 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_arguments4710 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600494000103UL,0x40UL});
		public static readonly BitSet _assignmentExpression_in_arguments4714 = new BitSet(new ulong[]{0x200000000UL,0x0UL,0x10000000UL});
		public static readonly BitSet _COMMA_in_arguments4718 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpression_in_arguments4720 = new BitSet(new ulong[]{0x200000000UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_arguments4728 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _memberExpression_in_leftHandSideExpression4757 = new BitSet(new ulong[]{0x2000000000002UL,0x88000000000UL});
		public static readonly BitSet _arguments_in_leftHandSideExpression4773 = new BitSet(new ulong[]{0x2000000000002UL,0x88000000000UL});
		public static readonly BitSet _LBRACK_in_leftHandSideExpression4794 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_leftHandSideExpression4796 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000UL});
		public static readonly BitSet _RBRACK_in_leftHandSideExpression4798 = new BitSet(new ulong[]{0x2000000000002UL,0x88000000000UL});
		public static readonly BitSet _DOT_in_leftHandSideExpression4817 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_leftHandSideExpression4819 = new BitSet(new ulong[]{0x2000000000002UL,0x88000000000UL});
		public static readonly BitSet _leftHandSideExpression_in_postfixExpression4854 = new BitSet(new ulong[]{0x40000000002UL,0x1000000UL});
		public static readonly BitSet _postfixOperator_in_postfixExpression4860 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INC_in_postfixOperator4878 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_in_postfixOperator4887 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _postfixExpression_in_unaryExpression4904 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryOperator_in_unaryExpression4909 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression4912 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DELETE_in_unaryOperator4924 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VOID_in_unaryOperator4929 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPEOF_in_unaryOperator4934 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INC_in_unaryOperator4939 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_in_unaryOperator4944 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ADD_in_unaryOperator4951 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUB_in_unaryOperator4960 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INV_in_unaryOperator4967 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_unaryOperator4972 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression4987 = new BitSet(new ulong[]{0x400000000002UL,0x24000000000000UL});
		public static readonly BitSet _set_in_multiplicativeExpression4991 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression5006 = new BitSet(new ulong[]{0x400000000002UL,0x24000000000000UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression5024 = new BitSet(new ulong[]{0x22UL,0x0UL,0x400000000000UL});
		public static readonly BitSet _set_in_additiveExpression5028 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression5039 = new BitSet(new ulong[]{0x22UL,0x0UL,0x400000000000UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression5058 = new BitSet(new ulong[]{0x2UL,0x0UL,0x14800000000UL});
		public static readonly BitSet _set_in_shiftExpression5062 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression5077 = new BitSet(new ulong[]{0x2UL,0x0UL,0x14800000000UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression5096 = new BitSet(new ulong[]{0x2UL,0x600008818000UL});
		public static readonly BitSet _set_in_relationalExpression5100 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression5127 = new BitSet(new ulong[]{0x2UL,0x600008818000UL});
		public static readonly BitSet _shiftExpression_in_relationalExpressionNoIn5141 = new BitSet(new ulong[]{0x2UL,0x600008018000UL});
		public static readonly BitSet _set_in_relationalExpressionNoIn5145 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _shiftExpression_in_relationalExpressionNoIn5168 = new BitSet(new ulong[]{0x2UL,0x600008018000UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression5187 = new BitSet(new ulong[]{0x800000000000002UL,0x9000000000000000UL,0x100000000UL});
		public static readonly BitSet _set_in_equalityExpression5191 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression5210 = new BitSet(new ulong[]{0x800000000000002UL,0x9000000000000000UL,0x100000000UL});
		public static readonly BitSet _relationalExpressionNoIn_in_equalityExpressionNoIn5224 = new BitSet(new ulong[]{0x800000000000002UL,0x9000000000000000UL,0x100000000UL});
		public static readonly BitSet _set_in_equalityExpressionNoIn5228 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _relationalExpressionNoIn_in_equalityExpressionNoIn5247 = new BitSet(new ulong[]{0x800000000000002UL,0x9000000000000000UL,0x100000000UL});
		public static readonly BitSet _equalityExpression_in_bitwiseANDExpression5267 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _AND_in_bitwiseANDExpression5271 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _equalityExpression_in_bitwiseANDExpression5274 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _equalityExpressionNoIn_in_bitwiseANDExpressionNoIn5288 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _AND_in_bitwiseANDExpressionNoIn5292 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _equalityExpressionNoIn_in_bitwiseANDExpressionNoIn5295 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _bitwiseANDExpression_in_bitwiseXORExpression5311 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x1000UL});
		public static readonly BitSet _XOR_in_bitwiseXORExpression5315 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _bitwiseANDExpression_in_bitwiseXORExpression5318 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x1000UL});
		public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn5334 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x1000UL});
		public static readonly BitSet _XOR_in_bitwiseXORExpressionNoIn5338 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn5341 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x1000UL});
		public static readonly BitSet _bitwiseXORExpression_in_bitwiseORExpression5356 = new BitSet(new ulong[]{0x2UL,0x0UL,0x10UL});
		public static readonly BitSet _OR_in_bitwiseORExpression5360 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _bitwiseXORExpression_in_bitwiseORExpression5363 = new BitSet(new ulong[]{0x2UL,0x0UL,0x10UL});
		public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn5378 = new BitSet(new ulong[]{0x2UL,0x0UL,0x10UL});
		public static readonly BitSet _OR_in_bitwiseORExpressionNoIn5382 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn5385 = new BitSet(new ulong[]{0x2UL,0x0UL,0x10UL});
		public static readonly BitSet _bitwiseORExpression_in_logicalANDExpression5404 = new BitSet(new ulong[]{0x2UL,0x2000000000UL});
		public static readonly BitSet _LAND_in_logicalANDExpression5408 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _bitwiseORExpression_in_logicalANDExpression5411 = new BitSet(new ulong[]{0x2UL,0x2000000000UL});
		public static readonly BitSet _bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn5425 = new BitSet(new ulong[]{0x2UL,0x2000000000UL});
		public static readonly BitSet _LAND_in_logicalANDExpressionNoIn5429 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn5432 = new BitSet(new ulong[]{0x2UL,0x2000000000UL});
		public static readonly BitSet _logicalANDExpression_in_logicalORExpression5447 = new BitSet(new ulong[]{0x2UL,0x40000000000UL});
		public static readonly BitSet _LOR_in_logicalORExpression5451 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _logicalANDExpression_in_logicalORExpression5454 = new BitSet(new ulong[]{0x2UL,0x40000000000UL});
		public static readonly BitSet _logicalANDExpressionNoIn_in_logicalORExpressionNoIn5469 = new BitSet(new ulong[]{0x2UL,0x40000000000UL});
		public static readonly BitSet _LOR_in_logicalORExpressionNoIn5473 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _logicalANDExpressionNoIn_in_logicalORExpressionNoIn5476 = new BitSet(new ulong[]{0x2UL,0x40000000000UL});
		public static readonly BitSet _logicalORExpression_in_conditionalExpression5495 = new BitSet(new ulong[]{0x2UL,0x0UL,0x800000UL});
		public static readonly BitSet _QUE_in_conditionalExpression5499 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpression_in_conditionalExpression5502 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _COLON_in_conditionalExpression5504 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpression_in_conditionalExpression5507 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalORExpressionNoIn_in_conditionalExpressionNoIn5521 = new BitSet(new ulong[]{0x2UL,0x0UL,0x800000UL});
		public static readonly BitSet _QUE_in_conditionalExpressionNoIn5525 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn5528 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _COLON_in_conditionalExpressionNoIn5530 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn5533 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalExpression_in_assignmentExpression5574 = new BitSet(new ulong[]{0x800000008242UL,0x48000000000000UL,0x829000000020UL,0x2000UL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpression5581 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpression_in_assignmentExpression5584 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalExpressionNoIn_in_assignmentExpressionNoIn5661 = new BitSet(new ulong[]{0x800000008242UL,0x48000000000000UL,0x829000000020UL,0x2000UL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpressionNoIn5668 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_assignmentExpressionNoIn5671 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_expression5695 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _COMMA_in_expression5699 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpression_in_expression5703 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn5740 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _COMMA_in_expressionNoIn5744 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn5748 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _SEMIC_in_semic5799 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOF_in_semic5804 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RBRACE_in_semic5809 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOL_in_semic5816 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MultiLineComment_in_semic5820 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_statement5849 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statementTail_in_statement5854 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableStatement_in_statementTail5866 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _emptyStatement_in_statementTail5871 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionStatement_in_statementTail5876 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifStatement_in_statementTail5881 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _iterationStatement_in_statementTail5886 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _continueStatement_in_statementTail5891 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _breakStatement_in_statementTail5896 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _returnStatement_in_statementTail5901 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _withStatement_in_statementTail5906 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _labelledStatement_in_statementTail5911 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _switchStatement_in_statementTail5916 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _throwStatement_in_statementTail5921 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tryStatement_in_statementTail5926 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_block5941 = new BitSet(new ulong[]{0x412C8800080420UL,0x601008C14118224AUL,0x6DD260068D000103UL,0x650UL});
		public static readonly BitSet _statement_in_block5943 = new BitSet(new ulong[]{0x412C8800080420UL,0x601008C14118224AUL,0x6DD260068D000103UL,0x650UL});
		public static readonly BitSet _RBRACE_in_block5946 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_in_variableStatement5975 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _variableDeclaration_in_variableStatement5977 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _COMMA_in_variableStatement5981 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _variableDeclaration_in_variableStatement5983 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_variableStatement5988 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_variableDeclaration6011 = new BitSet(new ulong[]{0x100008002UL});
		public static readonly BitSet _typeAnnotation_in_variableDeclaration6013 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _ASSIGN_in_variableDeclaration6018 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpression_in_variableDeclaration6020 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_variableDeclarationNoIn6035 = new BitSet(new ulong[]{0x100008002UL});
		public static readonly BitSet _typeAnnotation_in_variableDeclarationNoIn6037 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _ASSIGN_in_variableDeclarationNoIn6042 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_variableDeclarationNoIn6044 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMIC_in_emptyStatement6063 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_expressionStatement6081 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_expressionStatement6083 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_ifStatement6101 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_ifStatement6103 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_ifStatement6105 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_ifStatement6107 = new BitSet(new ulong[]{0x412C8800080420UL,0x601008C14118224AUL,0x6DD260068C000103UL,0x650UL});
		public static readonly BitSet _statement_in_ifStatement6109 = new BitSet(new ulong[]{0x100000000000002UL});
		public static readonly BitSet _ELSE_in_ifStatement6115 = new BitSet(new ulong[]{0x412C8800080420UL,0x601008C14118224AUL,0x6DD260068C000103UL,0x650UL});
		public static readonly BitSet _statement_in_ifStatement6117 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _doStatement_in_iterationStatement6150 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whileStatement_in_iterationStatement6155 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forStatement_in_iterationStatement6160 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DO_in_doStatement6172 = new BitSet(new ulong[]{0x412C8800080420UL,0x601008C14118224AUL,0x6DD260068C000103UL,0x650UL});
		public static readonly BitSet _statement_in_doStatement6174 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _WHILE_in_doStatement6176 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_doStatement6178 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_doStatement6180 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_doStatement6182 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_doStatement6184 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_whileStatement6209 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_whileStatement6212 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_whileStatement6215 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_whileStatement6217 = new BitSet(new ulong[]{0x412C8800080420UL,0x601008C14118224AUL,0x6DD260068C000103UL,0x650UL});
		public static readonly BitSet _statement_in_whileStatement6220 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_forStatement6233 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_forStatement6236 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600684000103UL,0x50UL});
		public static readonly BitSet _forControl_in_forStatement6239 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_forStatement6241 = new BitSet(new ulong[]{0x412C8800080420UL,0x601008C14118224AUL,0x6DD260068C000103UL,0x650UL});
		public static readonly BitSet _statement_in_forStatement6244 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forControlVar_in_forControl6255 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forControlExpression_in_forControl6260 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forControlSemic_in_forControl6265 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_in_forControlVar6276 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _variableDeclarationNoIn_in_forControlVar6278 = new BitSet(new ulong[]{0x200000000UL,0x800000UL,0x200000000UL});
		public static readonly BitSet _IN_in_forControlVar6290 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_forControlVar6292 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMA_in_forControlVar6338 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _variableDeclarationNoIn_in_forControlVar6340 = new BitSet(new ulong[]{0x200000000UL,0x0UL,0x200000000UL});
		public static readonly BitSet _SEMIC_in_forControlVar6345 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600684000103UL,0x40UL});
		public static readonly BitSet _expression_in_forControlVar6349 = new BitSet(new ulong[]{0x0UL,0x0UL,0x200000000UL});
		public static readonly BitSet _SEMIC_in_forControlVar6352 = new BitSet(new ulong[]{0x402C0800000422UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_forControlVar6356 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionNoIn_in_forControlExpression6422 = new BitSet(new ulong[]{0x0UL,0x800000UL,0x200000000UL});
		public static readonly BitSet _IN_in_forControlExpression6437 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_forControlExpression6441 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMIC_in_forControlExpression6487 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600684000103UL,0x40UL});
		public static readonly BitSet _expression_in_forControlExpression6491 = new BitSet(new ulong[]{0x0UL,0x0UL,0x200000000UL});
		public static readonly BitSet _SEMIC_in_forControlExpression6494 = new BitSet(new ulong[]{0x402C0800000422UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_forControlExpression6498 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMIC_in_forControlSemic6557 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600684000103UL,0x40UL});
		public static readonly BitSet _expression_in_forControlSemic6561 = new BitSet(new ulong[]{0x0UL,0x0UL,0x200000000UL});
		public static readonly BitSet _SEMIC_in_forControlSemic6564 = new BitSet(new ulong[]{0x402C0800000422UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_forControlSemic6568 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONTINUE_in_continueStatement6622 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _identifier_in_continueStatement6627 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_continueStatement6630 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAK_in_breakStatement6649 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _identifier_in_breakStatement6654 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_breakStatement6657 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_returnStatement6676 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _expression_in_returnStatement6681 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_returnStatement6684 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WITH_in_withStatement6701 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_withStatement6704 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_withStatement6707 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_withStatement6709 = new BitSet(new ulong[]{0x412C8800080420UL,0x601008C14118224AUL,0x6DD260068C000103UL,0x650UL});
		public static readonly BitSet _statement_in_withStatement6712 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SWITCH_in_switchStatement6728 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_switchStatement6730 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_switchStatement6732 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_switchStatement6734 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _LBRACE_in_switchStatement6736 = new BitSet(new ulong[]{0x100008000000UL,0x0UL,0x1000000UL});
		public static readonly BitSet _defaultClause_in_switchStatement6741 = new BitSet(new ulong[]{0x100008000000UL,0x0UL,0x1000000UL});
		public static readonly BitSet _caseClause_in_switchStatement6746 = new BitSet(new ulong[]{0x100008000000UL,0x0UL,0x1000000UL});
		public static readonly BitSet _RBRACE_in_switchStatement6751 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_caseClause6777 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_caseClause6780 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _COLON_in_caseClause6782 = new BitSet(new ulong[]{0x412C8800080422UL,0x601008C14118224AUL,0x6DD260068C000103UL,0x650UL});
		public static readonly BitSet _statement_in_caseClause6785 = new BitSet(new ulong[]{0x412C8800080422UL,0x601008C14118224AUL,0x6DD260068C000103UL,0x650UL});
		public static readonly BitSet _DEFAULT_in_defaultClause6798 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _COLON_in_defaultClause6801 = new BitSet(new ulong[]{0x412C8800080422UL,0x601008C14118224AUL,0x6DD260068C000103UL,0x650UL});
		public static readonly BitSet _statement_in_defaultClause6804 = new BitSet(new ulong[]{0x412C8800080422UL,0x601008C14118224AUL,0x6DD260068C000103UL,0x650UL});
		public static readonly BitSet _identifier_in_labelledStatement6821 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _COLON_in_labelledStatement6823 = new BitSet(new ulong[]{0x412C8800080420UL,0x601008C14118224AUL,0x6DD260068C000103UL,0x650UL});
		public static readonly BitSet _statement_in_labelledStatement6825 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _THROW_in_throwStatement6856 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _expression_in_throwStatement6861 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_throwStatement6863 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRY_in_tryStatement6880 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _block_in_tryStatement6883 = new BitSet(new ulong[]{0x10000000UL,0x10UL});
		public static readonly BitSet _catchClause_in_tryStatement6887 = new BitSet(new ulong[]{0x2UL,0x10UL});
		public static readonly BitSet _finallyClause_in_tryStatement6889 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _finallyClause_in_tryStatement6894 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CATCH_in_catchClause6908 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_catchClause6911 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_catchClause6914 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_catchClause6916 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _block_in_catchClause6919 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FINALLY_in_finallyClause6931 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _block_in_finallyClause6934 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_functionDeclaration6955 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_functionDeclaration6959 = new BitSet(new ulong[]{0x0UL,0x280000000000UL});
		public static readonly BitSet _typeParameters_in_functionDeclaration6961 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_functionDeclaration6964 = new BitSet(new ulong[]{0x80080800000400UL,0x10000100002008UL,0x2100200414540002UL});
		public static readonly BitSet _parameterList_in_functionDeclaration6966 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_functionDeclaration6969 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _typeAnnotation_in_functionDeclaration6971 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _functionBody_in_functionDeclaration6974 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_functionDeclaration6977 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_functionExpression7012 = new BitSet(new ulong[]{0x80800000400UL,0x10280100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_functionExpression7016 = new BitSet(new ulong[]{0x0UL,0x280000000000UL});
		public static readonly BitSet _typeParameters_in_functionExpression7019 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_functionExpression7022 = new BitSet(new ulong[]{0x80080800000400UL,0x10000100002008UL,0x2100200414540002UL});
		public static readonly BitSet _parameterList_in_functionExpression7024 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_functionExpression7027 = new BitSet(new ulong[]{0x100000000UL,0x4000000000UL});
		public static readonly BitSet _typeAnnotation_in_functionExpression7029 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _functionBody_in_functionExpression7032 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_functionBody7070 = new BitSet(new ulong[]{0x2412C8C80080420UL,0x601008C16158224AUL,0x6DD260068D000103UL,0x650UL});
		public static readonly BitSet _sourceElement_in_functionBody7072 = new BitSet(new ulong[]{0x2412C8C80080420UL,0x601008C16158224AUL,0x6DD260068D000103UL,0x650UL});
		public static readonly BitSet _RBRACE_in_functionBody7075 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _sourceElement_in_program7106 = new BitSet(new ulong[]{0x2412C8C80080422UL,0x601008C16158224AUL,0x6DD260068C000103UL,0x650UL});
		public static readonly BitSet _functionDeclaration_in_sourceElement7140 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _moduleDeclaration_in_sourceElement7148 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ambientDeclaration_in_sourceElement7156 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_sourceElement7164 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interfaceDeclaration_in_sourceElement7172 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classDeclaration_in_sourceElement7180 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _importDeclaration_in_sourceElement7188 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enumDeclaration_in_sourceElement7196 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXTENDS_in_typeConstraint7221 = new BitSet(new ulong[]{0x80800040400UL,0x201028C100002008UL,0x6100200404000002UL,0x40UL});
		public static readonly BitSet _type_in_typeConstraint7223 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_typeParameters7248 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _typeParameter_in_typeParameters7250 = new BitSet(new ulong[]{0x200000000UL,0x8000UL});
		public static readonly BitSet _COMMA_in_typeParameters7253 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _typeParameter_in_typeParameters7255 = new BitSet(new ulong[]{0x200000000UL,0x8000UL});
		public static readonly BitSet _GT_in_typeParameters7259 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_typeParameter7284 = new BitSet(new ulong[]{0x4000000000000002UL});
		public static readonly BitSet _typeConstraint_in_typeParameter7286 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_typeArguments7321 = new BitSet(new ulong[]{0x80800040400UL,0x201028C100002008UL,0x6100200404000002UL,0x40UL});
		public static readonly BitSet _type_in_typeArguments7323 = new BitSet(new ulong[]{0x200000000UL,0x8000UL});
		public static readonly BitSet _COMMA_in_typeArguments7326 = new BitSet(new ulong[]{0x80800040400UL,0x201028C100002008UL,0x6100200404000002UL,0x40UL});
		public static readonly BitSet _type_in_typeArguments7328 = new BitSet(new ulong[]{0x200000000UL,0x8000UL});
		public static readonly BitSet _GT_in_typeArguments7332 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryType_in_type7377 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionType_in_type7390 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constructorType_in_type7398 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _predefinedType_in_nonTupleType7440 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeReference_in_nonTupleType7448 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _objectType_in_nonTupleType7456 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeQuery_in_nonTupleType7464 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionType_in_nonTupleType7472 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constructorType_in_nonTupleType7480 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _predefinedType_in_primaryType7523 = new BitSet(new ulong[]{0x2UL,0x8000000000UL});
		public static readonly BitSet _typeReference_in_primaryType7531 = new BitSet(new ulong[]{0x2UL,0x8000000000UL});
		public static readonly BitSet _objectType_in_primaryType7539 = new BitSet(new ulong[]{0x2UL,0x8000000000UL});
		public static readonly BitSet _tupleType_in_primaryType7547 = new BitSet(new ulong[]{0x2UL,0x8000000000UL});
		public static readonly BitSet _typeQuery_in_primaryType7555 = new BitSet(new ulong[]{0x2UL,0x8000000000UL});
		public static readonly BitSet _arrayIndicator_in_primaryType7562 = new BitSet(new ulong[]{0x2UL,0x8000000000UL});
		public static readonly BitSet _LBRACK_in_arrayIndicator7581 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000UL});
		public static readonly BitSet _RBRACK_in_arrayIndicator7583 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeName_in_typeReference7664 = new BitSet(new ulong[]{0x2UL,0x200000000000UL});
		public static readonly BitSet _typeArguments_in_typeReference7668 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_typeName7697 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _qName_in_typeName7705 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_qName7727 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _DOT_in_qName7733 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_qName7739 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _LBRACE_in_objectType7765 = new BitSet(new ulong[]{0x40080800000400UL,0x2010288100082008UL,0x2110200405000102UL});
		public static readonly BitSet _typeMember_in_objectType7768 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_objectType7770 = new BitSet(new ulong[]{0x40080800000400UL,0x2010288100082008UL,0x2110200405000102UL});
		public static readonly BitSet _RBRACE_in_objectType7774 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertySignature_in_typeMember7800 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _callSignature_in_typeMember7808 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constructSignature_in_typeMember7816 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _indexSignature_in_typeMember7824 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodSignature_in_typeMember7832 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_tupleType7853 = new BitSet(new ulong[]{0x80800040400UL,0x2010284100002008UL,0x6100200404000002UL,0x40UL});
		public static readonly BitSet _nonTupleType_in_tupleType7855 = new BitSet(new ulong[]{0x200000000UL,0x0UL,0x2000000UL});
		public static readonly BitSet _COMMA_in_tupleType7858 = new BitSet(new ulong[]{0x80800040400UL,0x201028C100002008UL,0x6100200404000002UL,0x40UL});
		public static readonly BitSet _type_in_tupleType7860 = new BitSet(new ulong[]{0x200000000UL,0x0UL,0x2000000UL});
		public static readonly BitSet _RBRACK_in_tupleType7864 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryType_in_unionType7896 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10UL});
		public static readonly BitSet _OR_in_unionType7899 = new BitSet(new ulong[]{0x80800040400UL,0x1000C100002008UL,0x6100200404000002UL,0x40UL});
		public static readonly BitSet _primaryType_in_unionType7901 = new BitSet(new ulong[]{0x2UL,0x0UL,0x10UL});
		public static readonly BitSet _typeParameters_in_functionType7924 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_functionType7927 = new BitSet(new ulong[]{0x80080800000400UL,0x10000100002008UL,0x2100200414540002UL});
		public static readonly BitSet _parameterList_in_functionType7929 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_functionType7932 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ARROW_in_functionType7934 = new BitSet(new ulong[]{0x80800040400UL,0x201028C100002008UL,0x6100200404000002UL,0x40UL});
		public static readonly BitSet _type_in_functionType7936 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_constructorType7972 = new BitSet(new ulong[]{0x0UL,0x280000000000UL});
		public static readonly BitSet _typeParameters_in_constructorType7974 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_constructorType7977 = new BitSet(new ulong[]{0x80080800000400UL,0x10000100002008UL,0x2100200414540002UL});
		public static readonly BitSet _parameterList_in_constructorType7979 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_constructorType7982 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ARROW_in_constructorType7984 = new BitSet(new ulong[]{0x80800040400UL,0x201028C100002008UL,0x6100200404000002UL,0x40UL});
		public static readonly BitSet _type_in_constructorType7986 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPEOF_in_typeQuery8022 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_typeQuery8026 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _qName_in_typeQuery8030 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyName_in_propertySignature8058 = new BitSet(new ulong[]{0x100000002UL,0x0UL,0x800000UL});
		public static readonly BitSet _QUE_in_propertySignature8060 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _typeAnnotation_in_propertySignature8063 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeParameters_in_callSignature8099 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_callSignature8102 = new BitSet(new ulong[]{0x80080800000400UL,0x10000100002008UL,0x2100200414540002UL});
		public static readonly BitSet _parameterList_in_callSignature8104 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_callSignature8107 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _typeAnnotation_in_callSignature8109 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameter_in_parameterList8146 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _COMMA_in_parameterList8150 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404540002UL});
		public static readonly BitSet _parameter_in_parameterList8152 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _COMMA_in_parameterList8158 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _restParameter_in_parameterList8160 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _restParameter_in_parameterList8182 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _accessibilityModifier_in_parameter8240 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_parameter8243 = new BitSet(new ulong[]{0x100008002UL,0x0UL,0x800000UL});
		public static readonly BitSet _QUE_in_parameter8245 = new BitSet(new ulong[]{0x100008002UL});
		public static readonly BitSet _typeAnnotation_in_parameter8248 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _ASSIGN_in_parameter8252 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpression_in_parameter8254 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELLIPSIS_in_restParameter8294 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_restParameter8296 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _typeAnnotation_in_restParameter8298 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_constructSignature8330 = new BitSet(new ulong[]{0x0UL,0x280000000000UL});
		public static readonly BitSet _typeParameters_in_constructSignature8332 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_constructSignature8335 = new BitSet(new ulong[]{0x80080800000400UL,0x10000100002008UL,0x2100200414540002UL});
		public static readonly BitSet _parameterList_in_constructSignature8337 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_constructSignature8340 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _typeAnnotation_in_constructSignature8342 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_indexSignature8389 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_indexSignature8391 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _COLON_in_indexSignature8393 = new BitSet(new ulong[]{0x0UL,0x0UL,0x200000000000UL});
		public static readonly BitSet _STRING_in_indexSignature8395 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000UL});
		public static readonly BitSet _RBRACK_in_indexSignature8397 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _typeAnnotation_in_indexSignature8399 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_indexSignature8419 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_indexSignature8421 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _COLON_in_indexSignature8423 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _NUMBER_in_indexSignature8425 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000UL});
		public static readonly BitSet _RBRACK_in_indexSignature8427 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _typeAnnotation_in_indexSignature8429 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyName_in_methodSignature8458 = new BitSet(new ulong[]{0x0UL,0x280000000000UL,0x800000UL});
		public static readonly BitSet _QUE_in_methodSignature8460 = new BitSet(new ulong[]{0x0UL,0x280000000000UL});
		public static readonly BitSet _typeParameters_in_methodSignature8463 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_methodSignature8466 = new BitSet(new ulong[]{0x80080800000400UL,0x10000100002008UL,0x2100200414540002UL});
		public static readonly BitSet _parameterList_in_methodSignature8468 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_methodSignature8471 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _typeAnnotation_in_methodSignature8473 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPE_in_typeAliasDeclaration8513 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_typeAliasDeclaration8515 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _EQ_in_typeAliasDeclaration8517 = new BitSet(new ulong[]{0x80800040400UL,0x201028C100002008UL,0x6100200404000002UL,0x40UL});
		public static readonly BitSet _type_in_typeAliasDeclaration8519 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_typeAliasDeclaration8521 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_typeAnnotation8541 = new BitSet(new ulong[]{0x80800040400UL,0x201028C100002008UL,0x6100200404000002UL,0x40UL});
		public static readonly BitSet _type_in_typeAnnotation8543 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTERFACE_in_interfaceDeclaration8567 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_interfaceDeclaration8569 = new BitSet(new ulong[]{0x4000000000000000UL,0x204000000000UL});
		public static readonly BitSet _typeParameters_in_interfaceDeclaration8571 = new BitSet(new ulong[]{0x4000000000000000UL,0x4000000000UL});
		public static readonly BitSet _extendsClause_in_interfaceDeclaration8574 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _LBRACE_in_interfaceDeclaration8577 = new BitSet(new ulong[]{0x40080800000400UL,0x2010288100082008UL,0x2110200405000102UL});
		public static readonly BitSet _typeMember_in_interfaceDeclaration8580 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_interfaceDeclaration8582 = new BitSet(new ulong[]{0x40080800000400UL,0x2010288100082008UL,0x2110200405000102UL});
		public static readonly BitSet _RBRACE_in_interfaceDeclaration8586 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXTENDS_in_extendsClause8615 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _typeReference_in_extendsClause8617 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _COMMA_in_extendsClause8620 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _typeReference_in_extendsClause8622 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _CLASS_in_classDeclaration8648 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_classDeclaration8650 = new BitSet(new ulong[]{0x4000000000000000UL,0x204000200000UL});
		public static readonly BitSet _typeParameters_in_classDeclaration8652 = new BitSet(new ulong[]{0x4000000000000000UL,0x4000200000UL});
		public static readonly BitSet _extendsClause_in_classDeclaration8655 = new BitSet(new ulong[]{0x0UL,0x4000200000UL});
		public static readonly BitSet _implementsClause_in_classDeclaration8658 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _LBRACE_in_classDeclaration8661 = new BitSet(new ulong[]{0x80800000400UL,0x10008100002008UL,0x2100300405540002UL});
		public static readonly BitSet _classElement_in_classDeclaration8663 = new BitSet(new ulong[]{0x80800000400UL,0x10008100002008UL,0x2100300405540002UL});
		public static readonly BitSet _RBRACE_in_classDeclaration8666 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IMPLEMENTS_in_implementsClause8699 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _typeReference_in_implementsClause8701 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _COMMA_in_implementsClause8704 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _typeReference_in_implementsClause8706 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _getAccessor_in_classElement8742 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _setAccessor_in_classElement8755 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constructorDeclaration_in_classElement8760 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _memberVariableDeclaration_in_classElement8766 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _memberFunctionDeclaration_in_classElement8772 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _indexSignature_in_classElement8778 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_classElement8780 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constructorCallSignature_in_constructorDeclaration8797 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_constructorDeclaration8800 = new BitSet(new ulong[]{0x800000000UL,0x0UL,0x540000UL});
		public static readonly BitSet _constructorCallSignature_in_constructorDeclaration8802 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _functionBody_in_constructorDeclaration8806 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _accessibilityModifier_in_constructorCallSignature8829 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _CONSTRUCTOR_in_constructorCallSignature8832 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_constructorCallSignature8834 = new BitSet(new ulong[]{0x80080800000400UL,0x10000100002008UL,0x2100200414540002UL});
		public static readonly BitSet _parameterList_in_constructorCallSignature8836 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_constructorCallSignature8839 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _accessibilityModifier_in_memberVariableDeclaration8870 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100300404000002UL});
		public static readonly BitSet _STATIC_in_memberVariableDeclaration8873 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _variableDeclaration_in_memberVariableDeclaration8876 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_memberVariableDeclaration8878 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _memberFunctionCallSignature_in_memberFunctionDeclaration8908 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_memberFunctionDeclaration8911 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100300404540002UL});
		public static readonly BitSet _memberFunctionCallSignature_in_memberFunctionDeclaration8913 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _functionBody_in_memberFunctionDeclaration8917 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _accessibilityModifier_in_memberFunctionCallSignature8940 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100300404000002UL});
		public static readonly BitSet _STATIC_in_memberFunctionCallSignature8943 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_memberFunctionCallSignature8946 = new BitSet(new ulong[]{0x0UL,0x280000000000UL});
		public static readonly BitSet _typeParameters_in_memberFunctionCallSignature8948 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_memberFunctionCallSignature8951 = new BitSet(new ulong[]{0x80080800000400UL,0x10000100002008UL,0x2100200414540002UL});
		public static readonly BitSet _parameterList_in_memberFunctionCallSignature8953 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_memberFunctionCallSignature8956 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _typeAnnotation_in_memberFunctionCallSignature8958 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _accessibilityModifier_in_getAccessor8994 = new BitSet(new ulong[]{0x0UL,0x2000UL,0x100000000000UL});
		public static readonly BitSet _STATIC_in_getAccessor8997 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _GET_in_getAccessor9000 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_getAccessor9002 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_getAccessor9004 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_getAccessor9006 = new BitSet(new ulong[]{0x100000000UL,0x4000000000UL});
		public static readonly BitSet _typeAnnotation_in_getAccessor9008 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _functionBody_in_getAccessor9011 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _accessibilityModifier_in_setAccessor9042 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100400000000UL});
		public static readonly BitSet _STATIC_in_setAccessor9045 = new BitSet(new ulong[]{0x0UL,0x0UL,0x400000000UL});
		public static readonly BitSet _SET_in_setAccessor9048 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_setAccessor9050 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_setAccessor9052 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404540002UL});
		public static readonly BitSet _parameter_in_setAccessor9054 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_setAccessor9056 = new BitSet(new ulong[]{0x100000000UL,0x4000000000UL});
		public static readonly BitSet _typeAnnotation_in_setAccessor9058 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _functionBody_in_setAccessor9061 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONST_in_enumDeclaration9098 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _ENUM_in_enumDeclaration9101 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_enumDeclaration9103 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _LBRACE_in_enumDeclaration9105 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _enumBody_in_enumDeclaration9107 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000UL});
		public static readonly BitSet _RBRACE_in_enumDeclaration9109 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enumMember_in_enumBody9122 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _COMMA_in_enumBody9124 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _enumMember_in_enumBody9128 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_enumMember9139 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _ASSIGN_in_enumMember9142 = new BitSet(new ulong[]{0x402C0800000420UL,0x601008C14108220AUL,0x6550600484000103UL,0x40UL});
		public static readonly BitSet _assignmentExpression_in_enumMember9145 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MODULE_in_moduleDeclaration9176 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000000000UL});
		public static readonly BitSet _StringLiteral_in_moduleDeclaration9178 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _LBRACE_in_moduleDeclaration9180 = new BitSet(new ulong[]{0x12412C8C80080420UL,0x601008C16158224AUL,0x6DD260068D000103UL,0x650UL});
		public static readonly BitSet _moduleElement_in_moduleDeclaration9183 = new BitSet(new ulong[]{0x12412C8C80080420UL,0x601008C16158224AUL,0x6DD260068D000103UL,0x650UL});
		public static readonly BitSet _RBRACE_in_moduleDeclaration9187 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MODULE_in_moduleDeclaration9206 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_moduleDeclaration9208 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _LBRACE_in_moduleDeclaration9210 = new BitSet(new ulong[]{0x12412C8C80080420UL,0x601008C16158224AUL,0x6DD260068D000103UL,0x650UL});
		public static readonly BitSet _moduleElement_in_moduleDeclaration9213 = new BitSet(new ulong[]{0x12412C8C80080420UL,0x601008C16158224AUL,0x6DD260068D000103UL,0x650UL});
		public static readonly BitSet _RBRACE_in_moduleDeclaration9217 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _importDeclaration_in_moduleElement9257 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ambientDeclaration_in_moduleElement9265 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _moduleDeclaration_in_moduleElement9273 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionDeclaration_in_moduleElement9283 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_moduleElement9291 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interfaceDeclaration_in_moduleElement9299 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classDeclaration_in_moduleElement9307 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enumDeclaration_in_moduleElement9315 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _exportDeclaration_in_moduleElement9323 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IMPORT_in_importDeclaration9338 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_importDeclaration9340 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _ASSIGN_in_importDeclaration9342 = new BitSet(new ulong[]{0x0UL,0x10000000000000UL});
		public static readonly BitSet _MODULE_in_importDeclaration9344 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_importDeclaration9346 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000000000UL});
		public static readonly BitSet _StringLiteral_in_importDeclaration9348 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_importDeclaration9350 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_importDeclaration9352 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXPORT_in_exportDeclaration9376 = new BitSet(new ulong[]{0x200080480000000UL,0x10000020400200UL,0x0UL,0x10UL});
		public static readonly BitSet _exportableElement_in_exportDeclaration9378 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interfaceDeclaration_in_exportableElement9403 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classDeclaration_in_exportableElement9411 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _moduleDeclaration_in_exportableElement9419 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _importDeclaration_in_exportableElement9427 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enumDeclaration_in_exportableElement9435 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ambientDeclaration_in_exportableElement9443 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableStatement_in_exportableElement9451 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionDeclaration_in_exportableElement9459 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DECLARE_in_ambientDeclaration9476 = new BitSet(new ulong[]{0x200000480000000UL,0x10000020400200UL,0x0UL,0x10UL});
		public static readonly BitSet _ambientElement_in_ambientDeclaration9478 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interfaceDeclaration_in_ambientElement9503 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ambientClassDeclaration_in_ambientElement9511 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _moduleDeclaration_in_ambientElement9519 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _importDeclaration_in_ambientElement9527 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enumDeclaration_in_ambientElement9535 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableStatement_in_ambientElement9543 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ambientFunctionDeclaration_in_ambientElement9551 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CLASS_in_ambientClassDeclaration9565 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_ambientClassDeclaration9567 = new BitSet(new ulong[]{0x4000000000000000UL,0x204000000000UL});
		public static readonly BitSet _typeParameters_in_ambientClassDeclaration9569 = new BitSet(new ulong[]{0x4000000000000000UL,0x4000000000UL});
		public static readonly BitSet _extendsClause_in_ambientClassDeclaration9572 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _LBRACE_in_ambientClassDeclaration9575 = new BitSet(new ulong[]{0x40080800000400UL,0x2010288100082008UL,0x2110200405000102UL});
		public static readonly BitSet _typeMember_in_ambientClassDeclaration9578 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_ambientClassDeclaration9580 = new BitSet(new ulong[]{0x40080800000400UL,0x2010288100082008UL,0x2110200405000102UL});
		public static readonly BitSet _RBRACE_in_ambientClassDeclaration9584 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_ambientFunctionDeclaration9613 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_ambientFunctionDeclaration9617 = new BitSet(new ulong[]{0x0UL,0x280000000000UL});
		public static readonly BitSet _typeParameters_in_ambientFunctionDeclaration9619 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _LPAREN_in_ambientFunctionDeclaration9622 = new BitSet(new ulong[]{0x80080800000400UL,0x10000100002008UL,0x2100200414540002UL});
		public static readonly BitSet _parameterList_in_ambientFunctionDeclaration9624 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _RPAREN_in_ambientFunctionDeclaration9627 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _typeAnnotation_in_ambientFunctionDeclaration9629 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_ambientFunctionDeclaration9632 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _predefinedType_in_synpred1_TypeScript7440 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeReference_in_synpred2_TypeScript7448 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  Xebic.Parsers.ES3 
