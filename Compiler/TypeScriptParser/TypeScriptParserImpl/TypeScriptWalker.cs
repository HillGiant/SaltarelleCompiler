//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 TypeScriptWalker.g3 2016-05-06 13:05:56

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System;
using TypeScriptModel.TypeSystem.Parameters;
using TypeScriptModel.Elements;
using TypeScriptModel.Elements.ClassMembers;
using TypeScriptModel.TypeSystem;
using TypeScriptModel.TypeSystem.TypeMembers;
using TypeScriptModel.TypeSystem.Types;
using Saltarelle.Compiler.JSModel.Expressions;
using Saltarelle.Compiler.JSModel.Statements;
using System.Globalization;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  TypeScriptParser.TypeScriptParserImpl 
{

    [System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class TypeScriptWalker : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ABSTRACT", "ADD", "ADDASS", "AMBIENTFUNCTION", "AND", "ANDASS", "ANY", "ARGS", "ARRAY", "ARRAY_TYPE", "ARROW", "ASSIGN", "AWAIT", "BLOCK", "BOOLEAN", "BREAK", "BSLASH", "BYFIELD", "BYINDEX", "BYTE", "BackslashSequence", "CALL", "CALL_SIG", "CASE", "CATCH", "CEXPR", "CHAR", "CLASS", "COLON", "COMMA", "CONST", "CONSTRUCTOR", "CONST_DECL", "CONST_SIG", "CONST_TYPE", "CONTINUE", "CR", "CharacterEscapeSequence", "DEC", "DECLARE", "DEFAULT", "DELETE", "DIV", "DIVASS", "DO", "DOT", "DOUBLE", "DQUOTE", "DecimalDigit", "DecimalIntegerLiteral", "DecimalLiteral", "ELLIPSIS", "ELSE", "ENUM", "EOL", "EQ", "EXPORT", "EXPR", "EXTENDS", "EscapeSequence", "ExponentPart", "FALSE", "FF", "FINAL", "FINALLY", "FLOAT", "FOR", "FORITER", "FORSTEP", "FUNCTION", "FUNCTIONDECLARATION", "FUNCTION_TYPE", "FUNC_TYPE", "GET", "GOTO", "GT", "GTE", "HexDigit", "HexEscapeSequence", "HexIntegerLiteral", "IF", "IMPLEMENTS", "IMPORT", "IN", "INC", "INDEX", "INDEX_SIG", "INSTANCEOF", "INT", "INTERFACE", "INV", "ITEM", "Identifier", "IdentifierNameASCIIStart", "IdentifierPart", "IdentifierStartASCII", "LABELLED", "LAND", "LBRACE", "LBRACK", "LF", "LONG", "LOR", "LPAREN", "LS", "LT", "LTE", "LineTerminator", "METH_DECL", "METH_SIG", "MOD", "MODASS", "MODULE", "MUL", "MULASS", "MultiLineComment", "NAMEDVALUE", "NATIVE", "NBSP", "NEG", "NEQ", "NEW", "NOT", "NSAME", "NULL", "NUMBER", "OBJECT", "OBJECT_TYPE", "OR", "ORASS", "OctalDigit", "OctalEscapeSequence", "OctalIntegerLiteral", "PACKAGE", "PARAM", "PARAMS", "PARAM_ARRAY", "PARAM_OPT", "PAREXPR", "PDEC", "PINC", "POS", "PRIVATE", "PROP_SIG", "PROTECTED", "PS", "PUBLIC", "QUE", "RBRACE", "RBRACK", "REQUIRE", "RETURN", "RPAREN", "RegularExpressionChar", "RegularExpressionFirstChar", "RegularExpressionLiteral", "SAME", "SEMIC", "SET", "SHL", "SHLASS", "SHORT", "SHR", "SHRASS", "SHU", "SHUASS", "SP", "SQUOTE", "STATIC", "STRING", "SUB", "SUBASS", "SUPER", "SWITCH", "SYNCHRONIZED", "SingleLineComment", "StringLiteral", "TAB", "THIS", "THROW", "THROWS", "TRANSIENT", "TRUE", "TRY", "TUPLE_TYPE", "TYPE", "TYPEOF", "TYPEREF", "TYPE_ARGS", "TYPE_PARAMS", "USP", "UnicodeEscapeSequence", "VAR", "VAR_OPT", "VOID", "VOLATILE", "VT", "WHILE", "WITH", "WhiteSpace", "XOR", "XORASS", "YIELD", "ZeroToThree"
	};
	public const int EOF=-1;
	public const int ABSTRACT=4;
	public const int ADD=5;
	public const int ADDASS=6;
	public const int AMBIENTFUNCTION=7;
	public const int AND=8;
	public const int ANDASS=9;
	public const int ANY=10;
	public const int ARGS=11;
	public const int ARRAY=12;
	public const int ARRAY_TYPE=13;
	public const int ARROW=14;
	public const int ASSIGN=15;
	public const int AWAIT=16;
	public const int BLOCK=17;
	public const int BOOLEAN=18;
	public const int BREAK=19;
	public const int BSLASH=20;
	public const int BYFIELD=21;
	public const int BYINDEX=22;
	public const int BYTE=23;
	public const int BackslashSequence=24;
	public const int CALL=25;
	public const int CALL_SIG=26;
	public const int CASE=27;
	public const int CATCH=28;
	public const int CEXPR=29;
	public const int CHAR=30;
	public const int CLASS=31;
	public const int COLON=32;
	public const int COMMA=33;
	public const int CONST=34;
	public const int CONSTRUCTOR=35;
	public const int CONST_DECL=36;
	public const int CONST_SIG=37;
	public const int CONST_TYPE=38;
	public const int CONTINUE=39;
	public const int CR=40;
	public const int CharacterEscapeSequence=41;
	public const int DEC=42;
	public const int DECLARE=43;
	public const int DEFAULT=44;
	public const int DELETE=45;
	public const int DIV=46;
	public const int DIVASS=47;
	public const int DO=48;
	public const int DOT=49;
	public const int DOUBLE=50;
	public const int DQUOTE=51;
	public const int DecimalDigit=52;
	public const int DecimalIntegerLiteral=53;
	public const int DecimalLiteral=54;
	public const int ELLIPSIS=55;
	public const int ELSE=56;
	public const int ENUM=57;
	public const int EOL=58;
	public const int EQ=59;
	public const int EXPORT=60;
	public const int EXPR=61;
	public const int EXTENDS=62;
	public const int EscapeSequence=63;
	public const int ExponentPart=64;
	public const int FALSE=65;
	public const int FF=66;
	public const int FINAL=67;
	public const int FINALLY=68;
	public const int FLOAT=69;
	public const int FOR=70;
	public const int FORITER=71;
	public const int FORSTEP=72;
	public const int FUNCTION=73;
	public const int FUNCTIONDECLARATION=74;
	public const int FUNCTION_TYPE=75;
	public const int FUNC_TYPE=76;
	public const int GET=77;
	public const int GOTO=78;
	public const int GT=79;
	public const int GTE=80;
	public const int HexDigit=81;
	public const int HexEscapeSequence=82;
	public const int HexIntegerLiteral=83;
	public const int IF=84;
	public const int IMPLEMENTS=85;
	public const int IMPORT=86;
	public const int IN=87;
	public const int INC=88;
	public const int INDEX=89;
	public const int INDEX_SIG=90;
	public const int INSTANCEOF=91;
	public const int INT=92;
	public const int INTERFACE=93;
	public const int INV=94;
	public const int ITEM=95;
	public const int Identifier=96;
	public const int IdentifierNameASCIIStart=97;
	public const int IdentifierPart=98;
	public const int IdentifierStartASCII=99;
	public const int LABELLED=100;
	public const int LAND=101;
	public const int LBRACE=102;
	public const int LBRACK=103;
	public const int LF=104;
	public const int LONG=105;
	public const int LOR=106;
	public const int LPAREN=107;
	public const int LS=108;
	public const int LT=109;
	public const int LTE=110;
	public const int LineTerminator=111;
	public const int METH_DECL=112;
	public const int METH_SIG=113;
	public const int MOD=114;
	public const int MODASS=115;
	public const int MODULE=116;
	public const int MUL=117;
	public const int MULASS=118;
	public const int MultiLineComment=119;
	public const int NAMEDVALUE=120;
	public const int NATIVE=121;
	public const int NBSP=122;
	public const int NEG=123;
	public const int NEQ=124;
	public const int NEW=125;
	public const int NOT=126;
	public const int NSAME=127;
	public const int NULL=128;
	public const int NUMBER=129;
	public const int OBJECT=130;
	public const int OBJECT_TYPE=131;
	public const int OR=132;
	public const int ORASS=133;
	public const int OctalDigit=134;
	public const int OctalEscapeSequence=135;
	public const int OctalIntegerLiteral=136;
	public const int PACKAGE=137;
	public const int PARAM=138;
	public const int PARAMS=139;
	public const int PARAM_ARRAY=140;
	public const int PARAM_OPT=141;
	public const int PAREXPR=142;
	public const int PDEC=143;
	public const int PINC=144;
	public const int POS=145;
	public const int PRIVATE=146;
	public const int PROP_SIG=147;
	public const int PROTECTED=148;
	public const int PS=149;
	public const int PUBLIC=150;
	public const int QUE=151;
	public const int RBRACE=152;
	public const int RBRACK=153;
	public const int REQUIRE=154;
	public const int RETURN=155;
	public const int RPAREN=156;
	public const int RegularExpressionChar=157;
	public const int RegularExpressionFirstChar=158;
	public const int RegularExpressionLiteral=159;
	public const int SAME=160;
	public const int SEMIC=161;
	public const int SET=162;
	public const int SHL=163;
	public const int SHLASS=164;
	public const int SHORT=165;
	public const int SHR=166;
	public const int SHRASS=167;
	public const int SHU=168;
	public const int SHUASS=169;
	public const int SP=170;
	public const int SQUOTE=171;
	public const int STATIC=172;
	public const int STRING=173;
	public const int SUB=174;
	public const int SUBASS=175;
	public const int SUPER=176;
	public const int SWITCH=177;
	public const int SYNCHRONIZED=178;
	public const int SingleLineComment=179;
	public const int StringLiteral=180;
	public const int TAB=181;
	public const int THIS=182;
	public const int THROW=183;
	public const int THROWS=184;
	public const int TRANSIENT=185;
	public const int TRUE=186;
	public const int TRY=187;
	public const int TUPLE_TYPE=188;
	public const int TYPE=189;
	public const int TYPEOF=190;
	public const int TYPEREF=191;
	public const int TYPE_ARGS=192;
	public const int TYPE_PARAMS=193;
	public const int USP=194;
	public const int UnicodeEscapeSequence=195;
	public const int VAR=196;
	public const int VAR_OPT=197;
	public const int VOID=198;
	public const int VOLATILE=199;
	public const int VT=200;
	public const int WHILE=201;
	public const int WITH=202;
	public const int WhiteSpace=203;
	public const int XOR=204;
	public const int XORASS=205;
	public const int YIELD=206;
	public const int ZeroToThree=207;

	public TypeScriptWalker(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public TypeScriptWalker(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return TypeScriptWalker.tokenNames; } }
	public override string GrammarFileName { get { return "TypeScriptWalker.g3"; } }


	    public override void ReportError(RecognitionException e) { throw e; }
	    
		public string UnescapeStringLiteral(string orig) {
			if (orig.IndexOf('\\') == -1)
				return orig.Substring(1, orig.Length - 2);

			var result = new System.Text.StringBuilder();
			for (int i = 1; i < orig.Length - 1; i++) {
				char ch = orig[i];
				if (ch == '\\') {
					ch = orig[++i];
					if (ch == '\'')
						result.Append('\'');
					else if (ch == '\"')
						result.Append('\"');
					else if (ch == 'b')
						result.Append('\b');
					else if (ch == 'f')
						result.Append('\f');
					else if (ch == 'n')
						result.Append('\n');
					else if (ch == 'r')
						result.Append('\r');
					else if (ch == 't')
						result.Append('\t');
					else if (ch == 'v')
						result.Append('\v');
					else if (ch == '0')
						result.Append('\0');
					else if (ch == '/')
						result.Append('/');
					else
						result.Append('\\').Append(ch);	// TODO: More escape sequences.
				}
				else
					result.Append(ch);
			}
			return result.ToString();
		}

		public JsConstantExpression ParseRegexpLiteral(string orig) {
			var pattern = new System.Text.StringBuilder();
			int i = 1;
			for (; i < orig.Length - 1; i++) {
				char ch = orig[i];
				if (ch == '\\') {
					ch = orig[++i];
					if (ch == '\'')
						pattern.Append('\'');
					else if (ch == '\"')
						pattern.Append('\"');
					else if (ch == 'b')
						pattern.Append('\b');
					else if (ch == 'f')
						pattern.Append('\f');
					else if (ch == 'n')
						pattern.Append('\n');
					else if (ch == 'r')
						pattern.Append('\r');
					else if (ch == 't')
						pattern.Append('\t');
					else if (ch == 'v')
						pattern.Append('\v');
					else if (ch == '0')
						pattern.Append('\0');
					else if (ch == '/')
						pattern.Append('/');
					else
						pattern.Append('\\').Append(ch);	// TODO: More escape sequences.
				}
				else if (ch == '/')
					break;
				else
					pattern.Append(ch);
			}

			string options = i < orig.Length - 1 ? orig.Substring(i + 1) : null;

			return JsExpression.Regexp(pattern.ToString(), options);
		}

		public int DecodeOctalNumber(string value) {
			int result = 0;
			for (int i = 0; i < value.Length; i++)
				result = result * 8 + (value[i] - '0');
			return result;
		}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// TypeScriptWalker.g3:115:8: public program returns [IList<TsSourceElement> result] : (s= sourceElement )* ;
	[GrammarRule("program")]
	public IList<TsSourceElement> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		IList<TsSourceElement> result = default(IList<TsSourceElement>);


		TsSourceElement s = default(TsSourceElement);

		 result = new List<TsSourceElement>(); 
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(115, 1);
		try
		{
			// TypeScriptWalker.g3:117:2: ( (s= sourceElement )* )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:117:4: (s= sourceElement )*
			{
			DebugLocation(117, 4);
			// TypeScriptWalker.g3:117:4: (s= sourceElement )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				try
				{
					alt1 = dfa1.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:117:5: s= sourceElement
					{
					DebugLocation(117, 7);
					PushFollow(Follow._sourceElement_in_program76);
					s=sourceElement();
					PopFollow();

					DebugLocation(117, 23);
					 result.Add(s); 

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(118, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return result;

	}
	// $ANTLR end "program"

	partial void EnterRule_sourceElement();
	partial void LeaveRule_sourceElement();
	// $ANTLR start "sourceElement"
	// TypeScriptWalker.g3:120:8: public sourceElement returns [TsSourceElement result] : ( (e= statementElement ) | (e= interfaceElement ) | (e= classElement ) | (e= moduleElement ) | (e= namespaceElement ) | (e= exportDeclaration ) | (e= ambientDeclaration ) | (e= ambientFunctionDeclaration ) | (e= importDeclaration ) ) ;
	[GrammarRule("sourceElement")]
	public TsSourceElement sourceElement()
	{
		EnterRule_sourceElement();
		EnterRule("sourceElement", 2);
		TraceIn("sourceElement", 2);
		TsSourceElement result = default(TsSourceElement);


		TsSourceElement e = default(TsSourceElement);

		try { DebugEnterRule(GrammarFileName, "sourceElement");
		DebugLocation(120, 4);
		try
		{
			// TypeScriptWalker.g3:121:5: ( ( (e= statementElement ) | (e= interfaceElement ) | (e= classElement ) | (e= moduleElement ) | (e= namespaceElement ) | (e= exportDeclaration ) | (e= ambientDeclaration ) | (e= ambientFunctionDeclaration ) | (e= importDeclaration ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:121:7: ( (e= statementElement ) | (e= interfaceElement ) | (e= classElement ) | (e= moduleElement ) | (e= namespaceElement ) | (e= exportDeclaration ) | (e= ambientDeclaration ) | (e= ambientFunctionDeclaration ) | (e= importDeclaration ) )
			{
			DebugLocation(121, 7);
			// TypeScriptWalker.g3:121:7: ( (e= statementElement ) | (e= interfaceElement ) | (e= classElement ) | (e= moduleElement ) | (e= namespaceElement ) | (e= exportDeclaration ) | (e= ambientDeclaration ) | (e= ambientFunctionDeclaration ) | (e= importDeclaration ) )
			int alt2=9;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			try
			{
				alt2 = dfa2.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:121:8: (e= statementElement )
				{
				DebugLocation(121, 8);
				// TypeScriptWalker.g3:121:8: (e= statementElement )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:121:9: e= statementElement
				{
				DebugLocation(121, 11);
				PushFollow(Follow._statementElement_in_sourceElement106);
				e=statementElement();
				PopFollow();


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:122:7: (e= interfaceElement )
				{
				DebugLocation(122, 7);
				// TypeScriptWalker.g3:122:7: (e= interfaceElement )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:122:8: e= interfaceElement
				{
				DebugLocation(122, 10);
				PushFollow(Follow._interfaceElement_in_sourceElement120);
				e=interfaceElement();
				PopFollow();


				}


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:123:7: (e= classElement )
				{
				DebugLocation(123, 7);
				// TypeScriptWalker.g3:123:7: (e= classElement )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:123:8: e= classElement
				{
				DebugLocation(123, 10);
				PushFollow(Follow._classElement_in_sourceElement134);
				e=classElement();
				PopFollow();


				}


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScriptWalker.g3:124:7: (e= moduleElement )
				{
				DebugLocation(124, 7);
				// TypeScriptWalker.g3:124:7: (e= moduleElement )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:124:8: e= moduleElement
				{
				DebugLocation(124, 10);
				PushFollow(Follow._moduleElement_in_sourceElement148);
				e=moduleElement();
				PopFollow();


				}


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScriptWalker.g3:125:7: (e= namespaceElement )
				{
				DebugLocation(125, 7);
				// TypeScriptWalker.g3:125:7: (e= namespaceElement )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:125:8: e= namespaceElement
				{
				DebugLocation(125, 10);
				PushFollow(Follow._namespaceElement_in_sourceElement162);
				e=namespaceElement();
				PopFollow();


				}


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScriptWalker.g3:126:7: (e= exportDeclaration )
				{
				DebugLocation(126, 7);
				// TypeScriptWalker.g3:126:7: (e= exportDeclaration )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:126:8: e= exportDeclaration
				{
				DebugLocation(126, 10);
				PushFollow(Follow._exportDeclaration_in_sourceElement176);
				e=exportDeclaration();
				PopFollow();


				}


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// TypeScriptWalker.g3:127:7: (e= ambientDeclaration )
				{
				DebugLocation(127, 7);
				// TypeScriptWalker.g3:127:7: (e= ambientDeclaration )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:127:8: e= ambientDeclaration
				{
				DebugLocation(127, 10);
				PushFollow(Follow._ambientDeclaration_in_sourceElement190);
				e=ambientDeclaration();
				PopFollow();


				}


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// TypeScriptWalker.g3:128:7: (e= ambientFunctionDeclaration )
				{
				DebugLocation(128, 7);
				// TypeScriptWalker.g3:128:7: (e= ambientFunctionDeclaration )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:128:8: e= ambientFunctionDeclaration
				{
				DebugLocation(128, 10);
				PushFollow(Follow._ambientFunctionDeclaration_in_sourceElement204);
				e=ambientFunctionDeclaration();
				PopFollow();


				}


				}
				break;
			case 9:
				DebugEnterAlt(9);
				// TypeScriptWalker.g3:129:7: (e= importDeclaration )
				{
				DebugLocation(129, 7);
				// TypeScriptWalker.g3:129:7: (e= importDeclaration )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:129:8: e= importDeclaration
				{
				DebugLocation(129, 10);
				PushFollow(Follow._importDeclaration_in_sourceElement218);
				e=importDeclaration();
				PopFollow();


				}


				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(130, 5);
			 result = e; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("sourceElement", 2);
			LeaveRule("sourceElement", 2);
			LeaveRule_sourceElement();
		}
		DebugLocation(131, 4);
		} finally { DebugExitRule(GrammarFileName, "sourceElement"); }
		return result;

	}
	// $ANTLR end "sourceElement"

	partial void EnterRule_statementElement();
	partial void LeaveRule_statementElement();
	// $ANTLR start "statementElement"
	// TypeScriptWalker.g3:133:8: public statementElement returns [TsSourceElement result] : s= statement ;
	[GrammarRule("statementElement")]
	public TsSourceElement statementElement()
	{
		EnterRule_statementElement();
		EnterRule("statementElement", 3);
		TraceIn("statementElement", 3);
		TsSourceElement result = default(TsSourceElement);


		JsStatement s = default(JsStatement);

		try { DebugEnterRule(GrammarFileName, "statementElement");
		DebugLocation(133, 4);
		try
		{
			// TypeScriptWalker.g3:134:5: (s= statement )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:134:7: s= statement
			{
			DebugLocation(134, 9);
			PushFollow(Follow._statement_in_statementElement253);
			s=statement();
			PopFollow();

			DebugLocation(135, 5);
			 result = new TsStatementElement(s); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statementElement", 3);
			LeaveRule("statementElement", 3);
			LeaveRule_statementElement();
		}
		DebugLocation(136, 4);
		} finally { DebugExitRule(GrammarFileName, "statementElement"); }
		return result;

	}
	// $ANTLR end "statementElement"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// TypeScriptWalker.g3:138:8: public statement returns [JsStatement result] : (x= block |x= variableDeclaration |e= expression |x= ifStatement |x= doStatement |x= whileStatement |x= forStatement |x= continueStatement |x= breakStatement |x= returnStatement |x= withStatement |x= labelledStatement |x= switchStatement |x= throwStatement |x= tryStatement |x= functionDeclaration |x= gotoStatement |x= yieldStatement |x= awaitStatement | SEMIC ) ;
	[GrammarRule("statement")]
	public JsStatement statement()
	{
		EnterRule_statement();
		EnterRule("statement", 4);
		TraceIn("statement", 4);
		JsStatement result = default(JsStatement);


		JsStatement x = default(JsStatement);
		JsExpression e = default(JsExpression);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(138, 1);
		try
		{
			// TypeScriptWalker.g3:139:2: ( (x= block |x= variableDeclaration |e= expression |x= ifStatement |x= doStatement |x= whileStatement |x= forStatement |x= continueStatement |x= breakStatement |x= returnStatement |x= withStatement |x= labelledStatement |x= switchStatement |x= throwStatement |x= tryStatement |x= functionDeclaration |x= gotoStatement |x= yieldStatement |x= awaitStatement | SEMIC ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:139:4: (x= block |x= variableDeclaration |e= expression |x= ifStatement |x= doStatement |x= whileStatement |x= forStatement |x= continueStatement |x= breakStatement |x= returnStatement |x= withStatement |x= labelledStatement |x= switchStatement |x= throwStatement |x= tryStatement |x= functionDeclaration |x= gotoStatement |x= yieldStatement |x= awaitStatement | SEMIC )
			{
			DebugLocation(139, 4);
			// TypeScriptWalker.g3:139:4: (x= block |x= variableDeclaration |e= expression |x= ifStatement |x= doStatement |x= whileStatement |x= forStatement |x= continueStatement |x= breakStatement |x= returnStatement |x= withStatement |x= labelledStatement |x= switchStatement |x= throwStatement |x= tryStatement |x= functionDeclaration |x= gotoStatement |x= yieldStatement |x= awaitStatement | SEMIC )
			int alt3=20;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			try
			{
				alt3 = dfa3.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:139:5: x= block
				{
				DebugLocation(139, 6);
				PushFollow(Follow._block_in_statement282);
				x=block();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:140:4: x= variableDeclaration
				{
				DebugLocation(140, 5);
				PushFollow(Follow._variableDeclaration_in_statement289);
				x=variableDeclaration();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:141:4: e= expression
				{
				DebugLocation(141, 5);
				PushFollow(Follow._expression_in_statement296);
				e=expression();
				PopFollow();

				DebugLocation(141, 17);
				 x = new JsExpressionStatement(e); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScriptWalker.g3:142:4: x= ifStatement
				{
				DebugLocation(142, 5);
				PushFollow(Follow._ifStatement_in_statement305);
				x=ifStatement();
				PopFollow();


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScriptWalker.g3:143:4: x= doStatement
				{
				DebugLocation(143, 5);
				PushFollow(Follow._doStatement_in_statement312);
				x=doStatement();
				PopFollow();


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScriptWalker.g3:144:4: x= whileStatement
				{
				DebugLocation(144, 5);
				PushFollow(Follow._whileStatement_in_statement319);
				x=whileStatement();
				PopFollow();


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// TypeScriptWalker.g3:145:4: x= forStatement
				{
				DebugLocation(145, 5);
				PushFollow(Follow._forStatement_in_statement326);
				x=forStatement();
				PopFollow();


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// TypeScriptWalker.g3:146:4: x= continueStatement
				{
				DebugLocation(146, 5);
				PushFollow(Follow._continueStatement_in_statement333);
				x=continueStatement();
				PopFollow();


				}
				break;
			case 9:
				DebugEnterAlt(9);
				// TypeScriptWalker.g3:147:4: x= breakStatement
				{
				DebugLocation(147, 5);
				PushFollow(Follow._breakStatement_in_statement340);
				x=breakStatement();
				PopFollow();


				}
				break;
			case 10:
				DebugEnterAlt(10);
				// TypeScriptWalker.g3:148:4: x= returnStatement
				{
				DebugLocation(148, 5);
				PushFollow(Follow._returnStatement_in_statement347);
				x=returnStatement();
				PopFollow();


				}
				break;
			case 11:
				DebugEnterAlt(11);
				// TypeScriptWalker.g3:149:4: x= withStatement
				{
				DebugLocation(149, 5);
				PushFollow(Follow._withStatement_in_statement354);
				x=withStatement();
				PopFollow();


				}
				break;
			case 12:
				DebugEnterAlt(12);
				// TypeScriptWalker.g3:150:4: x= labelledStatement
				{
				DebugLocation(150, 5);
				PushFollow(Follow._labelledStatement_in_statement361);
				x=labelledStatement();
				PopFollow();


				}
				break;
			case 13:
				DebugEnterAlt(13);
				// TypeScriptWalker.g3:151:4: x= switchStatement
				{
				DebugLocation(151, 5);
				PushFollow(Follow._switchStatement_in_statement368);
				x=switchStatement();
				PopFollow();


				}
				break;
			case 14:
				DebugEnterAlt(14);
				// TypeScriptWalker.g3:152:4: x= throwStatement
				{
				DebugLocation(152, 5);
				PushFollow(Follow._throwStatement_in_statement375);
				x=throwStatement();
				PopFollow();


				}
				break;
			case 15:
				DebugEnterAlt(15);
				// TypeScriptWalker.g3:153:4: x= tryStatement
				{
				DebugLocation(153, 5);
				PushFollow(Follow._tryStatement_in_statement382);
				x=tryStatement();
				PopFollow();


				}
				break;
			case 16:
				DebugEnterAlt(16);
				// TypeScriptWalker.g3:154:4: x= functionDeclaration
				{
				DebugLocation(154, 5);
				PushFollow(Follow._functionDeclaration_in_statement389);
				x=functionDeclaration();
				PopFollow();


				}
				break;
			case 17:
				DebugEnterAlt(17);
				// TypeScriptWalker.g3:155:4: x= gotoStatement
				{
				DebugLocation(155, 5);
				PushFollow(Follow._gotoStatement_in_statement396);
				x=gotoStatement();
				PopFollow();


				}
				break;
			case 18:
				DebugEnterAlt(18);
				// TypeScriptWalker.g3:156:4: x= yieldStatement
				{
				DebugLocation(156, 5);
				PushFollow(Follow._yieldStatement_in_statement403);
				x=yieldStatement();
				PopFollow();


				}
				break;
			case 19:
				DebugEnterAlt(19);
				// TypeScriptWalker.g3:157:4: x= awaitStatement
				{
				DebugLocation(157, 5);
				PushFollow(Follow._awaitStatement_in_statement410);
				x=awaitStatement();
				PopFollow();


				}
				break;
			case 20:
				DebugEnterAlt(20);
				// TypeScriptWalker.g3:158:4: SEMIC
				{
				DebugLocation(158, 4);
				Match(input,SEMIC,Follow._SEMIC_in_statement415); 
				DebugLocation(158, 10);
				 x = new JsEmptyStatement(); 

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(159, 2);
			 result = x; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statement", 4);
			LeaveRule("statement", 4);
			LeaveRule_statement();
		}
		DebugLocation(160, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return result;

	}
	// $ANTLR end "statement"

	partial void EnterRule_block();
	partial void LeaveRule_block();
	// $ANTLR start "block"
	// TypeScriptWalker.g3:162:1: block returns [JsStatement result] : ^( BLOCK (s= statement )* ) ;
	[GrammarRule("block")]
	private JsStatement block()
	{
		EnterRule_block();
		EnterRule("block", 5);
		TraceIn("block", 5);
		JsStatement result = default(JsStatement);


		JsStatement s = default(JsStatement);

		 var stmts = new List<JsStatement>(); 
		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(162, 1);
		try
		{
			// TypeScriptWalker.g3:164:2: ( ^( BLOCK (s= statement )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:164:4: ^( BLOCK (s= statement )* )
			{
			DebugLocation(164, 4);
			DebugLocation(164, 7);
			Match(input,BLOCK,Follow._BLOCK_in_block444); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(164, 13);
				// TypeScriptWalker.g3:164:13: (s= statement )*
				try { DebugEnterSubRule(4);
				while (true)
				{
					int alt4=2;
					try { DebugEnterDecision(4, false);
					try
					{
						alt4 = dfa4.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(4); }
					switch ( alt4 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:164:14: s= statement
						{
						DebugLocation(164, 15);
						PushFollow(Follow._statement_in_block449);
						s=statement();
						PopFollow();

						DebugLocation(164, 26);
						 stmts.Add(s); 

						}
						break;

					default:
						goto loop4;
					}
				}

				loop4:
					;

				} finally { DebugExitSubRule(4); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(165, 2);
			 result = new JsBlockStatement(stmts); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("block", 5);
			LeaveRule("block", 5);
			LeaveRule_block();
		}
		DebugLocation(166, 1);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return result;

	}
	// $ANTLR end "block"

	partial void EnterRule_variableDeclaration();
	partial void LeaveRule_variableDeclaration();
	// $ANTLR start "variableDeclaration"
	// TypeScriptWalker.g3:168:1: variableDeclaration returns [JsStatement result] : ^( VAR ( (i= identifier (a= typeAnnotation )? ( ASSIGN e= expression )? ) )+ ) ;
	[GrammarRule("variableDeclaration")]
	private JsStatement variableDeclaration()
	{
		EnterRule_variableDeclaration();
		EnterRule("variableDeclaration", 6);
		TraceIn("variableDeclaration", 6);
		JsStatement result = default(JsStatement);


		string i = default(string);
		TsType a = default(TsType);
		JsExpression e = default(JsExpression);

		 var vars = new List<JsVariableDeclaration>(); 
		try { DebugEnterRule(GrammarFileName, "variableDeclaration");
		DebugLocation(168, 1);
		try
		{
			// TypeScriptWalker.g3:170:2: ( ^( VAR ( (i= identifier (a= typeAnnotation )? ( ASSIGN e= expression )? ) )+ ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:170:4: ^( VAR ( (i= identifier (a= typeAnnotation )? ( ASSIGN e= expression )? ) )+ )
			{
			DebugLocation(170, 4);
			DebugLocation(170, 7);
			Match(input,VAR,Follow._VAR_in_variableDeclaration480); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(170, 11);
			// TypeScriptWalker.g3:170:11: ( (i= identifier (a= typeAnnotation )? ( ASSIGN e= expression )? ) )+
			int cnt7=0;
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==ANY||LA7_1==CONSTRUCTOR||LA7_1==DECLARE||LA7_1==FINAL||LA7_1==GET||LA7_1==Identifier||LA7_1==MODULE||LA7_1==NUMBER||LA7_1==REQUIRE||LA7_1==SET||LA7_1==STRING||LA7_1==THROWS||LA7_1==TYPE))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:170:12: (i= identifier (a= typeAnnotation )? ( ASSIGN e= expression )? )
					{
					DebugLocation(170, 12);
					// TypeScriptWalker.g3:170:12: (i= identifier (a= typeAnnotation )? ( ASSIGN e= expression )? )
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:170:13: i= identifier (a= typeAnnotation )? ( ASSIGN e= expression )?
					{
					DebugLocation(170, 14);
					PushFollow(Follow._identifier_in_variableDeclaration486);
					i=identifier();
					PopFollow();

					DebugLocation(170, 27);
					// TypeScriptWalker.g3:170:27: (a= typeAnnotation )?
					int alt5=2;
					try { DebugEnterSubRule(5);
					try { DebugEnterDecision(5, false);
					int LA5_1 = input.LA(1);

					if ((LA5_1==COLON))
					{
						alt5 = 1;
					}
					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:170:27: a= typeAnnotation
						{
						DebugLocation(170, 27);
						PushFollow(Follow._typeAnnotation_in_variableDeclaration490);
						a=typeAnnotation();
						PopFollow();


						}
						break;

					}
					} finally { DebugExitSubRule(5); }

					DebugLocation(170, 44);
					// TypeScriptWalker.g3:170:44: ( ASSIGN e= expression )?
					int alt6=2;
					try { DebugEnterSubRule(6);
					try { DebugEnterDecision(6, false);
					int LA6_1 = input.LA(1);

					if ((LA6_1==ASSIGN))
					{
						alt6 = 1;
					}
					} finally { DebugExitDecision(6); }
					switch (alt6)
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:170:45: ASSIGN e= expression
						{
						DebugLocation(170, 45);
						Match(input,ASSIGN,Follow._ASSIGN_in_variableDeclaration494); 
						DebugLocation(170, 53);
						PushFollow(Follow._expression_in_variableDeclaration498);
						e=expression();
						PopFollow();


						}
						break;

					}
					} finally { DebugExitSubRule(6); }


					}

					DebugLocation(170, 68);
					 vars.Add(new JsVariableDeclaration(i, e, a)); 

					}
					break;

				default:
					if (cnt7 >= 1)
						goto loop7;

					EarlyExitException eee7 = new EarlyExitException( 7, input );
					DebugRecognitionException(eee7);
					throw eee7;
				}
				cnt7++;
			}
			loop7:
				;

			} finally { DebugExitSubRule(7); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(171, 5);
			 result = new JsVariableDeclarationStatement(vars); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("variableDeclaration", 6);
			LeaveRule("variableDeclaration", 6);
			LeaveRule_variableDeclaration();
		}
		DebugLocation(172, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclaration"); }
		return result;

	}
	// $ANTLR end "variableDeclaration"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();
	// $ANTLR start "ifStatement"
	// TypeScriptWalker.g3:174:1: ifStatement returns [JsStatement result] : ^( IF x= expression a= statement (b= statement )? ) ;
	[GrammarRule("ifStatement")]
	private JsStatement ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 7);
		TraceIn("ifStatement", 7);
		JsStatement result = default(JsStatement);


		JsExpression x = default(JsExpression);
		JsStatement a = default(JsStatement);
		JsStatement b = default(JsStatement);

		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(174, 1);
		try
		{
			// TypeScriptWalker.g3:175:2: ( ^( IF x= expression a= statement (b= statement )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:175:4: ^( IF x= expression a= statement (b= statement )? )
			{
			DebugLocation(175, 4);
			DebugLocation(175, 7);
			Match(input,IF,Follow._IF_in_ifStatement529); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(175, 11);
			PushFollow(Follow._expression_in_ifStatement533);
			x=expression();
			PopFollow();

			DebugLocation(175, 24);
			PushFollow(Follow._statement_in_ifStatement537);
			a=statement();
			PopFollow();

			DebugLocation(175, 36);
			// TypeScriptWalker.g3:175:36: (b= statement )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			try
			{
				alt8 = dfa8.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:175:36: b= statement
				{
				DebugLocation(175, 36);
				PushFollow(Follow._statement_in_ifStatement541);
				b=statement();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(8); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(175, 50);
			 result = new JsIfStatement(x, a, b); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ifStatement", 7);
			LeaveRule("ifStatement", 7);
			LeaveRule_ifStatement();
		}
		DebugLocation(176, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return result;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_doStatement();
	partial void LeaveRule_doStatement();
	// $ANTLR start "doStatement"
	// TypeScriptWalker.g3:178:1: doStatement returns [JsStatement result] : ^( DO s= statement x= expression ) ;
	[GrammarRule("doStatement")]
	private JsStatement doStatement()
	{
		EnterRule_doStatement();
		EnterRule("doStatement", 8);
		TraceIn("doStatement", 8);
		JsStatement result = default(JsStatement);


		JsStatement s = default(JsStatement);
		JsExpression x = default(JsExpression);

		try { DebugEnterRule(GrammarFileName, "doStatement");
		DebugLocation(178, 1);
		try
		{
			// TypeScriptWalker.g3:179:2: ( ^( DO s= statement x= expression ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:179:4: ^( DO s= statement x= expression )
			{
			DebugLocation(179, 4);
			DebugLocation(179, 7);
			Match(input,DO,Follow._DO_in_doStatement563); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(179, 11);
			PushFollow(Follow._statement_in_doStatement567);
			s=statement();
			PopFollow();

			DebugLocation(179, 23);
			PushFollow(Follow._expression_in_doStatement571);
			x=expression();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(179, 37);
			 result = new JsDoWhileStatement(x, s); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("doStatement", 8);
			LeaveRule("doStatement", 8);
			LeaveRule_doStatement();
		}
		DebugLocation(180, 1);
		} finally { DebugExitRule(GrammarFileName, "doStatement"); }
		return result;

	}
	// $ANTLR end "doStatement"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();
	// $ANTLR start "whileStatement"
	// TypeScriptWalker.g3:182:1: whileStatement returns [JsStatement result] : ^( WHILE x= expression s= statement ) ;
	[GrammarRule("whileStatement")]
	private JsStatement whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 9);
		TraceIn("whileStatement", 9);
		JsStatement result = default(JsStatement);


		JsExpression x = default(JsExpression);
		JsStatement s = default(JsStatement);

		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(182, 1);
		try
		{
			// TypeScriptWalker.g3:183:2: ( ^( WHILE x= expression s= statement ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:183:4: ^( WHILE x= expression s= statement )
			{
			DebugLocation(183, 4);
			DebugLocation(183, 7);
			Match(input,WHILE,Follow._WHILE_in_whileStatement592); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(183, 14);
			PushFollow(Follow._expression_in_whileStatement596);
			x=expression();
			PopFollow();

			DebugLocation(183, 27);
			PushFollow(Follow._statement_in_whileStatement600);
			s=statement();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(183, 40);
			 result = new JsWhileStatement(x, s); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("whileStatement", 9);
			LeaveRule("whileStatement", 9);
			LeaveRule_whileStatement();
		}
		DebugLocation(184, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return result;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_forStatement();
	partial void LeaveRule_forStatement();
	// $ANTLR start "forStatement"
	// TypeScriptWalker.g3:186:1: forStatement returns [JsStatement result] : ^( FOR ( ( ^( FORSTEP (x= exprOptClause |d= variableDeclaration ) x= exprOptClause y= exprOptClause ) s= statement ) | ( ^( FORITER ( ^( EXPR i= identifier ) | ^( VAR i= identifier ) ) x= exprClause ) s= statement ) ) ) ;
	[GrammarRule("forStatement")]
	private JsStatement forStatement()
	{
		EnterRule_forStatement();
		EnterRule("forStatement", 10);
		TraceIn("forStatement", 10);
		JsStatement result = default(JsStatement);


		JsExpression x = default(JsExpression);
		JsStatement d = default(JsStatement);
		JsExpression y = default(JsExpression);
		JsStatement s = default(JsStatement);
		string i = default(string);

		try { DebugEnterRule(GrammarFileName, "forStatement");
		DebugLocation(186, 2);
		try
		{
			// TypeScriptWalker.g3:187:2: ( ^( FOR ( ( ^( FORSTEP (x= exprOptClause |d= variableDeclaration ) x= exprOptClause y= exprOptClause ) s= statement ) | ( ^( FORITER ( ^( EXPR i= identifier ) | ^( VAR i= identifier ) ) x= exprClause ) s= statement ) ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:187:4: ^( FOR ( ( ^( FORSTEP (x= exprOptClause |d= variableDeclaration ) x= exprOptClause y= exprOptClause ) s= statement ) | ( ^( FORITER ( ^( EXPR i= identifier ) | ^( VAR i= identifier ) ) x= exprClause ) s= statement ) ) )
			{
			DebugLocation(187, 4);
			DebugLocation(188, 2);
			Match(input,FOR,Follow._FOR_in_forStatement622); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(189, 2);
			// TypeScriptWalker.g3:189:2: ( ( ^( FORSTEP (x= exprOptClause |d= variableDeclaration ) x= exprOptClause y= exprOptClause ) s= statement ) | ( ^( FORITER ( ^( EXPR i= identifier ) | ^( VAR i= identifier ) ) x= exprClause ) s= statement ) )
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if ((LA11_1==FORSTEP))
			{
				alt11 = 1;
			}
			else if ((LA11_1==FORITER))
			{
				alt11 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:190:5: ( ^( FORSTEP (x= exprOptClause |d= variableDeclaration ) x= exprOptClause y= exprOptClause ) s= statement )
				{
				DebugLocation(190, 5);
				// TypeScriptWalker.g3:190:5: ( ^( FORSTEP (x= exprOptClause |d= variableDeclaration ) x= exprOptClause y= exprOptClause ) s= statement )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:190:7: ^( FORSTEP (x= exprOptClause |d= variableDeclaration ) x= exprOptClause y= exprOptClause ) s= statement
				{
				DebugLocation(190, 7);
				DebugLocation(190, 10);
				Match(input,FORSTEP,Follow._FORSTEP_in_forStatement636); 

				DebugLocation(190, 18);
				 JsStatement init = null; 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(190, 47);
				// TypeScriptWalker.g3:190:47: (x= exprOptClause |d= variableDeclaration )
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==EXPR))
				{
					alt9 = 1;
				}
				else if ((LA9_1==VAR))
				{
					alt9 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 9, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:190:49: x= exprOptClause
					{
					DebugLocation(190, 50);
					PushFollow(Follow._exprOptClause_in_forStatement644);
					x=exprOptClause();
					PopFollow();

					DebugLocation(190, 65);
					 init = x != null ? (JsStatement)new JsExpressionStatement(x) : new JsEmptyStatement(); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// TypeScriptWalker.g3:190:158: d= variableDeclaration
					{
					DebugLocation(190, 159);
					PushFollow(Follow._variableDeclaration_in_forStatement652);
					d=variableDeclaration();
					PopFollow();

					DebugLocation(190, 180);
					 init = d; 

					}
					break;

				}
				} finally { DebugExitSubRule(9); }

				DebugLocation(190, 197);
				PushFollow(Follow._exprOptClause_in_forStatement660);
				x=exprOptClause();
				PopFollow();

				DebugLocation(190, 213);
				PushFollow(Follow._exprOptClause_in_forStatement664);
				y=exprOptClause();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(190, 231);
				PushFollow(Follow._statement_in_forStatement670);
				s=statement();
				PopFollow();

				DebugLocation(190, 242);
				 result = new JsForStatement(init, x, y, s); 

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:191:5: ( ^( FORITER ( ^( EXPR i= identifier ) | ^( VAR i= identifier ) ) x= exprClause ) s= statement )
				{
				DebugLocation(191, 5);
				// TypeScriptWalker.g3:191:5: ( ^( FORITER ( ^( EXPR i= identifier ) | ^( VAR i= identifier ) ) x= exprClause ) s= statement )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:191:7: ^( FORITER ( ^( EXPR i= identifier ) | ^( VAR i= identifier ) ) x= exprClause ) s= statement
				{
				DebugLocation(191, 7);
				DebugLocation(191, 10);
				Match(input,FORITER,Follow._FORITER_in_forStatement684); 

				DebugLocation(191, 18);
				 bool isDeclared = false; 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(191, 47);
				// TypeScriptWalker.g3:191:47: ( ^( EXPR i= identifier ) | ^( VAR i= identifier ) )
				int alt10=2;
				try { DebugEnterSubRule(10);
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1==EXPR))
				{
					alt10 = 1;
				}
				else if ((LA10_1==VAR))
				{
					alt10 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:191:49: ^( EXPR i= identifier )
					{
					DebugLocation(191, 49);
					DebugLocation(191, 52);
					Match(input,EXPR,Follow._EXPR_in_forStatement692); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(191, 58);
					PushFollow(Follow._identifier_in_forStatement696);
					i=identifier();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// TypeScriptWalker.g3:191:74: ^( VAR i= identifier )
					{
					DebugLocation(191, 74);
					DebugLocation(191, 77);
					Match(input,VAR,Follow._VAR_in_forStatement704); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(191, 82);
					PushFollow(Follow._identifier_in_forStatement708);
					i=identifier();
					PopFollow();

					DebugLocation(191, 94);
					 isDeclared = true; 

					Match(input, TokenTypes.Up, null); 


					}
					break;

				}
				} finally { DebugExitSubRule(10); }

				DebugLocation(191, 122);
				PushFollow(Follow._exprClause_in_forStatement718);
				x=exprClause();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(191, 137);
				PushFollow(Follow._statement_in_forStatement724);
				s=statement();
				PopFollow();

				DebugLocation(191, 148);
				 result = new JsForEachInStatement(i, x, s, isDeclared); 

				}


				}
				break;

			}
			} finally { DebugExitSubRule(11); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("forStatement", 10);
			LeaveRule("forStatement", 10);
			LeaveRule_forStatement();
		}
		DebugLocation(193, 2);
		} finally { DebugExitRule(GrammarFileName, "forStatement"); }
		return result;

	}
	// $ANTLR end "forStatement"

	partial void EnterRule_exprOptClause();
	partial void LeaveRule_exprOptClause();
	// $ANTLR start "exprOptClause"
	// TypeScriptWalker.g3:195:1: exprOptClause returns [JsExpression result] : ^( EXPR (x= expression )? ) ;
	[GrammarRule("exprOptClause")]
	private JsExpression exprOptClause()
	{
		EnterRule_exprOptClause();
		EnterRule("exprOptClause", 11);
		TraceIn("exprOptClause", 11);
		JsExpression result = default(JsExpression);


		JsExpression x = default(JsExpression);

		try { DebugEnterRule(GrammarFileName, "exprOptClause");
		DebugLocation(195, 1);
		try
		{
			// TypeScriptWalker.g3:196:2: ( ^( EXPR (x= expression )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:196:4: ^( EXPR (x= expression )? )
			{
			DebugLocation(196, 4);
			DebugLocation(196, 7);
			Match(input,EXPR,Follow._EXPR_in_exprOptClause749); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(196, 13);
				// TypeScriptWalker.g3:196:13: (x= expression )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				try
				{
					alt12 = dfa12.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:196:13: x= expression
					{
					DebugLocation(196, 13);
					PushFollow(Follow._expression_in_exprOptClause753);
					x=expression();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(12); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(196, 28);
			 result = x; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exprOptClause", 11);
			LeaveRule("exprOptClause", 11);
			LeaveRule_exprOptClause();
		}
		DebugLocation(197, 1);
		} finally { DebugExitRule(GrammarFileName, "exprOptClause"); }
		return result;

	}
	// $ANTLR end "exprOptClause"

	partial void EnterRule_exprClause();
	partial void LeaveRule_exprClause();
	// $ANTLR start "exprClause"
	// TypeScriptWalker.g3:199:1: exprClause returns [JsExpression result] : ^( EXPR x= expression ) ;
	[GrammarRule("exprClause")]
	private JsExpression exprClause()
	{
		EnterRule_exprClause();
		EnterRule("exprClause", 12);
		TraceIn("exprClause", 12);
		JsExpression result = default(JsExpression);


		JsExpression x = default(JsExpression);

		try { DebugEnterRule(GrammarFileName, "exprClause");
		DebugLocation(199, 1);
		try
		{
			// TypeScriptWalker.g3:200:2: ( ^( EXPR x= expression ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:200:4: ^( EXPR x= expression )
			{
			DebugLocation(200, 4);
			DebugLocation(200, 7);
			Match(input,EXPR,Follow._EXPR_in_exprClause775); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(200, 13);
			PushFollow(Follow._expression_in_exprClause779);
			x=expression();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(200, 27);
			 result = x; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exprClause", 12);
			LeaveRule("exprClause", 12);
			LeaveRule_exprClause();
		}
		DebugLocation(201, 1);
		} finally { DebugExitRule(GrammarFileName, "exprClause"); }
		return result;

	}
	// $ANTLR end "exprClause"

	partial void EnterRule_continueStatement();
	partial void LeaveRule_continueStatement();
	// $ANTLR start "continueStatement"
	// TypeScriptWalker.g3:203:1: continueStatement returns [JsStatement result] : ^( CONTINUE (i= identifier )? ) ;
	[GrammarRule("continueStatement")]
	private JsStatement continueStatement()
	{
		EnterRule_continueStatement();
		EnterRule("continueStatement", 13);
		TraceIn("continueStatement", 13);
		JsStatement result = default(JsStatement);


		string i = default(string);

		try { DebugEnterRule(GrammarFileName, "continueStatement");
		DebugLocation(203, 1);
		try
		{
			// TypeScriptWalker.g3:204:2: ( ^( CONTINUE (i= identifier )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:204:4: ^( CONTINUE (i= identifier )? )
			{
			DebugLocation(204, 4);
			DebugLocation(204, 7);
			Match(input,CONTINUE,Follow._CONTINUE_in_continueStatement800); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(204, 17);
				// TypeScriptWalker.g3:204:17: (i= identifier )?
				int alt13=2;
				try { DebugEnterSubRule(13);
				try { DebugEnterDecision(13, false);
				int LA13_1 = input.LA(1);

				if ((LA13_1==ANY||LA13_1==CONSTRUCTOR||LA13_1==DECLARE||LA13_1==FINAL||LA13_1==GET||LA13_1==Identifier||LA13_1==MODULE||LA13_1==NUMBER||LA13_1==REQUIRE||LA13_1==SET||LA13_1==STRING||LA13_1==THROWS||LA13_1==TYPE))
				{
					alt13 = 1;
				}
				} finally { DebugExitDecision(13); }
				switch (alt13)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:204:17: i= identifier
					{
					DebugLocation(204, 17);
					PushFollow(Follow._identifier_in_continueStatement804);
					i=identifier();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(13); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(204, 32);
			 result = new JsContinueStatement(i != null ? i : null); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("continueStatement", 13);
			LeaveRule("continueStatement", 13);
			LeaveRule_continueStatement();
		}
		DebugLocation(205, 1);
		} finally { DebugExitRule(GrammarFileName, "continueStatement"); }
		return result;

	}
	// $ANTLR end "continueStatement"

	partial void EnterRule_breakStatement();
	partial void LeaveRule_breakStatement();
	// $ANTLR start "breakStatement"
	// TypeScriptWalker.g3:207:1: breakStatement returns [JsStatement result] : ^( BREAK (i= identifier )? ) ;
	[GrammarRule("breakStatement")]
	private JsStatement breakStatement()
	{
		EnterRule_breakStatement();
		EnterRule("breakStatement", 14);
		TraceIn("breakStatement", 14);
		JsStatement result = default(JsStatement);


		string i = default(string);

		try { DebugEnterRule(GrammarFileName, "breakStatement");
		DebugLocation(207, 1);
		try
		{
			// TypeScriptWalker.g3:208:2: ( ^( BREAK (i= identifier )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:208:4: ^( BREAK (i= identifier )? )
			{
			DebugLocation(208, 4);
			DebugLocation(208, 7);
			Match(input,BREAK,Follow._BREAK_in_breakStatement826); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(208, 14);
				// TypeScriptWalker.g3:208:14: (i= identifier )?
				int alt14=2;
				try { DebugEnterSubRule(14);
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if ((LA14_1==ANY||LA14_1==CONSTRUCTOR||LA14_1==DECLARE||LA14_1==FINAL||LA14_1==GET||LA14_1==Identifier||LA14_1==MODULE||LA14_1==NUMBER||LA14_1==REQUIRE||LA14_1==SET||LA14_1==STRING||LA14_1==THROWS||LA14_1==TYPE))
				{
					alt14 = 1;
				}
				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:208:14: i= identifier
					{
					DebugLocation(208, 14);
					PushFollow(Follow._identifier_in_breakStatement830);
					i=identifier();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(14); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(208, 29);
			 result = new JsBreakStatement(i != null ? i : null); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("breakStatement", 14);
			LeaveRule("breakStatement", 14);
			LeaveRule_breakStatement();
		}
		DebugLocation(209, 1);
		} finally { DebugExitRule(GrammarFileName, "breakStatement"); }
		return result;

	}
	// $ANTLR end "breakStatement"

	partial void EnterRule_returnStatement();
	partial void LeaveRule_returnStatement();
	// $ANTLR start "returnStatement"
	// TypeScriptWalker.g3:211:1: returnStatement returns [JsStatement result] : ^( RETURN (x= expression )? ) ;
	[GrammarRule("returnStatement")]
	private JsStatement returnStatement()
	{
		EnterRule_returnStatement();
		EnterRule("returnStatement", 15);
		TraceIn("returnStatement", 15);
		JsStatement result = default(JsStatement);


		JsExpression x = default(JsExpression);

		try { DebugEnterRule(GrammarFileName, "returnStatement");
		DebugLocation(211, 1);
		try
		{
			// TypeScriptWalker.g3:212:2: ( ^( RETURN (x= expression )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:212:4: ^( RETURN (x= expression )? )
			{
			DebugLocation(212, 4);
			DebugLocation(212, 7);
			Match(input,RETURN,Follow._RETURN_in_returnStatement852); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(212, 15);
				// TypeScriptWalker.g3:212:15: (x= expression )?
				int alt15=2;
				try { DebugEnterSubRule(15);
				try { DebugEnterDecision(15, false);
				try
				{
					alt15 = dfa15.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:212:15: x= expression
					{
					DebugLocation(212, 15);
					PushFollow(Follow._expression_in_returnStatement857);
					x=expression();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(15); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(212, 31);
			 result = new JsReturnStatement(x); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("returnStatement", 15);
			LeaveRule("returnStatement", 15);
			LeaveRule_returnStatement();
		}
		DebugLocation(213, 1);
		} finally { DebugExitRule(GrammarFileName, "returnStatement"); }
		return result;

	}
	// $ANTLR end "returnStatement"

	partial void EnterRule_withStatement();
	partial void LeaveRule_withStatement();
	// $ANTLR start "withStatement"
	// TypeScriptWalker.g3:215:1: withStatement returns [JsStatement result] : ^( WITH x= expression s= statement ) ;
	[GrammarRule("withStatement")]
	private JsStatement withStatement()
	{
		EnterRule_withStatement();
		EnterRule("withStatement", 16);
		TraceIn("withStatement", 16);
		JsStatement result = default(JsStatement);


		JsExpression x = default(JsExpression);
		JsStatement s = default(JsStatement);

		try { DebugEnterRule(GrammarFileName, "withStatement");
		DebugLocation(215, 1);
		try
		{
			// TypeScriptWalker.g3:216:2: ( ^( WITH x= expression s= statement ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:216:4: ^( WITH x= expression s= statement )
			{
			DebugLocation(216, 4);
			DebugLocation(216, 7);
			Match(input,WITH,Follow._WITH_in_withStatement879); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(216, 13);
			PushFollow(Follow._expression_in_withStatement883);
			x=expression();
			PopFollow();

			DebugLocation(216, 26);
			PushFollow(Follow._statement_in_withStatement887);
			s=statement();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(216, 39);
			 result = new JsWithStatement(x, s); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("withStatement", 16);
			LeaveRule("withStatement", 16);
			LeaveRule_withStatement();
		}
		DebugLocation(217, 1);
		} finally { DebugExitRule(GrammarFileName, "withStatement"); }
		return result;

	}
	// $ANTLR end "withStatement"

	partial void EnterRule_labelledStatement();
	partial void LeaveRule_labelledStatement();
	// $ANTLR start "labelledStatement"
	// TypeScriptWalker.g3:219:1: labelledStatement returns [JsStatement result] : ^( LABELLED i= identifier s= statement ) ;
	[GrammarRule("labelledStatement")]
	private JsStatement labelledStatement()
	{
		EnterRule_labelledStatement();
		EnterRule("labelledStatement", 17);
		TraceIn("labelledStatement", 17);
		JsStatement result = default(JsStatement);


		string i = default(string);
		JsStatement s = default(JsStatement);

		try { DebugEnterRule(GrammarFileName, "labelledStatement");
		DebugLocation(219, 1);
		try
		{
			// TypeScriptWalker.g3:220:2: ( ^( LABELLED i= identifier s= statement ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:220:4: ^( LABELLED i= identifier s= statement )
			{
			DebugLocation(220, 4);
			DebugLocation(220, 7);
			Match(input,LABELLED,Follow._LABELLED_in_labelledStatement908); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(220, 17);
			PushFollow(Follow._identifier_in_labelledStatement912);
			i=identifier();
			PopFollow();

			DebugLocation(220, 30);
			PushFollow(Follow._statement_in_labelledStatement916);
			s=statement();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(220, 43);
			 result = new JsLabelledStatement(i, s); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("labelledStatement", 17);
			LeaveRule("labelledStatement", 17);
			LeaveRule_labelledStatement();
		}
		DebugLocation(221, 1);
		} finally { DebugExitRule(GrammarFileName, "labelledStatement"); }
		return result;

	}
	// $ANTLR end "labelledStatement"

	partial void EnterRule_switchStatement();
	partial void LeaveRule_switchStatement();
	// $ANTLR start "switchStatement"
	// TypeScriptWalker.g3:223:1: switchStatement returns [JsStatement result] : ^( SWITCH x= expression ( (d= defaultClause |c= caseClause ) )* ) ;
	[GrammarRule("switchStatement")]
	private JsStatement switchStatement()
	{
		EnterRule_switchStatement();
		EnterRule("switchStatement", 18);
		TraceIn("switchStatement", 18);
		JsStatement result = default(JsStatement);


		JsExpression x = default(JsExpression);
		List<JsStatement> d = default(List<JsStatement>);
		Tuple<JsExpression, List<JsStatement>> c = default(Tuple<JsExpression, List<JsStatement>>);

		 var sections = new List<JsSwitchSection>(); 
		try { DebugEnterRule(GrammarFileName, "switchStatement");
		DebugLocation(223, 1);
		try
		{
			// TypeScriptWalker.g3:225:2: ( ^( SWITCH x= expression ( (d= defaultClause |c= caseClause ) )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:225:4: ^( SWITCH x= expression ( (d= defaultClause |c= caseClause ) )* )
			{
			DebugLocation(225, 4);
			DebugLocation(225, 7);
			Match(input,SWITCH,Follow._SWITCH_in_switchStatement942); 

			DebugLocation(225, 14);
			 var values = new List<JsExpression>(); List<JsStatement> stmts = null; 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(225, 90);
			PushFollow(Follow._expression_in_switchStatement948);
			x=expression();
			PopFollow();

			DebugLocation(226, 7);
			// TypeScriptWalker.g3:226:7: ( (d= defaultClause |c= caseClause ) )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1==CASE||LA17_1==DEFAULT))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:226:8: (d= defaultClause |c= caseClause )
					{
					DebugLocation(226, 8);
					// TypeScriptWalker.g3:226:8: (d= defaultClause |c= caseClause )
					int alt16=2;
					try { DebugEnterSubRule(16);
					try { DebugEnterDecision(16, false);
					int LA16_1 = input.LA(1);

					if ((LA16_1==DEFAULT))
					{
						alt16 = 1;
					}
					else if ((LA16_1==CASE))
					{
						alt16 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(16); }
					switch (alt16)
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:227:4: d= defaultClause
						{
						DebugLocation(227, 5);
						PushFollow(Follow._defaultClause_in_switchStatement964);
						d=defaultClause();
						PopFollow();

						DebugLocation(227, 20);
						 values.Add(null); stmts = d; 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// TypeScriptWalker.g3:228:7: c= caseClause
						{
						DebugLocation(228, 8);
						PushFollow(Follow._caseClause_in_switchStatement976);
						c=caseClause();
						PopFollow();

						DebugLocation(228, 20);
						 values.Add(c.Item1); stmts = c.Item2; 

						}
						break;

					}
					} finally { DebugExitSubRule(16); }

					DebugLocation(229, 12);
					 if (stmts != null) { sections.Add(new JsSwitchSection(values, stmts.Count == 1 ? JsBlockStatement.MakeBlock(stmts[0]) : new JsBlockStatement(stmts))); values = new List<JsExpression>(); } 

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(230, 7);
			 if (values.Count > 0) { sections.Add(new JsSwitchSection(values, JsBlockStatement.EmptyStatement)); } result = new JsSwitchStatement(x, sections); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("switchStatement", 18);
			LeaveRule("switchStatement", 18);
			LeaveRule_switchStatement();
		}
		DebugLocation(231, 1);
		} finally { DebugExitRule(GrammarFileName, "switchStatement"); }
		return result;

	}
	// $ANTLR end "switchStatement"

	partial void EnterRule_defaultClause();
	partial void LeaveRule_defaultClause();
	// $ANTLR start "defaultClause"
	// TypeScriptWalker.g3:233:1: defaultClause returns [List<JsStatement> result] : ^( DEFAULT (s= statement )* ) ;
	[GrammarRule("defaultClause")]
	private List<JsStatement> defaultClause()
	{
		EnterRule_defaultClause();
		EnterRule("defaultClause", 19);
		TraceIn("defaultClause", 19);
		List<JsStatement> result = default(List<JsStatement>);


		JsStatement s = default(JsStatement);

		try { DebugEnterRule(GrammarFileName, "defaultClause");
		DebugLocation(233, 1);
		try
		{
			// TypeScriptWalker.g3:234:2: ( ^( DEFAULT (s= statement )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:234:4: ^( DEFAULT (s= statement )* )
			{
			DebugLocation(234, 4);
			DebugLocation(234, 7);
			Match(input,DEFAULT,Follow._DEFAULT_in_defaultClause1019); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(234, 15);
				// TypeScriptWalker.g3:234:15: (s= statement )*
				try { DebugEnterSubRule(18);
				while (true)
				{
					int alt18=2;
					try { DebugEnterDecision(18, false);
					try
					{
						alt18 = dfa18.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(18); }
					switch ( alt18 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:234:16: s= statement
						{
						DebugLocation(234, 17);
						PushFollow(Follow._statement_in_defaultClause1024);
						s=statement();
						PopFollow();

						DebugLocation(234, 28);
						 result = result ?? new List<JsStatement>(); result.Add(s); 

						}
						break;

					default:
						goto loop18;
					}
				}

				loop18:
					;

				} finally { DebugExitSubRule(18); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("defaultClause", 19);
			LeaveRule("defaultClause", 19);
			LeaveRule_defaultClause();
		}
		DebugLocation(235, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultClause"); }
		return result;

	}
	// $ANTLR end "defaultClause"

	partial void EnterRule_caseClause();
	partial void LeaveRule_caseClause();
	// $ANTLR start "caseClause"
	// TypeScriptWalker.g3:237:1: caseClause returns [Tuple<JsExpression, List<JsStatement>> result] : ^( CASE x= expression (s= statement )* ) ;
	[GrammarRule("caseClause")]
	private Tuple<JsExpression, List<JsStatement>> caseClause()
	{
		EnterRule_caseClause();
		EnterRule("caseClause", 20);
		TraceIn("caseClause", 20);
		Tuple<JsExpression, List<JsStatement>> result = default(Tuple<JsExpression, List<JsStatement>>);


		JsExpression x = default(JsExpression);
		JsStatement s = default(JsStatement);

		 List<JsStatement> stmts = null; 
		try { DebugEnterRule(GrammarFileName, "caseClause");
		DebugLocation(237, 1);
		try
		{
			// TypeScriptWalker.g3:239:2: ( ^( CASE x= expression (s= statement )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:239:4: ^( CASE x= expression (s= statement )* )
			{
			DebugLocation(239, 4);
			DebugLocation(239, 7);
			Match(input,CASE,Follow._CASE_in_caseClause1052); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(239, 13);
			PushFollow(Follow._expression_in_caseClause1056);
			x=expression();
			PopFollow();

			DebugLocation(239, 25);
			// TypeScriptWalker.g3:239:25: (s= statement )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				try
				{
					alt19 = dfa19.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:239:26: s= statement
					{
					DebugLocation(239, 27);
					PushFollow(Follow._statement_in_caseClause1061);
					s=statement();
					PopFollow();

					DebugLocation(239, 38);
					 stmts = stmts ?? new List<JsStatement>(); stmts.Add(s); 

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(239, 102);
			 result = Tuple.Create(x, stmts); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("caseClause", 20);
			LeaveRule("caseClause", 20);
			LeaveRule_caseClause();
		}
		DebugLocation(240, 1);
		} finally { DebugExitRule(GrammarFileName, "caseClause"); }
		return result;

	}
	// $ANTLR end "caseClause"

	partial void EnterRule_throwStatement();
	partial void LeaveRule_throwStatement();
	// $ANTLR start "throwStatement"
	// TypeScriptWalker.g3:242:1: throwStatement returns [JsStatement result] : ^( THROW x= expression ) ;
	[GrammarRule("throwStatement")]
	private JsStatement throwStatement()
	{
		EnterRule_throwStatement();
		EnterRule("throwStatement", 21);
		TraceIn("throwStatement", 21);
		JsStatement result = default(JsStatement);


		JsExpression x = default(JsExpression);

		try { DebugEnterRule(GrammarFileName, "throwStatement");
		DebugLocation(242, 1);
		try
		{
			// TypeScriptWalker.g3:243:2: ( ^( THROW x= expression ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:243:4: ^( THROW x= expression )
			{
			DebugLocation(243, 4);
			DebugLocation(243, 7);
			Match(input,THROW,Follow._THROW_in_throwStatement1086); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(243, 14);
			PushFollow(Follow._expression_in_throwStatement1090);
			x=expression();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(243, 28);
			 result = new JsThrowStatement(x); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("throwStatement", 21);
			LeaveRule("throwStatement", 21);
			LeaveRule_throwStatement();
		}
		DebugLocation(244, 1);
		} finally { DebugExitRule(GrammarFileName, "throwStatement"); }
		return result;

	}
	// $ANTLR end "throwStatement"

	partial void EnterRule_tryStatement();
	partial void LeaveRule_tryStatement();
	// $ANTLR start "tryStatement"
	// TypeScriptWalker.g3:246:1: tryStatement returns [JsStatement result] : ^( TRY a= block (b= catchClause )? (c= finallyClause )? ) ;
	[GrammarRule("tryStatement")]
	private JsStatement tryStatement()
	{
		EnterRule_tryStatement();
		EnterRule("tryStatement", 22);
		TraceIn("tryStatement", 22);
		JsStatement result = default(JsStatement);


		JsStatement a = default(JsStatement);
		JsCatchClause b = default(JsCatchClause);
		JsStatement c = default(JsStatement);

		try { DebugEnterRule(GrammarFileName, "tryStatement");
		DebugLocation(246, 1);
		try
		{
			// TypeScriptWalker.g3:247:2: ( ^( TRY a= block (b= catchClause )? (c= finallyClause )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:247:4: ^( TRY a= block (b= catchClause )? (c= finallyClause )? )
			{
			DebugLocation(247, 4);
			DebugLocation(247, 7);
			Match(input,TRY,Follow._TRY_in_tryStatement1111); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(247, 12);
			PushFollow(Follow._block_in_tryStatement1115);
			a=block();
			PopFollow();

			DebugLocation(247, 20);
			// TypeScriptWalker.g3:247:20: (b= catchClause )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_1 = input.LA(1);

			if ((LA20_1==CATCH))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:247:20: b= catchClause
				{
				DebugLocation(247, 20);
				PushFollow(Follow._catchClause_in_tryStatement1119);
				b=catchClause();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(247, 35);
			// TypeScriptWalker.g3:247:35: (c= finallyClause )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_1 = input.LA(1);

			if ((LA21_1==FINALLY))
			{
				alt21 = 1;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:247:35: c= finallyClause
				{
				DebugLocation(247, 35);
				PushFollow(Follow._finallyClause_in_tryStatement1124);
				c=finallyClause();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(21); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(247, 53);
			 result = new JsTryStatement(a, b, c); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("tryStatement", 22);
			LeaveRule("tryStatement", 22);
			LeaveRule_tryStatement();
		}
		DebugLocation(248, 1);
		} finally { DebugExitRule(GrammarFileName, "tryStatement"); }
		return result;

	}
	// $ANTLR end "tryStatement"

	partial void EnterRule_catchClause();
	partial void LeaveRule_catchClause();
	// $ANTLR start "catchClause"
	// TypeScriptWalker.g3:250:1: catchClause returns [JsCatchClause result] : ^( CATCH i= identifier b= block ) ;
	[GrammarRule("catchClause")]
	private JsCatchClause catchClause()
	{
		EnterRule_catchClause();
		EnterRule("catchClause", 23);
		TraceIn("catchClause", 23);
		JsCatchClause result = default(JsCatchClause);


		string i = default(string);
		JsStatement b = default(JsStatement);

		try { DebugEnterRule(GrammarFileName, "catchClause");
		DebugLocation(250, 1);
		try
		{
			// TypeScriptWalker.g3:251:2: ( ^( CATCH i= identifier b= block ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:251:4: ^( CATCH i= identifier b= block )
			{
			DebugLocation(251, 4);
			DebugLocation(251, 7);
			Match(input,CATCH,Follow._CATCH_in_catchClause1147); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(251, 14);
			PushFollow(Follow._identifier_in_catchClause1151);
			i=identifier();
			PopFollow();

			DebugLocation(251, 27);
			PushFollow(Follow._block_in_catchClause1155);
			b=block();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(251, 36);
			 result = new JsCatchClause(i, b); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("catchClause", 23);
			LeaveRule("catchClause", 23);
			LeaveRule_catchClause();
		}
		DebugLocation(252, 1);
		} finally { DebugExitRule(GrammarFileName, "catchClause"); }
		return result;

	}
	// $ANTLR end "catchClause"

	partial void EnterRule_finallyClause();
	partial void LeaveRule_finallyClause();
	// $ANTLR start "finallyClause"
	// TypeScriptWalker.g3:254:1: finallyClause returns [JsStatement result] : ^( FINALLY b= block ) ;
	[GrammarRule("finallyClause")]
	private JsStatement finallyClause()
	{
		EnterRule_finallyClause();
		EnterRule("finallyClause", 24);
		TraceIn("finallyClause", 24);
		JsStatement result = default(JsStatement);


		JsStatement b = default(JsStatement);

		try { DebugEnterRule(GrammarFileName, "finallyClause");
		DebugLocation(254, 1);
		try
		{
			// TypeScriptWalker.g3:255:2: ( ^( FINALLY b= block ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:255:4: ^( FINALLY b= block )
			{
			DebugLocation(255, 4);
			DebugLocation(255, 7);
			Match(input,FINALLY,Follow._FINALLY_in_finallyClause1177); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(255, 16);
			PushFollow(Follow._block_in_finallyClause1181);
			b=block();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(255, 25);
			 result = b; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("finallyClause", 24);
			LeaveRule("finallyClause", 24);
			LeaveRule_finallyClause();
		}
		DebugLocation(256, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyClause"); }
		return result;

	}
	// $ANTLR end "finallyClause"

	partial void EnterRule_gotoStatement();
	partial void LeaveRule_gotoStatement();
	// $ANTLR start "gotoStatement"
	// TypeScriptWalker.g3:258:1: gotoStatement returns [JsStatement result] : ^( GOTO i= identifier ) ;
	[GrammarRule("gotoStatement")]
	private JsStatement gotoStatement()
	{
		EnterRule_gotoStatement();
		EnterRule("gotoStatement", 25);
		TraceIn("gotoStatement", 25);
		JsStatement result = default(JsStatement);


		string i = default(string);

		try { DebugEnterRule(GrammarFileName, "gotoStatement");
		DebugLocation(258, 1);
		try
		{
			// TypeScriptWalker.g3:259:2: ( ^( GOTO i= identifier ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:259:4: ^( GOTO i= identifier )
			{
			DebugLocation(259, 4);
			DebugLocation(259, 7);
			Match(input,GOTO,Follow._GOTO_in_gotoStatement1202); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(259, 13);
			PushFollow(Follow._identifier_in_gotoStatement1206);
			i=identifier();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(259, 27);
			 result = new JsGotoStatement(i); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("gotoStatement", 25);
			LeaveRule("gotoStatement", 25);
			LeaveRule_gotoStatement();
		}
		DebugLocation(260, 1);
		} finally { DebugExitRule(GrammarFileName, "gotoStatement"); }
		return result;

	}
	// $ANTLR end "gotoStatement"

	partial void EnterRule_yieldStatement();
	partial void LeaveRule_yieldStatement();
	// $ANTLR start "yieldStatement"
	// TypeScriptWalker.g3:262:1: yieldStatement returns [JsStatement result] : ^( YIELD (x= expression )? ) ;
	[GrammarRule("yieldStatement")]
	private JsStatement yieldStatement()
	{
		EnterRule_yieldStatement();
		EnterRule("yieldStatement", 26);
		TraceIn("yieldStatement", 26);
		JsStatement result = default(JsStatement);


		JsExpression x = default(JsExpression);

		try { DebugEnterRule(GrammarFileName, "yieldStatement");
		DebugLocation(262, 1);
		try
		{
			// TypeScriptWalker.g3:263:2: ( ^( YIELD (x= expression )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:263:4: ^( YIELD (x= expression )? )
			{
			DebugLocation(263, 4);
			DebugLocation(263, 7);
			Match(input,YIELD,Follow._YIELD_in_yieldStatement1227); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(263, 14);
				// TypeScriptWalker.g3:263:14: (x= expression )?
				int alt22=2;
				try { DebugEnterSubRule(22);
				try { DebugEnterDecision(22, false);
				try
				{
					alt22 = dfa22.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:263:14: x= expression
					{
					DebugLocation(263, 14);
					PushFollow(Follow._expression_in_yieldStatement1231);
					x=expression();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(22); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(263, 29);
			 result = new JsYieldStatement(x); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("yieldStatement", 26);
			LeaveRule("yieldStatement", 26);
			LeaveRule_yieldStatement();
		}
		DebugLocation(264, 1);
		} finally { DebugExitRule(GrammarFileName, "yieldStatement"); }
		return result;

	}
	// $ANTLR end "yieldStatement"

	partial void EnterRule_awaitStatement();
	partial void LeaveRule_awaitStatement();
	// $ANTLR start "awaitStatement"
	// TypeScriptWalker.g3:266:1: awaitStatement returns [JsStatement result] : ^( AWAIT x= expression y= identifier ) ;
	[GrammarRule("awaitStatement")]
	private JsStatement awaitStatement()
	{
		EnterRule_awaitStatement();
		EnterRule("awaitStatement", 27);
		TraceIn("awaitStatement", 27);
		JsStatement result = default(JsStatement);


		JsExpression x = default(JsExpression);
		string y = default(string);

		try { DebugEnterRule(GrammarFileName, "awaitStatement");
		DebugLocation(266, 1);
		try
		{
			// TypeScriptWalker.g3:267:2: ( ^( AWAIT x= expression y= identifier ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:267:4: ^( AWAIT x= expression y= identifier )
			{
			DebugLocation(267, 4);
			DebugLocation(267, 7);
			Match(input,AWAIT,Follow._AWAIT_in_awaitStatement1253); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(267, 14);
			PushFollow(Follow._expression_in_awaitStatement1257);
			x=expression();
			PopFollow();

			DebugLocation(267, 27);
			PushFollow(Follow._identifier_in_awaitStatement1261);
			y=identifier();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(267, 41);
			 result = new JsAwaitStatement(x, y); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("awaitStatement", 27);
			LeaveRule("awaitStatement", 27);
			LeaveRule_awaitStatement();
		}
		DebugLocation(268, 1);
		} finally { DebugExitRule(GrammarFileName, "awaitStatement"); }
		return result;

	}
	// $ANTLR end "awaitStatement"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// TypeScriptWalker.g3:270:8: public expression returns [JsExpression result] : (x= expr | ^( CEXPR (x= expr )+ ) );
	[GrammarRule("expression")]
	public JsExpression expression()
	{
		EnterRule_expression();
		EnterRule("expression", 28);
		TraceIn("expression", 28);
		JsExpression result = default(JsExpression);


		JsExpression x = default(JsExpression);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(270, 1);
		try
		{
			// TypeScriptWalker.g3:271:2: (x= expr | ^( CEXPR (x= expr )+ ) )
			int alt24=2;
			try { DebugEnterDecision(24, false);
			try
			{
				alt24 = dfa24.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:271:4: x= expr
				{
				DebugLocation(271, 5);
				PushFollow(Follow._expr_in_expression1284);
				x=expr();
				PopFollow();

				DebugLocation(271, 11);
				 result = x; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:272:4: ^( CEXPR (x= expr )+ )
				{
				DebugLocation(272, 4);
				DebugLocation(272, 7);
				Match(input,CEXPR,Follow._CEXPR_in_expression1293); 

				DebugLocation(272, 13);
				 var list = new List<JsExpression>(); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(272, 54);
				// TypeScriptWalker.g3:272:54: (x= expr )+
				int cnt23=0;
				try { DebugEnterSubRule(23);
				while (true)
				{
					int alt23=2;
					try { DebugEnterDecision(23, false);
					try
					{
						alt23 = dfa23.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(23); }
					switch (alt23)
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:272:55: x= expr
						{
						DebugLocation(272, 56);
						PushFollow(Follow._expr_in_expression1300);
						x=expr();
						PopFollow();

						DebugLocation(272, 62);
						 list.Add(x); 

						}
						break;

					default:
						if (cnt23 >= 1)
							goto loop23;

						EarlyExitException eee23 = new EarlyExitException( 23, input );
						DebugRecognitionException(eee23);
						throw eee23;
					}
					cnt23++;
				}
				loop23:
					;

				} finally { DebugExitSubRule(23); }

				DebugLocation(272, 81);
				 result = JsExpression.Comma(list); 

				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 28);
			LeaveRule("expression", 28);
			LeaveRule_expression();
		}
		DebugLocation(273, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return result;

	}
	// $ANTLR end "expression"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();
	// $ANTLR start "expr"
	// TypeScriptWalker.g3:275:1: expr returns [JsExpression result] : (x= leftHandSideExpression | ^( ASSIGN a= expr b= expr ) | ^( MULASS a= expr b= expr ) | ^( DIVASS a= expr b= expr ) | ^( MODASS a= expr b= expr ) | ^( ADDASS a= expr b= expr ) | ^( SUBASS a= expr b= expr ) | ^( SHLASS a= expr b= expr ) | ^( SHRASS a= expr b= expr ) | ^( SHUASS a= expr b= expr ) | ^( ANDASS a= expr b= expr ) | ^( XORASS a= expr b= expr ) | ^( ORASS a= expr b= expr ) | ^( QUE a= expr b= expr c= expr ) | ^( LOR a= expr b= expr ) | ^( LAND a= expr b= expr ) | ^( AND a= expr b= expr ) | ^( OR a= expr b= expr ) | ^( XOR a= expr b= expr ) | ^( EQ a= expr b= expr ) | ^( NEQ a= expr b= expr ) | ^( SAME a= expr b= expr ) | ^( NSAME a= expr b= expr ) | ^( LT a= expr b= expr ) | ^( GT a= expr b= expr ) | ^( LTE a= expr b= expr ) | ^( GTE a= expr b= expr ) | ^( INSTANCEOF a= expr b= expr ) | ^( IN a= expr b= expr ) | ^( SHL a= expr b= expr ) | ^( SHR a= expr b= expr ) | ^( SHU a= expr b= expr ) | ^( ADD a= expr b= expr ) | ^( SUB a= expr b= expr ) | ^( MUL a= expr b= expr ) | ^( DIV a= expr b= expr ) | ^( MOD a= expr b= expr ) | ^( DELETE a= expr ) | ^( VOID a= expr ) | ^( TYPEOF a= expr ) | ^( INC a= expr ) | ^( DEC a= expr ) | ^( POS a= expr ) | ^( NEG a= expr ) | ^( INV a= expr ) | ^( NOT a= expr ) | ^( PINC a= expr ) | ^( PDEC a= expr ) );
	[GrammarRule("expr")]
	private JsExpression expr()
	{
		EnterRule_expr();
		EnterRule("expr", 29);
		TraceIn("expr", 29);
		JsExpression result = default(JsExpression);


		JsExpression x = default(JsExpression);
		JsExpression a = default(JsExpression);
		JsExpression b = default(JsExpression);
		JsExpression c = default(JsExpression);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(275, 1);
		try
		{
			// TypeScriptWalker.g3:276:2: (x= leftHandSideExpression | ^( ASSIGN a= expr b= expr ) | ^( MULASS a= expr b= expr ) | ^( DIVASS a= expr b= expr ) | ^( MODASS a= expr b= expr ) | ^( ADDASS a= expr b= expr ) | ^( SUBASS a= expr b= expr ) | ^( SHLASS a= expr b= expr ) | ^( SHRASS a= expr b= expr ) | ^( SHUASS a= expr b= expr ) | ^( ANDASS a= expr b= expr ) | ^( XORASS a= expr b= expr ) | ^( ORASS a= expr b= expr ) | ^( QUE a= expr b= expr c= expr ) | ^( LOR a= expr b= expr ) | ^( LAND a= expr b= expr ) | ^( AND a= expr b= expr ) | ^( OR a= expr b= expr ) | ^( XOR a= expr b= expr ) | ^( EQ a= expr b= expr ) | ^( NEQ a= expr b= expr ) | ^( SAME a= expr b= expr ) | ^( NSAME a= expr b= expr ) | ^( LT a= expr b= expr ) | ^( GT a= expr b= expr ) | ^( LTE a= expr b= expr ) | ^( GTE a= expr b= expr ) | ^( INSTANCEOF a= expr b= expr ) | ^( IN a= expr b= expr ) | ^( SHL a= expr b= expr ) | ^( SHR a= expr b= expr ) | ^( SHU a= expr b= expr ) | ^( ADD a= expr b= expr ) | ^( SUB a= expr b= expr ) | ^( MUL a= expr b= expr ) | ^( DIV a= expr b= expr ) | ^( MOD a= expr b= expr ) | ^( DELETE a= expr ) | ^( VOID a= expr ) | ^( TYPEOF a= expr ) | ^( INC a= expr ) | ^( DEC a= expr ) | ^( POS a= expr ) | ^( NEG a= expr ) | ^( INV a= expr ) | ^( NOT a= expr ) | ^( PINC a= expr ) | ^( PDEC a= expr ) )
			int alt25=48;
			try { DebugEnterDecision(25, false);
			try
			{
				alt25 = dfa25.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:276:4: x= leftHandSideExpression
				{
				DebugLocation(276, 5);
				PushFollow(Follow._leftHandSideExpression_in_expr1324);
				x=leftHandSideExpression();
				PopFollow();

				DebugLocation(276, 29);
				 result = x; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:279:4: ^( ASSIGN a= expr b= expr )
				{
				DebugLocation(279, 4);
				DebugLocation(279, 7);
				Match(input,ASSIGN,Follow._ASSIGN_in_expr1337); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(279, 15);
				PushFollow(Follow._expr_in_expr1341);
				a=expr();
				PopFollow();

				DebugLocation(279, 22);
				PushFollow(Follow._expr_in_expr1345);
				b=expr();
				PopFollow();

				DebugLocation(279, 28);
				 result = JsExpression.Assign(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:280:4: ^( MULASS a= expr b= expr )
				{
				DebugLocation(280, 4);
				DebugLocation(280, 7);
				Match(input,MULASS,Follow._MULASS_in_expr1356); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(280, 15);
				PushFollow(Follow._expr_in_expr1360);
				a=expr();
				PopFollow();

				DebugLocation(280, 22);
				PushFollow(Follow._expr_in_expr1364);
				b=expr();
				PopFollow();

				DebugLocation(280, 28);
				 result = JsExpression.MultiplyAssign(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScriptWalker.g3:281:4: ^( DIVASS a= expr b= expr )
				{
				DebugLocation(281, 4);
				DebugLocation(281, 7);
				Match(input,DIVASS,Follow._DIVASS_in_expr1375); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(281, 15);
				PushFollow(Follow._expr_in_expr1379);
				a=expr();
				PopFollow();

				DebugLocation(281, 22);
				PushFollow(Follow._expr_in_expr1383);
				b=expr();
				PopFollow();

				DebugLocation(281, 28);
				 result = JsExpression.DivideAssign(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScriptWalker.g3:282:4: ^( MODASS a= expr b= expr )
				{
				DebugLocation(282, 4);
				DebugLocation(282, 7);
				Match(input,MODASS,Follow._MODASS_in_expr1394); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(282, 15);
				PushFollow(Follow._expr_in_expr1398);
				a=expr();
				PopFollow();

				DebugLocation(282, 22);
				PushFollow(Follow._expr_in_expr1402);
				b=expr();
				PopFollow();

				DebugLocation(282, 28);
				 result = JsExpression.ModuloAssign(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScriptWalker.g3:283:4: ^( ADDASS a= expr b= expr )
				{
				DebugLocation(283, 4);
				DebugLocation(283, 7);
				Match(input,ADDASS,Follow._ADDASS_in_expr1413); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(283, 15);
				PushFollow(Follow._expr_in_expr1417);
				a=expr();
				PopFollow();

				DebugLocation(283, 22);
				PushFollow(Follow._expr_in_expr1421);
				b=expr();
				PopFollow();

				DebugLocation(283, 28);
				 result = JsExpression.AddAssign(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// TypeScriptWalker.g3:284:4: ^( SUBASS a= expr b= expr )
				{
				DebugLocation(284, 4);
				DebugLocation(284, 7);
				Match(input,SUBASS,Follow._SUBASS_in_expr1432); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(284, 15);
				PushFollow(Follow._expr_in_expr1436);
				a=expr();
				PopFollow();

				DebugLocation(284, 22);
				PushFollow(Follow._expr_in_expr1440);
				b=expr();
				PopFollow();

				DebugLocation(284, 28);
				 result = JsExpression.SubtractAssign(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// TypeScriptWalker.g3:285:4: ^( SHLASS a= expr b= expr )
				{
				DebugLocation(285, 4);
				DebugLocation(285, 7);
				Match(input,SHLASS,Follow._SHLASS_in_expr1451); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(285, 15);
				PushFollow(Follow._expr_in_expr1455);
				a=expr();
				PopFollow();

				DebugLocation(285, 22);
				PushFollow(Follow._expr_in_expr1459);
				b=expr();
				PopFollow();

				DebugLocation(285, 28);
				 result = JsExpression.LeftShiftAssign(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 9:
				DebugEnterAlt(9);
				// TypeScriptWalker.g3:286:4: ^( SHRASS a= expr b= expr )
				{
				DebugLocation(286, 4);
				DebugLocation(286, 7);
				Match(input,SHRASS,Follow._SHRASS_in_expr1470); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(286, 15);
				PushFollow(Follow._expr_in_expr1474);
				a=expr();
				PopFollow();

				DebugLocation(286, 22);
				PushFollow(Follow._expr_in_expr1478);
				b=expr();
				PopFollow();

				DebugLocation(286, 28);
				 result = JsExpression.RightShiftSignedAssign(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 10:
				DebugEnterAlt(10);
				// TypeScriptWalker.g3:287:4: ^( SHUASS a= expr b= expr )
				{
				DebugLocation(287, 4);
				DebugLocation(287, 7);
				Match(input,SHUASS,Follow._SHUASS_in_expr1489); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(287, 15);
				PushFollow(Follow._expr_in_expr1493);
				a=expr();
				PopFollow();

				DebugLocation(287, 22);
				PushFollow(Follow._expr_in_expr1497);
				b=expr();
				PopFollow();

				DebugLocation(287, 28);
				 result = JsExpression.RightShiftUnsignedAssign(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 11:
				DebugEnterAlt(11);
				// TypeScriptWalker.g3:288:4: ^( ANDASS a= expr b= expr )
				{
				DebugLocation(288, 4);
				DebugLocation(288, 7);
				Match(input,ANDASS,Follow._ANDASS_in_expr1508); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(288, 15);
				PushFollow(Follow._expr_in_expr1512);
				a=expr();
				PopFollow();

				DebugLocation(288, 22);
				PushFollow(Follow._expr_in_expr1516);
				b=expr();
				PopFollow();

				DebugLocation(288, 28);
				 result = JsExpression.BitwiseAndAssign(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 12:
				DebugEnterAlt(12);
				// TypeScriptWalker.g3:289:4: ^( XORASS a= expr b= expr )
				{
				DebugLocation(289, 4);
				DebugLocation(289, 7);
				Match(input,XORASS,Follow._XORASS_in_expr1527); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(289, 15);
				PushFollow(Follow._expr_in_expr1531);
				a=expr();
				PopFollow();

				DebugLocation(289, 22);
				PushFollow(Follow._expr_in_expr1535);
				b=expr();
				PopFollow();

				DebugLocation(289, 28);
				 result = JsExpression.BitwiseXorAssign(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 13:
				DebugEnterAlt(13);
				// TypeScriptWalker.g3:290:4: ^( ORASS a= expr b= expr )
				{
				DebugLocation(290, 4);
				DebugLocation(290, 7);
				Match(input,ORASS,Follow._ORASS_in_expr1546); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(290, 15);
				PushFollow(Follow._expr_in_expr1551);
				a=expr();
				PopFollow();

				DebugLocation(290, 22);
				PushFollow(Follow._expr_in_expr1555);
				b=expr();
				PopFollow();

				DebugLocation(290, 28);
				 result = JsExpression.BitwiseOrAssign(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 14:
				DebugEnterAlt(14);
				// TypeScriptWalker.g3:293:4: ^( QUE a= expr b= expr c= expr )
				{
				DebugLocation(293, 4);
				DebugLocation(293, 7);
				Match(input,QUE,Follow._QUE_in_expr1570); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(293, 12);
				PushFollow(Follow._expr_in_expr1574);
				a=expr();
				PopFollow();

				DebugLocation(293, 19);
				PushFollow(Follow._expr_in_expr1578);
				b=expr();
				PopFollow();

				DebugLocation(293, 26);
				PushFollow(Follow._expr_in_expr1582);
				c=expr();
				PopFollow();

				DebugLocation(293, 33);
				 result = JsExpression.Conditional(a, b, c); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 15:
				DebugEnterAlt(15);
				// TypeScriptWalker.g3:296:4: ^( LOR a= expr b= expr )
				{
				DebugLocation(296, 4);
				DebugLocation(296, 7);
				Match(input,LOR,Follow._LOR_in_expr1598); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(296, 19);
				PushFollow(Follow._expr_in_expr1609);
				a=expr();
				PopFollow();

				DebugLocation(296, 26);
				PushFollow(Follow._expr_in_expr1613);
				b=expr();
				PopFollow();

				DebugLocation(296, 32);
				 result = JsExpression.LogicalOr(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 16:
				DebugEnterAlt(16);
				// TypeScriptWalker.g3:297:4: ^( LAND a= expr b= expr )
				{
				DebugLocation(297, 4);
				DebugLocation(297, 7);
				Match(input,LAND,Follow._LAND_in_expr1624); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(297, 19);
				PushFollow(Follow._expr_in_expr1634);
				a=expr();
				PopFollow();

				DebugLocation(297, 26);
				PushFollow(Follow._expr_in_expr1638);
				b=expr();
				PopFollow();

				DebugLocation(297, 32);
				 result = JsExpression.LogicalAnd(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 17:
				DebugEnterAlt(17);
				// TypeScriptWalker.g3:300:4: ^( AND a= expr b= expr )
				{
				DebugLocation(300, 4);
				DebugLocation(300, 7);
				Match(input,AND,Follow._AND_in_expr1653); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(300, 19);
				PushFollow(Follow._expr_in_expr1664);
				a=expr();
				PopFollow();

				DebugLocation(300, 26);
				PushFollow(Follow._expr_in_expr1668);
				b=expr();
				PopFollow();

				DebugLocation(300, 32);
				 result = JsExpression.BitwiseAnd(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 18:
				DebugEnterAlt(18);
				// TypeScriptWalker.g3:301:4: ^( OR a= expr b= expr )
				{
				DebugLocation(301, 4);
				DebugLocation(301, 7);
				Match(input,OR,Follow._OR_in_expr1679); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(301, 19);
				PushFollow(Follow._expr_in_expr1691);
				a=expr();
				PopFollow();

				DebugLocation(301, 26);
				PushFollow(Follow._expr_in_expr1695);
				b=expr();
				PopFollow();

				DebugLocation(301, 32);
				 result = JsExpression.BitwiseOr(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 19:
				DebugEnterAlt(19);
				// TypeScriptWalker.g3:302:4: ^( XOR a= expr b= expr )
				{
				DebugLocation(302, 4);
				DebugLocation(302, 7);
				Match(input,XOR,Follow._XOR_in_expr1706); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(302, 19);
				PushFollow(Follow._expr_in_expr1717);
				a=expr();
				PopFollow();

				DebugLocation(302, 26);
				PushFollow(Follow._expr_in_expr1721);
				b=expr();
				PopFollow();

				DebugLocation(302, 32);
				 result = JsExpression.BitwiseXor(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 20:
				DebugEnterAlt(20);
				// TypeScriptWalker.g3:305:4: ^( EQ a= expr b= expr )
				{
				DebugLocation(305, 4);
				DebugLocation(305, 7);
				Match(input,EQ,Follow._EQ_in_expr1736); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(305, 19);
				PushFollow(Follow._expr_in_expr1748);
				a=expr();
				PopFollow();

				DebugLocation(305, 26);
				PushFollow(Follow._expr_in_expr1752);
				b=expr();
				PopFollow();

				DebugLocation(305, 32);
				 result = JsExpression.Equal(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 21:
				DebugEnterAlt(21);
				// TypeScriptWalker.g3:306:4: ^( NEQ a= expr b= expr )
				{
				DebugLocation(306, 4);
				DebugLocation(306, 7);
				Match(input,NEQ,Follow._NEQ_in_expr1763); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(306, 19);
				PushFollow(Follow._expr_in_expr1774);
				a=expr();
				PopFollow();

				DebugLocation(306, 26);
				PushFollow(Follow._expr_in_expr1778);
				b=expr();
				PopFollow();

				DebugLocation(306, 32);
				 result = JsExpression.NotEqual(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 22:
				DebugEnterAlt(22);
				// TypeScriptWalker.g3:307:4: ^( SAME a= expr b= expr )
				{
				DebugLocation(307, 4);
				DebugLocation(307, 7);
				Match(input,SAME,Follow._SAME_in_expr1789); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(307, 19);
				PushFollow(Follow._expr_in_expr1799);
				a=expr();
				PopFollow();

				DebugLocation(307, 26);
				PushFollow(Follow._expr_in_expr1803);
				b=expr();
				PopFollow();

				DebugLocation(307, 32);
				 result = JsExpression.Same(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 23:
				DebugEnterAlt(23);
				// TypeScriptWalker.g3:308:4: ^( NSAME a= expr b= expr )
				{
				DebugLocation(308, 4);
				DebugLocation(308, 7);
				Match(input,NSAME,Follow._NSAME_in_expr1814); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(308, 19);
				PushFollow(Follow._expr_in_expr1823);
				a=expr();
				PopFollow();

				DebugLocation(308, 26);
				PushFollow(Follow._expr_in_expr1827);
				b=expr();
				PopFollow();

				DebugLocation(308, 32);
				 result = JsExpression.NotSame(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 24:
				DebugEnterAlt(24);
				// TypeScriptWalker.g3:311:4: ^( LT a= expr b= expr )
				{
				DebugLocation(311, 4);
				DebugLocation(311, 7);
				Match(input,LT,Follow._LT_in_expr1842); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(311, 19);
				PushFollow(Follow._expr_in_expr1854);
				a=expr();
				PopFollow();

				DebugLocation(311, 26);
				PushFollow(Follow._expr_in_expr1858);
				b=expr();
				PopFollow();

				DebugLocation(311, 32);
				 result = JsExpression.Lesser(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 25:
				DebugEnterAlt(25);
				// TypeScriptWalker.g3:312:4: ^( GT a= expr b= expr )
				{
				DebugLocation(312, 4);
				DebugLocation(312, 7);
				Match(input,GT,Follow._GT_in_expr1869); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(312, 19);
				PushFollow(Follow._expr_in_expr1881);
				a=expr();
				PopFollow();

				DebugLocation(312, 26);
				PushFollow(Follow._expr_in_expr1885);
				b=expr();
				PopFollow();

				DebugLocation(312, 32);
				 result = JsExpression.Greater(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 26:
				DebugEnterAlt(26);
				// TypeScriptWalker.g3:313:4: ^( LTE a= expr b= expr )
				{
				DebugLocation(313, 4);
				DebugLocation(313, 7);
				Match(input,LTE,Follow._LTE_in_expr1896); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(313, 19);
				PushFollow(Follow._expr_in_expr1907);
				a=expr();
				PopFollow();

				DebugLocation(313, 26);
				PushFollow(Follow._expr_in_expr1911);
				b=expr();
				PopFollow();

				DebugLocation(313, 32);
				 result = JsExpression.LesserOrEqual(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 27:
				DebugEnterAlt(27);
				// TypeScriptWalker.g3:314:4: ^( GTE a= expr b= expr )
				{
				DebugLocation(314, 4);
				DebugLocation(314, 7);
				Match(input,GTE,Follow._GTE_in_expr1922); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(314, 19);
				PushFollow(Follow._expr_in_expr1933);
				a=expr();
				PopFollow();

				DebugLocation(314, 26);
				PushFollow(Follow._expr_in_expr1937);
				b=expr();
				PopFollow();

				DebugLocation(314, 32);
				 result = JsExpression.GreaterOrEqual(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 28:
				DebugEnterAlt(28);
				// TypeScriptWalker.g3:315:4: ^( INSTANCEOF a= expr b= expr )
				{
				DebugLocation(315, 4);
				DebugLocation(315, 7);
				Match(input,INSTANCEOF,Follow._INSTANCEOF_in_expr1948); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(315, 19);
				PushFollow(Follow._expr_in_expr1952);
				a=expr();
				PopFollow();

				DebugLocation(315, 26);
				PushFollow(Follow._expr_in_expr1956);
				b=expr();
				PopFollow();

				DebugLocation(315, 32);
				 result = JsExpression.InstanceOf(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 29:
				DebugEnterAlt(29);
				// TypeScriptWalker.g3:316:4: ^( IN a= expr b= expr )
				{
				DebugLocation(316, 4);
				DebugLocation(316, 7);
				Match(input,IN,Follow._IN_in_expr1967); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(316, 19);
				PushFollow(Follow._expr_in_expr1979);
				a=expr();
				PopFollow();

				DebugLocation(316, 26);
				PushFollow(Follow._expr_in_expr1983);
				b=expr();
				PopFollow();

				DebugLocation(316, 32);
				 result = JsExpression.In(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 30:
				DebugEnterAlt(30);
				// TypeScriptWalker.g3:319:4: ^( SHL a= expr b= expr )
				{
				DebugLocation(319, 4);
				DebugLocation(319, 7);
				Match(input,SHL,Follow._SHL_in_expr1998); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(319, 19);
				PushFollow(Follow._expr_in_expr2009);
				a=expr();
				PopFollow();

				DebugLocation(319, 26);
				PushFollow(Follow._expr_in_expr2013);
				b=expr();
				PopFollow();

				DebugLocation(319, 32);
				 result = JsExpression.LeftShift(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 31:
				DebugEnterAlt(31);
				// TypeScriptWalker.g3:320:4: ^( SHR a= expr b= expr )
				{
				DebugLocation(320, 4);
				DebugLocation(320, 7);
				Match(input,SHR,Follow._SHR_in_expr2024); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(320, 19);
				PushFollow(Follow._expr_in_expr2035);
				a=expr();
				PopFollow();

				DebugLocation(320, 26);
				PushFollow(Follow._expr_in_expr2039);
				b=expr();
				PopFollow();

				DebugLocation(320, 32);
				 result = JsExpression.RightShiftSigned(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 32:
				DebugEnterAlt(32);
				// TypeScriptWalker.g3:321:4: ^( SHU a= expr b= expr )
				{
				DebugLocation(321, 4);
				DebugLocation(321, 7);
				Match(input,SHU,Follow._SHU_in_expr2050); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(321, 19);
				PushFollow(Follow._expr_in_expr2061);
				a=expr();
				PopFollow();

				DebugLocation(321, 26);
				PushFollow(Follow._expr_in_expr2065);
				b=expr();
				PopFollow();

				DebugLocation(321, 32);
				 result = JsExpression.RightShiftUnsigned(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 33:
				DebugEnterAlt(33);
				// TypeScriptWalker.g3:324:4: ^( ADD a= expr b= expr )
				{
				DebugLocation(324, 4);
				DebugLocation(324, 7);
				Match(input,ADD,Follow._ADD_in_expr2080); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(324, 19);
				PushFollow(Follow._expr_in_expr2091);
				a=expr();
				PopFollow();

				DebugLocation(324, 26);
				PushFollow(Follow._expr_in_expr2095);
				b=expr();
				PopFollow();

				DebugLocation(324, 32);
				 result = JsExpression.Add(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 34:
				DebugEnterAlt(34);
				// TypeScriptWalker.g3:325:4: ^( SUB a= expr b= expr )
				{
				DebugLocation(325, 4);
				DebugLocation(325, 7);
				Match(input,SUB,Follow._SUB_in_expr2106); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(325, 19);
				PushFollow(Follow._expr_in_expr2117);
				a=expr();
				PopFollow();

				DebugLocation(325, 26);
				PushFollow(Follow._expr_in_expr2121);
				b=expr();
				PopFollow();

				DebugLocation(325, 32);
				 result = JsExpression.Subtract(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 35:
				DebugEnterAlt(35);
				// TypeScriptWalker.g3:328:4: ^( MUL a= expr b= expr )
				{
				DebugLocation(328, 4);
				DebugLocation(328, 7);
				Match(input,MUL,Follow._MUL_in_expr2136); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(328, 19);
				PushFollow(Follow._expr_in_expr2147);
				a=expr();
				PopFollow();

				DebugLocation(328, 26);
				PushFollow(Follow._expr_in_expr2151);
				b=expr();
				PopFollow();

				DebugLocation(328, 32);
				 result = JsExpression.Multiply(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 36:
				DebugEnterAlt(36);
				// TypeScriptWalker.g3:329:4: ^( DIV a= expr b= expr )
				{
				DebugLocation(329, 4);
				DebugLocation(329, 7);
				Match(input,DIV,Follow._DIV_in_expr2162); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(329, 19);
				PushFollow(Follow._expr_in_expr2173);
				a=expr();
				PopFollow();

				DebugLocation(329, 26);
				PushFollow(Follow._expr_in_expr2177);
				b=expr();
				PopFollow();

				DebugLocation(329, 32);
				 result = JsExpression.Divide(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 37:
				DebugEnterAlt(37);
				// TypeScriptWalker.g3:330:4: ^( MOD a= expr b= expr )
				{
				DebugLocation(330, 4);
				DebugLocation(330, 7);
				Match(input,MOD,Follow._MOD_in_expr2188); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(330, 19);
				PushFollow(Follow._expr_in_expr2199);
				a=expr();
				PopFollow();

				DebugLocation(330, 26);
				PushFollow(Follow._expr_in_expr2203);
				b=expr();
				PopFollow();

				DebugLocation(330, 32);
				 result = JsExpression.Modulo(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 38:
				DebugEnterAlt(38);
				// TypeScriptWalker.g3:333:4: ^( DELETE a= expr )
				{
				DebugLocation(333, 4);
				DebugLocation(333, 7);
				Match(input,DELETE,Follow._DELETE_in_expr2218); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(333, 15);
				PushFollow(Follow._expr_in_expr2222);
				a=expr();
				PopFollow();

				DebugLocation(333, 21);
				 result = JsExpression.Delete(a); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 39:
				DebugEnterAlt(39);
				// TypeScriptWalker.g3:334:4: ^( VOID a= expr )
				{
				DebugLocation(334, 4);
				DebugLocation(334, 7);
				Match(input,VOID,Follow._VOID_in_expr2233); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(334, 15);
				PushFollow(Follow._expr_in_expr2239);
				a=expr();
				PopFollow();

				DebugLocation(334, 21);
				 result = JsExpression.Void(a); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 40:
				DebugEnterAlt(40);
				// TypeScriptWalker.g3:335:4: ^( TYPEOF a= expr )
				{
				DebugLocation(335, 4);
				DebugLocation(335, 7);
				Match(input,TYPEOF,Follow._TYPEOF_in_expr2250); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(335, 15);
				PushFollow(Follow._expr_in_expr2254);
				a=expr();
				PopFollow();

				DebugLocation(335, 21);
				 result = JsExpression.TypeOf(a); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 41:
				DebugEnterAlt(41);
				// TypeScriptWalker.g3:336:4: ^( INC a= expr )
				{
				DebugLocation(336, 4);
				DebugLocation(336, 7);
				Match(input,INC,Follow._INC_in_expr2265); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(336, 15);
				PushFollow(Follow._expr_in_expr2272);
				a=expr();
				PopFollow();

				DebugLocation(336, 21);
				 result = JsExpression.PrefixPlusPlus(a); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 42:
				DebugEnterAlt(42);
				// TypeScriptWalker.g3:337:4: ^( DEC a= expr )
				{
				DebugLocation(337, 4);
				DebugLocation(337, 7);
				Match(input,DEC,Follow._DEC_in_expr2283); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(337, 15);
				PushFollow(Follow._expr_in_expr2290);
				a=expr();
				PopFollow();

				DebugLocation(337, 21);
				 result = JsExpression.PrefixMinusMinus(a); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 43:
				DebugEnterAlt(43);
				// TypeScriptWalker.g3:338:4: ^( POS a= expr )
				{
				DebugLocation(338, 4);
				DebugLocation(338, 7);
				Match(input,POS,Follow._POS_in_expr2301); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(338, 15);
				PushFollow(Follow._expr_in_expr2308);
				a=expr();
				PopFollow();

				DebugLocation(338, 21);
				 result = JsExpression.Positive(a); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 44:
				DebugEnterAlt(44);
				// TypeScriptWalker.g3:339:4: ^( NEG a= expr )
				{
				DebugLocation(339, 4);
				DebugLocation(339, 7);
				Match(input,NEG,Follow._NEG_in_expr2319); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(339, 15);
				PushFollow(Follow._expr_in_expr2326);
				a=expr();
				PopFollow();

				DebugLocation(339, 21);
				 result = JsExpression.Negate(a); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 45:
				DebugEnterAlt(45);
				// TypeScriptWalker.g3:340:4: ^( INV a= expr )
				{
				DebugLocation(340, 4);
				DebugLocation(340, 7);
				Match(input,INV,Follow._INV_in_expr2337); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(340, 15);
				PushFollow(Follow._expr_in_expr2344);
				a=expr();
				PopFollow();

				DebugLocation(340, 21);
				 result = JsExpression.BitwiseNot(a); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 46:
				DebugEnterAlt(46);
				// TypeScriptWalker.g3:341:4: ^( NOT a= expr )
				{
				DebugLocation(341, 4);
				DebugLocation(341, 7);
				Match(input,NOT,Follow._NOT_in_expr2355); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(341, 15);
				PushFollow(Follow._expr_in_expr2362);
				a=expr();
				PopFollow();

				DebugLocation(341, 21);
				 result = JsExpression.LogicalNot(a); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 47:
				DebugEnterAlt(47);
				// TypeScriptWalker.g3:344:4: ^( PINC a= expr )
				{
				DebugLocation(344, 4);
				DebugLocation(344, 7);
				Match(input,PINC,Follow._PINC_in_expr2377); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(344, 15);
				PushFollow(Follow._expr_in_expr2383);
				a=expr();
				PopFollow();

				DebugLocation(344, 21);
				 result = JsExpression.PostfixPlusPlus(a); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 48:
				DebugEnterAlt(48);
				// TypeScriptWalker.g3:345:4: ^( PDEC a= expr )
				{
				DebugLocation(345, 4);
				DebugLocation(345, 7);
				Match(input,PDEC,Follow._PDEC_in_expr2394); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(345, 15);
				PushFollow(Follow._expr_in_expr2400);
				a=expr();
				PopFollow();

				DebugLocation(345, 21);
				 result = JsExpression.PostfixMinusMinus(a); 

				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expr", 29);
			LeaveRule("expr", 29);
			LeaveRule_expr();
		}
		DebugLocation(346, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return result;

	}
	// $ANTLR end "expr"

	partial void EnterRule_leftHandSideExpression();
	partial void LeaveRule_leftHandSideExpression();
	// $ANTLR start "leftHandSideExpression"
	// TypeScriptWalker.g3:348:1: leftHandSideExpression returns [JsExpression result] : (x= primaryExpression |x= functionExpression |x= callExpression |x= memberExpression );
	[GrammarRule("leftHandSideExpression")]
	private JsExpression leftHandSideExpression()
	{
		EnterRule_leftHandSideExpression();
		EnterRule("leftHandSideExpression", 30);
		TraceIn("leftHandSideExpression", 30);
		JsExpression result = default(JsExpression);


		JsExpression x = default(JsExpression);

		try { DebugEnterRule(GrammarFileName, "leftHandSideExpression");
		DebugLocation(348, 1);
		try
		{
			// TypeScriptWalker.g3:349:2: (x= primaryExpression |x= functionExpression |x= callExpression |x= memberExpression )
			int alt26=4;
			try { DebugEnterDecision(26, false);
			switch (input.LA(1))
			{
			case ANY:
			case ARRAY:
			case CONSTRUCTOR:
			case DECLARE:
			case DecimalLiteral:
			case FALSE:
			case FINAL:
			case GET:
			case HexIntegerLiteral:
			case Identifier:
			case MODULE:
			case NULL:
			case NUMBER:
			case OBJECT:
			case OctalIntegerLiteral:
			case PAREXPR:
			case REQUIRE:
			case RegularExpressionLiteral:
			case SET:
			case STRING:
			case StringLiteral:
			case THIS:
			case THROWS:
			case TRUE:
			case TYPE:
				{
				alt26 = 1;
				}
				break;
			case FUNCTION:
				{
				alt26 = 2;
				}
				break;
			case CALL:
				{
				alt26 = 3;
				}
				break;
			case BYFIELD:
			case BYINDEX:
				{
				alt26 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 26, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:349:4: x= primaryExpression
				{
				DebugLocation(349, 5);
				PushFollow(Follow._primaryExpression_in_leftHandSideExpression2421);
				x=primaryExpression();
				PopFollow();

				DebugLocation(349, 25);
				 result = x; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:350:4: x= functionExpression
				{
				DebugLocation(350, 5);
				PushFollow(Follow._functionExpression_in_leftHandSideExpression2431);
				x=functionExpression();
				PopFollow();

				DebugLocation(350, 25);
				 result = x; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:351:4: x= callExpression
				{
				DebugLocation(351, 5);
				PushFollow(Follow._callExpression_in_leftHandSideExpression2440);
				x=callExpression();
				PopFollow();

				DebugLocation(351, 25);
				 result = x; 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScriptWalker.g3:352:4: x= memberExpression
				{
				DebugLocation(352, 5);
				PushFollow(Follow._memberExpression_in_leftHandSideExpression2453);
				x=memberExpression();
				PopFollow();

				DebugLocation(352, 25);
				 result = x; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("leftHandSideExpression", 30);
			LeaveRule("leftHandSideExpression", 30);
			LeaveRule_leftHandSideExpression();
		}
		DebugLocation(353, 1);
		} finally { DebugExitRule(GrammarFileName, "leftHandSideExpression"); }
		return result;

	}
	// $ANTLR end "leftHandSideExpression"

	partial void EnterRule_functionExpression();
	partial void LeaveRule_functionExpression();
	// $ANTLR start "functionExpression"
	// TypeScriptWalker.g3:355:1: functionExpression returns [JsExpression result] : ^( FUNCTION (i= identifier )? (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? (b= block ) ) ;
	[GrammarRule("functionExpression")]
	private JsExpression functionExpression()
	{
		EnterRule_functionExpression();
		EnterRule("functionExpression", 31);
		TraceIn("functionExpression", 31);
		JsExpression result = default(JsExpression);


		string i = default(string);
		IList<TsTypeParameter> typeParams = default(IList<TsTypeParameter>);
		IList<TsParameter> parameters = default(IList<TsParameter>);
		TsType annotation = default(TsType);
		JsStatement b = default(JsStatement);

		 var parms = new List<string>(); 
		try { DebugEnterRule(GrammarFileName, "functionExpression");
		DebugLocation(355, 1);
		try
		{
			// TypeScriptWalker.g3:357:2: ( ^( FUNCTION (i= identifier )? (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? (b= block ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:357:4: ^( FUNCTION (i= identifier )? (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? (b= block ) )
			{
			DebugLocation(357, 4);
			DebugLocation(357, 7);
			Match(input,FUNCTION,Follow._FUNCTION_in_functionExpression2479); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(357, 17);
			// TypeScriptWalker.g3:357:17: (i= identifier )?
			int alt27=2;
			try { DebugEnterSubRule(27);
			try { DebugEnterDecision(27, false);
			int LA27_1 = input.LA(1);

			if ((LA27_1==ANY||LA27_1==CONSTRUCTOR||LA27_1==DECLARE||LA27_1==FINAL||LA27_1==GET||LA27_1==Identifier||LA27_1==MODULE||LA27_1==NUMBER||LA27_1==REQUIRE||LA27_1==SET||LA27_1==STRING||LA27_1==THROWS||LA27_1==TYPE))
			{
				alt27 = 1;
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:357:17: i= identifier
				{
				DebugLocation(357, 17);
				PushFollow(Follow._identifier_in_functionExpression2483);
				i=identifier();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(27); }

			DebugLocation(357, 30);
			// TypeScriptWalker.g3:357:30: (typeParams= typeParameters )?
			int alt28=2;
			try { DebugEnterSubRule(28);
			try { DebugEnterDecision(28, false);
			int LA28_1 = input.LA(1);

			if ((LA28_1==TYPE_PARAMS))
			{
				alt28 = 1;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:357:31: typeParams= typeParameters
				{
				DebugLocation(357, 42);
				PushFollow(Follow._typeParameters_in_functionExpression2491);
				typeParams=typeParameters();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(28); }

			DebugLocation(357, 61);
			// TypeScriptWalker.g3:357:61: (parameters= parameterList )?
			int alt29=2;
			try { DebugEnterSubRule(29);
			try { DebugEnterDecision(29, false);
			int LA29_1 = input.LA(1);

			if ((LA29_1==ELLIPSIS||LA29_1==PARAMS))
			{
				alt29 = 1;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:357:62: parameters= parameterList
				{
				DebugLocation(357, 73);
				PushFollow(Follow._parameterList_in_functionExpression2500);
				parameters=parameterList();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(29); }

			DebugLocation(357, 91);
			// TypeScriptWalker.g3:357:91: (annotation= typeAnnotation )?
			int alt30=2;
			try { DebugEnterSubRule(30);
			try { DebugEnterDecision(30, false);
			int LA30_1 = input.LA(1);

			if ((LA30_1==COLON))
			{
				alt30 = 1;
			}
			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:357:92: annotation= typeAnnotation
				{
				DebugLocation(357, 103);
				PushFollow(Follow._typeAnnotation_in_functionExpression2509);
				annotation=typeAnnotation();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(30); }

			DebugLocation(357, 122);
			// TypeScriptWalker.g3:357:122: (b= block )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:357:123: b= block
			{
			DebugLocation(357, 124);
			PushFollow(Follow._block_in_functionExpression2516);
			b=block();
			PopFollow();


			}


			Match(input, TokenTypes.Up, null); 

			DebugLocation(357, 134);
			 result = JsExpression.FunctionDefinition(typeParams, parameters, i != null ? i : null, b, annotation); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("functionExpression", 31);
			LeaveRule("functionExpression", 31);
			LeaveRule_functionExpression();
		}
		DebugLocation(358, 1);
		} finally { DebugExitRule(GrammarFileName, "functionExpression"); }
		return result;

	}
	// $ANTLR end "functionExpression"

	partial void EnterRule_functionDeclaration();
	partial void LeaveRule_functionDeclaration();
	// $ANTLR start "functionDeclaration"
	// TypeScriptWalker.g3:360:1: functionDeclaration returns [JsStatement result] : ^( FUNCTIONDECLARATION i= identifier (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? (b= block )? ) ;
	[GrammarRule("functionDeclaration")]
	private JsStatement functionDeclaration()
	{
		EnterRule_functionDeclaration();
		EnterRule("functionDeclaration", 32);
		TraceIn("functionDeclaration", 32);
		JsStatement result = default(JsStatement);


		string i = default(string);
		IList<TsTypeParameter> typeParams = default(IList<TsTypeParameter>);
		IList<TsParameter> parameters = default(IList<TsParameter>);
		TsType annotation = default(TsType);
		JsStatement b = default(JsStatement);

		 var parms = new List<string>(); 
		try { DebugEnterRule(GrammarFileName, "functionDeclaration");
		DebugLocation(360, 1);
		try
		{
			// TypeScriptWalker.g3:362:2: ( ^( FUNCTIONDECLARATION i= identifier (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? (b= block )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:362:4: ^( FUNCTIONDECLARATION i= identifier (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? (b= block )? )
			{
			DebugLocation(362, 4);
			DebugLocation(362, 7);
			Match(input,FUNCTIONDECLARATION,Follow._FUNCTIONDECLARATION_in_functionDeclaration2543); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(362, 28);
			PushFollow(Follow._identifier_in_functionDeclaration2547);
			i=identifier();
			PopFollow();

			DebugLocation(362, 40);
			// TypeScriptWalker.g3:362:40: (typeParams= typeParameters )?
			int alt31=2;
			try { DebugEnterSubRule(31);
			try { DebugEnterDecision(31, false);
			int LA31_1 = input.LA(1);

			if ((LA31_1==TYPE_PARAMS))
			{
				alt31 = 1;
			}
			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:362:41: typeParams= typeParameters
				{
				DebugLocation(362, 52);
				PushFollow(Follow._typeParameters_in_functionDeclaration2554);
				typeParams=typeParameters();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(31); }

			DebugLocation(362, 71);
			// TypeScriptWalker.g3:362:71: (parameters= parameterList )?
			int alt32=2;
			try { DebugEnterSubRule(32);
			try { DebugEnterDecision(32, false);
			int LA32_1 = input.LA(1);

			if ((LA32_1==ELLIPSIS||LA32_1==PARAMS))
			{
				alt32 = 1;
			}
			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:362:72: parameters= parameterList
				{
				DebugLocation(362, 83);
				PushFollow(Follow._parameterList_in_functionDeclaration2563);
				parameters=parameterList();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(32); }

			DebugLocation(362, 101);
			// TypeScriptWalker.g3:362:101: (annotation= typeAnnotation )?
			int alt33=2;
			try { DebugEnterSubRule(33);
			try { DebugEnterDecision(33, false);
			int LA33_1 = input.LA(1);

			if ((LA33_1==COLON))
			{
				alt33 = 1;
			}
			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:362:102: annotation= typeAnnotation
				{
				DebugLocation(362, 113);
				PushFollow(Follow._typeAnnotation_in_functionDeclaration2572);
				annotation=typeAnnotation();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(33); }

			DebugLocation(362, 132);
			// TypeScriptWalker.g3:362:132: (b= block )?
			int alt34=2;
			try { DebugEnterSubRule(34);
			try { DebugEnterDecision(34, false);
			int LA34_1 = input.LA(1);

			if ((LA34_1==BLOCK))
			{
				alt34 = 1;
			}
			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:362:133: b= block
				{
				DebugLocation(362, 134);
				PushFollow(Follow._block_in_functionDeclaration2579);
				b=block();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(34); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(362, 145);
			 result = new JsFunctionStatement(typeParams, parameters, i, b, annotation); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("functionDeclaration", 32);
			LeaveRule("functionDeclaration", 32);
			LeaveRule_functionDeclaration();
		}
		DebugLocation(363, 1);
		} finally { DebugExitRule(GrammarFileName, "functionDeclaration"); }
		return result;

	}
	// $ANTLR end "functionDeclaration"

	partial void EnterRule_callExpression();
	partial void LeaveRule_callExpression();
	// $ANTLR start "callExpression"
	// TypeScriptWalker.g3:365:1: callExpression returns [JsExpression result] : ( ^( CALL ^( NEW t= leftHandSideExpression ) ^( ARGS (a= expr )* ) ) | ^( CALL t= leftHandSideExpression ^( ARGS (a= expr )* ) ) );
	[GrammarRule("callExpression")]
	private JsExpression callExpression()
	{
		EnterRule_callExpression();
		EnterRule("callExpression", 33);
		TraceIn("callExpression", 33);
		JsExpression result = default(JsExpression);


		JsExpression t = default(JsExpression);
		JsExpression a = default(JsExpression);

		 var args = new List<JsExpression>(); 
		try { DebugEnterRule(GrammarFileName, "callExpression");
		DebugLocation(365, 1);
		try
		{
			// TypeScriptWalker.g3:367:2: ( ^( CALL ^( NEW t= leftHandSideExpression ) ^( ARGS (a= expr )* ) ) | ^( CALL t= leftHandSideExpression ^( ARGS (a= expr )* ) ) )
			int alt37=2;
			try { DebugEnterDecision(37, false);
			int LA37_1 = input.LA(1);

			if ((LA37_1==CALL))
			{
				int LA37_2 = input.LA(2);

				if ((LA37_2==DOWN))
				{
					int LA37_3 = input.LA(3);

					if ((LA37_3==NEW))
					{
						alt37 = 1;
					}
					else if ((LA37_3==ANY||LA37_3==ARRAY||(LA37_3>=BYFIELD && LA37_3<=BYINDEX)||LA37_3==CALL||LA37_3==CONSTRUCTOR||LA37_3==DECLARE||LA37_3==DecimalLiteral||LA37_3==FALSE||LA37_3==FINAL||LA37_3==FUNCTION||LA37_3==GET||LA37_3==HexIntegerLiteral||LA37_3==Identifier||LA37_3==MODULE||(LA37_3>=NULL && LA37_3<=OBJECT)||LA37_3==OctalIntegerLiteral||LA37_3==PAREXPR||LA37_3==REQUIRE||LA37_3==RegularExpressionLiteral||LA37_3==SET||LA37_3==STRING||LA37_3==StringLiteral||LA37_3==THIS||LA37_3==THROWS||LA37_3==TRUE||LA37_3==TYPE))
					{
						alt37 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 37, 2, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 37, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 37, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:367:4: ^( CALL ^( NEW t= leftHandSideExpression ) ^( ARGS (a= expr )* ) )
				{
				DebugLocation(367, 4);
				DebugLocation(367, 7);
				Match(input,CALL,Follow._CALL_in_callExpression2607); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(367, 12);
				DebugLocation(367, 15);
				Match(input,NEW,Follow._NEW_in_callExpression2611); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(367, 20);
				PushFollow(Follow._leftHandSideExpression_in_callExpression2615);
				t=leftHandSideExpression();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(367, 46);
				DebugLocation(367, 49);
				Match(input,ARGS,Follow._ARGS_in_callExpression2621); 

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); 
					DebugLocation(367, 54);
					// TypeScriptWalker.g3:367:54: (a= expr )*
					try { DebugEnterSubRule(35);
					while (true)
					{
						int alt35=2;
						try { DebugEnterDecision(35, false);
						try
						{
							alt35 = dfa35.Predict(input);
						}
						catch (NoViableAltException nvae)
						{
							DebugRecognitionException(nvae);
							throw;
						}
						} finally { DebugExitDecision(35); }
						switch ( alt35 )
						{
						case 1:
							DebugEnterAlt(1);
							// TypeScriptWalker.g3:367:55: a= expr
							{
							DebugLocation(367, 56);
							PushFollow(Follow._expr_in_callExpression2626);
							a=expr();
							PopFollow();

							DebugLocation(367, 62);
							 args.Add(a); 

							}
							break;

						default:
							goto loop35;
						}
					}

					loop35:
						;

					} finally { DebugExitSubRule(35); }


					Match(input, TokenTypes.Up, null); 
				}


				Match(input, TokenTypes.Up, null); 

				DebugLocation(367, 85);
				 result = JsExpression.New(t, args); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:368:4: ^( CALL t= leftHandSideExpression ^( ARGS (a= expr )* ) )
				{
				DebugLocation(368, 4);
				DebugLocation(368, 7);
				Match(input,CALL,Follow._CALL_in_callExpression2643); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(368, 13);
				PushFollow(Follow._leftHandSideExpression_in_callExpression2647);
				t=leftHandSideExpression();
				PopFollow();

				DebugLocation(368, 37);
				DebugLocation(368, 40);
				Match(input,ARGS,Follow._ARGS_in_callExpression2651); 

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); 
					DebugLocation(368, 45);
					// TypeScriptWalker.g3:368:45: (a= expr )*
					try { DebugEnterSubRule(36);
					while (true)
					{
						int alt36=2;
						try { DebugEnterDecision(36, false);
						try
						{
							alt36 = dfa36.Predict(input);
						}
						catch (NoViableAltException nvae)
						{
							DebugRecognitionException(nvae);
							throw;
						}
						} finally { DebugExitDecision(36); }
						switch ( alt36 )
						{
						case 1:
							DebugEnterAlt(1);
							// TypeScriptWalker.g3:368:46: a= expr
							{
							DebugLocation(368, 47);
							PushFollow(Follow._expr_in_callExpression2656);
							a=expr();
							PopFollow();

							DebugLocation(368, 53);
							 args.Add(a); 

							}
							break;

						default:
							goto loop36;
						}
					}

					loop36:
						;

					} finally { DebugExitSubRule(36); }


					Match(input, TokenTypes.Up, null); 
				}


				Match(input, TokenTypes.Up, null); 

				DebugLocation(368, 76);
				 result = JsExpression.Invocation(t, args); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("callExpression", 33);
			LeaveRule("callExpression", 33);
			LeaveRule_callExpression();
		}
		DebugLocation(369, 1);
		} finally { DebugExitRule(GrammarFileName, "callExpression"); }
		return result;

	}
	// $ANTLR end "callExpression"

	partial void EnterRule_memberExpression();
	partial void LeaveRule_memberExpression();
	// $ANTLR start "memberExpression"
	// TypeScriptWalker.g3:371:1: memberExpression returns [JsExpression result] : ( ^( BYINDEX a= leftHandSideExpression b= expression ) | ^( BYFIELD a= leftHandSideExpression i= identifier ) );
	[GrammarRule("memberExpression")]
	private JsExpression memberExpression()
	{
		EnterRule_memberExpression();
		EnterRule("memberExpression", 34);
		TraceIn("memberExpression", 34);
		JsExpression result = default(JsExpression);


		JsExpression a = default(JsExpression);
		JsExpression b = default(JsExpression);
		string i = default(string);

		try { DebugEnterRule(GrammarFileName, "memberExpression");
		DebugLocation(371, 1);
		try
		{
			// TypeScriptWalker.g3:372:2: ( ^( BYINDEX a= leftHandSideExpression b= expression ) | ^( BYFIELD a= leftHandSideExpression i= identifier ) )
			int alt38=2;
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1==BYINDEX))
			{
				alt38 = 1;
			}
			else if ((LA38_1==BYFIELD))
			{
				alt38 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 38, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:372:4: ^( BYINDEX a= leftHandSideExpression b= expression )
				{
				DebugLocation(372, 4);
				DebugLocation(372, 7);
				Match(input,BYINDEX,Follow._BYINDEX_in_memberExpression2684); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(372, 16);
				PushFollow(Follow._leftHandSideExpression_in_memberExpression2688);
				a=leftHandSideExpression();
				PopFollow();

				DebugLocation(372, 41);
				PushFollow(Follow._expression_in_memberExpression2692);
				b=expression();
				PopFollow();

				DebugLocation(372, 53);
				 result = JsExpression.Index(a, b); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:373:4: ^( BYFIELD a= leftHandSideExpression i= identifier )
				{
				DebugLocation(373, 4);
				DebugLocation(373, 7);
				Match(input,BYFIELD,Follow._BYFIELD_in_memberExpression2703); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(373, 16);
				PushFollow(Follow._leftHandSideExpression_in_memberExpression2707);
				a=leftHandSideExpression();
				PopFollow();

				DebugLocation(373, 41);
				PushFollow(Follow._identifier_in_memberExpression2711);
				i=identifier();
				PopFollow();

				DebugLocation(373, 53);
				 result = JsExpression.MemberAccess(a, i); 

				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("memberExpression", 34);
			LeaveRule("memberExpression", 34);
			LeaveRule_memberExpression();
		}
		DebugLocation(374, 1);
		} finally { DebugExitRule(GrammarFileName, "memberExpression"); }
		return result;

	}
	// $ANTLR end "memberExpression"

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();
	// $ANTLR start "primaryExpression"
	// TypeScriptWalker.g3:376:1: primaryExpression returns [JsExpression result] : (i= identifier |x= literal | ^( PAREXPR x= expression ) );
	[GrammarRule("primaryExpression")]
	private JsExpression primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 35);
		TraceIn("primaryExpression", 35);
		JsExpression result = default(JsExpression);


		string i = default(string);
		JsExpression x = default(JsExpression);

		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(376, 1);
		try
		{
			// TypeScriptWalker.g3:377:2: (i= identifier |x= literal | ^( PAREXPR x= expression ) )
			int alt39=3;
			try { DebugEnterDecision(39, false);
			switch (input.LA(1))
			{
			case ANY:
			case CONSTRUCTOR:
			case DECLARE:
			case FINAL:
			case GET:
			case Identifier:
			case MODULE:
			case NUMBER:
			case REQUIRE:
			case SET:
			case STRING:
			case THROWS:
			case TYPE:
				{
				alt39 = 1;
				}
				break;
			case ARRAY:
			case DecimalLiteral:
			case FALSE:
			case HexIntegerLiteral:
			case NULL:
			case OBJECT:
			case OctalIntegerLiteral:
			case RegularExpressionLiteral:
			case StringLiteral:
			case THIS:
			case TRUE:
				{
				alt39 = 2;
				}
				break;
			case PAREXPR:
				{
				alt39 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 39, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(39); }
			switch (alt39)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:377:4: i= identifier
				{
				DebugLocation(377, 5);
				PushFollow(Follow._identifier_in_primaryExpression2732);
				i=identifier();
				PopFollow();

				DebugLocation(377, 17);
				 result = JsExpression.Identifier(i); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:378:4: x= literal
				{
				DebugLocation(378, 5);
				PushFollow(Follow._literal_in_primaryExpression2741);
				x=literal();
				PopFollow();

				DebugLocation(378, 14);
				 result = x; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:379:4: ^( PAREXPR x= expression )
				{
				DebugLocation(379, 4);
				DebugLocation(379, 6);
				Match(input,PAREXPR,Follow._PAREXPR_in_primaryExpression2749); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(379, 15);
				PushFollow(Follow._expression_in_primaryExpression2753);
				x=expression();
				PopFollow();

				DebugLocation(379, 27);
				 result = x; 

				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("primaryExpression", 35);
			LeaveRule("primaryExpression", 35);
			LeaveRule_primaryExpression();
		}
		DebugLocation(380, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return result;

	}
	// $ANTLR end "primaryExpression"

	partial void EnterRule_literal();
	partial void LeaveRule_literal();
	// $ANTLR start "literal"
	// TypeScriptWalker.g3:382:1: literal returns [JsExpression result] : ( THIS | NULL |x= booleanLiteral |x= numericLiteral | StringLiteral | RegularExpressionLiteral |x= arrayLiteral |x= objectLiteral );
	[GrammarRule("literal")]
	private JsExpression literal()
	{
		EnterRule_literal();
		EnterRule("literal", 36);
		TraceIn("literal", 36);
		JsExpression result = default(JsExpression);


		CommonTree StringLiteral1 = default(CommonTree);
		CommonTree RegularExpressionLiteral2 = default(CommonTree);
		JsExpression x = default(JsExpression);

		try { DebugEnterRule(GrammarFileName, "literal");
		DebugLocation(382, 1);
		try
		{
			// TypeScriptWalker.g3:383:2: ( THIS | NULL |x= booleanLiteral |x= numericLiteral | StringLiteral | RegularExpressionLiteral |x= arrayLiteral |x= objectLiteral )
			int alt40=8;
			try { DebugEnterDecision(40, false);
			switch (input.LA(1))
			{
			case THIS:
				{
				alt40 = 1;
				}
				break;
			case NULL:
				{
				alt40 = 2;
				}
				break;
			case FALSE:
			case TRUE:
				{
				alt40 = 3;
				}
				break;
			case DecimalLiteral:
			case HexIntegerLiteral:
			case OctalIntegerLiteral:
				{
				alt40 = 4;
				}
				break;
			case StringLiteral:
				{
				alt40 = 5;
				}
				break;
			case RegularExpressionLiteral:
				{
				alt40 = 6;
				}
				break;
			case ARRAY:
				{
				alt40 = 7;
				}
				break;
			case OBJECT:
				{
				alt40 = 8;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 40, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(40); }
			switch (alt40)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:383:4: THIS
				{
				DebugLocation(383, 4);
				Match(input,THIS,Follow._THIS_in_literal2771); 
				DebugLocation(383, 9);
				 result = JsExpression.This; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:384:4: NULL
				{
				DebugLocation(384, 4);
				Match(input,NULL,Follow._NULL_in_literal2778); 
				DebugLocation(384, 9);
				 result = JsExpression.Null; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:385:4: x= booleanLiteral
				{
				DebugLocation(385, 5);
				PushFollow(Follow._booleanLiteral_in_literal2787);
				x=booleanLiteral();
				PopFollow();

				DebugLocation(385, 21);
				 result = x; 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScriptWalker.g3:386:4: x= numericLiteral
				{
				DebugLocation(386, 5);
				PushFollow(Follow._numericLiteral_in_literal2796);
				x=numericLiteral();
				PopFollow();

				DebugLocation(386, 21);
				 result = x; 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScriptWalker.g3:387:4: StringLiteral
				{
				DebugLocation(387, 4);
				StringLiteral1=(CommonTree)Match(input,StringLiteral,Follow._StringLiteral_in_literal2803); 
				DebugLocation(387, 18);
				 result = JsExpression.String(UnescapeStringLiteral(StringLiteral1.Text)); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScriptWalker.g3:388:4: RegularExpressionLiteral
				{
				DebugLocation(388, 4);
				RegularExpressionLiteral2=(CommonTree)Match(input,RegularExpressionLiteral,Follow._RegularExpressionLiteral_in_literal2810); 
				DebugLocation(388, 29);
				 result = ParseRegexpLiteral(RegularExpressionLiteral2.Text); 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// TypeScriptWalker.g3:389:4: x= arrayLiteral
				{
				DebugLocation(389, 5);
				PushFollow(Follow._arrayLiteral_in_literal2819);
				x=arrayLiteral();
				PopFollow();

				DebugLocation(389, 19);
				 result = x; 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// TypeScriptWalker.g3:390:4: x= objectLiteral
				{
				DebugLocation(390, 5);
				PushFollow(Follow._objectLiteral_in_literal2828);
				x=objectLiteral();
				PopFollow();

				DebugLocation(390, 20);
				 result = x; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("literal", 36);
			LeaveRule("literal", 36);
			LeaveRule_literal();
		}
		DebugLocation(391, 1);
		} finally { DebugExitRule(GrammarFileName, "literal"); }
		return result;

	}
	// $ANTLR end "literal"

	partial void EnterRule_booleanLiteral();
	partial void LeaveRule_booleanLiteral();
	// $ANTLR start "booleanLiteral"
	// TypeScriptWalker.g3:393:1: booleanLiteral returns [JsExpression result] : ( TRUE | FALSE );
	[GrammarRule("booleanLiteral")]
	private JsExpression booleanLiteral()
	{
		EnterRule_booleanLiteral();
		EnterRule("booleanLiteral", 37);
		TraceIn("booleanLiteral", 37);
		JsExpression result = default(JsExpression);


		try { DebugEnterRule(GrammarFileName, "booleanLiteral");
		DebugLocation(393, 1);
		try
		{
			// TypeScriptWalker.g3:394:2: ( TRUE | FALSE )
			int alt41=2;
			try { DebugEnterDecision(41, false);
			int LA41_1 = input.LA(1);

			if ((LA41_1==TRUE))
			{
				alt41 = 1;
			}
			else if ((LA41_1==FALSE))
			{
				alt41 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 41, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:394:4: TRUE
				{
				DebugLocation(394, 4);
				Match(input,TRUE,Follow._TRUE_in_booleanLiteral2845); 
				DebugLocation(394, 10);
				 result = JsExpression.True; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:395:4: FALSE
				{
				DebugLocation(395, 4);
				Match(input,FALSE,Follow._FALSE_in_booleanLiteral2853); 
				DebugLocation(395, 10);
				 result = JsExpression.False; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("booleanLiteral", 37);
			LeaveRule("booleanLiteral", 37);
			LeaveRule_booleanLiteral();
		}
		DebugLocation(396, 1);
		} finally { DebugExitRule(GrammarFileName, "booleanLiteral"); }
		return result;

	}
	// $ANTLR end "booleanLiteral"

	partial void EnterRule_numericLiteral();
	partial void LeaveRule_numericLiteral();
	// $ANTLR start "numericLiteral"
	// TypeScriptWalker.g3:398:1: numericLiteral returns [JsExpression result] : ( DecimalLiteral | OctalIntegerLiteral | HexIntegerLiteral );
	[GrammarRule("numericLiteral")]
	private JsExpression numericLiteral()
	{
		EnterRule_numericLiteral();
		EnterRule("numericLiteral", 38);
		TraceIn("numericLiteral", 38);
		JsExpression result = default(JsExpression);


		CommonTree DecimalLiteral3 = default(CommonTree);
		CommonTree OctalIntegerLiteral4 = default(CommonTree);
		CommonTree HexIntegerLiteral5 = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "numericLiteral");
		DebugLocation(398, 1);
		try
		{
			// TypeScriptWalker.g3:399:2: ( DecimalLiteral | OctalIntegerLiteral | HexIntegerLiteral )
			int alt42=3;
			try { DebugEnterDecision(42, false);
			switch (input.LA(1))
			{
			case DecimalLiteral:
				{
				alt42 = 1;
				}
				break;
			case OctalIntegerLiteral:
				{
				alt42 = 2;
				}
				break;
			case HexIntegerLiteral:
				{
				alt42 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 42, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:399:4: DecimalLiteral
				{
				DebugLocation(399, 4);
				DecimalLiteral3=(CommonTree)Match(input,DecimalLiteral,Follow._DecimalLiteral_in_numericLiteral2870); 
				DebugLocation(399, 24);
				 result = JsExpression.Number(double.Parse(DecimalLiteral3.Text, NumberStyles.Float, CultureInfo.InvariantCulture)); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:400:4: OctalIntegerLiteral
				{
				DebugLocation(400, 4);
				OctalIntegerLiteral4=(CommonTree)Match(input,OctalIntegerLiteral,Follow._OctalIntegerLiteral_in_numericLiteral2882); 
				DebugLocation(400, 24);
				 result = JsExpression.Number(DecodeOctalNumber(OctalIntegerLiteral4.Text)); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:401:4: HexIntegerLiteral
				{
				DebugLocation(401, 4);
				HexIntegerLiteral5=(CommonTree)Match(input,HexIntegerLiteral,Follow._HexIntegerLiteral_in_numericLiteral2889); 
				DebugLocation(401, 24);
				 result = JsExpression.Number(int.Parse(HexIntegerLiteral5.Text.Substring(2), NumberStyles.HexNumber, CultureInfo.InvariantCulture)); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("numericLiteral", 38);
			LeaveRule("numericLiteral", 38);
			LeaveRule_numericLiteral();
		}
		DebugLocation(402, 1);
		} finally { DebugExitRule(GrammarFileName, "numericLiteral"); }
		return result;

	}
	// $ANTLR end "numericLiteral"

	partial void EnterRule_arrayLiteral();
	partial void LeaveRule_arrayLiteral();
	// $ANTLR start "arrayLiteral"
	// TypeScriptWalker.g3:404:1: arrayLiteral returns [JsExpression result] : ^( ARRAY ( ^( ITEM (x= expr )? ) )* ) ;
	[GrammarRule("arrayLiteral")]
	private JsExpression arrayLiteral()
	{
		EnterRule_arrayLiteral();
		EnterRule("arrayLiteral", 39);
		TraceIn("arrayLiteral", 39);
		JsExpression result = default(JsExpression);


		JsExpression x = default(JsExpression);

		 var items = new List<JsExpression>(); 
		try { DebugEnterRule(GrammarFileName, "arrayLiteral");
		DebugLocation(404, 1);
		try
		{
			// TypeScriptWalker.g3:406:2: ( ^( ARRAY ( ^( ITEM (x= expr )? ) )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:406:4: ^( ARRAY ( ^( ITEM (x= expr )? ) )* )
			{
			DebugLocation(406, 4);
			DebugLocation(406, 7);
			Match(input,ARRAY,Follow._ARRAY_in_arrayLiteral2915); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(406, 13);
				// TypeScriptWalker.g3:406:13: ( ^( ITEM (x= expr )? ) )*
				try { DebugEnterSubRule(44);
				while (true)
				{
					int alt44=2;
					try { DebugEnterDecision(44, false);
					int LA44_1 = input.LA(1);

					if ((LA44_1==ITEM))
					{
						alt44 = 1;
					}


					} finally { DebugExitDecision(44); }
					switch ( alt44 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:406:15: ^( ITEM (x= expr )? )
						{
						DebugLocation(406, 15);
						DebugLocation(406, 18);
						Match(input,ITEM,Follow._ITEM_in_arrayLiteral2921); 

						DebugLocation(406, 23);
						 x = null; 

						if (input.LA(1) == TokenTypes.Down)
						{
							Match(input, TokenTypes.Down, null); 
							DebugLocation(406, 38);
							// TypeScriptWalker.g3:406:38: (x= expr )?
							int alt43=2;
							try { DebugEnterSubRule(43);
							try { DebugEnterDecision(43, false);
							try
							{
								alt43 = dfa43.Predict(input);
							}
							catch (NoViableAltException nvae)
							{
								DebugRecognitionException(nvae);
								throw;
							}
							} finally { DebugExitDecision(43); }
							switch (alt43)
							{
							case 1:
								DebugEnterAlt(1);
								// TypeScriptWalker.g3:406:38: x= expr
								{
								DebugLocation(406, 38);
								PushFollow(Follow._expr_in_arrayLiteral2927);
								x=expr();
								PopFollow();


								}
								break;

							}
							} finally { DebugExitSubRule(43); }


							Match(input, TokenTypes.Up, null); 
						}

						DebugLocation(406, 47);
						 items.Add(x); 

						}
						break;

					default:
						goto loop44;
					}
				}

				loop44:
					;

				} finally { DebugExitSubRule(44); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(406, 70);
			 result = JsExpression.ArrayLiteral(items); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("arrayLiteral", 39);
			LeaveRule("arrayLiteral", 39);
			LeaveRule_arrayLiteral();
		}
		DebugLocation(407, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayLiteral"); }
		return result;

	}
	// $ANTLR end "arrayLiteral"

	partial void EnterRule_objectLiteral();
	partial void LeaveRule_objectLiteral();
	// $ANTLR start "objectLiteral"
	// TypeScriptWalker.g3:409:1: objectLiteral returns [JsExpression result] : ^( OBJECT ( ^( NAMEDVALUE n= propertyName x= expr ) )* ) ;
	[GrammarRule("objectLiteral")]
	private JsExpression objectLiteral()
	{
		EnterRule_objectLiteral();
		EnterRule("objectLiteral", 40);
		TraceIn("objectLiteral", 40);
		JsExpression result = default(JsExpression);


		string n = default(string);
		JsExpression x = default(JsExpression);

		 var props = new List<JsObjectLiteralProperty>(); 
		try { DebugEnterRule(GrammarFileName, "objectLiteral");
		DebugLocation(409, 1);
		try
		{
			// TypeScriptWalker.g3:411:2: ( ^( OBJECT ( ^( NAMEDVALUE n= propertyName x= expr ) )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:411:4: ^( OBJECT ( ^( NAMEDVALUE n= propertyName x= expr ) )* )
			{
			DebugLocation(411, 4);
			DebugLocation(411, 7);
			Match(input,OBJECT,Follow._OBJECT_in_objectLiteral2961); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(411, 14);
				// TypeScriptWalker.g3:411:14: ( ^( NAMEDVALUE n= propertyName x= expr ) )*
				try { DebugEnterSubRule(45);
				while (true)
				{
					int alt45=2;
					try { DebugEnterDecision(45, false);
					int LA45_1 = input.LA(1);

					if ((LA45_1==NAMEDVALUE))
					{
						alt45 = 1;
					}


					} finally { DebugExitDecision(45); }
					switch ( alt45 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:411:16: ^( NAMEDVALUE n= propertyName x= expr )
						{
						DebugLocation(411, 16);
						DebugLocation(411, 19);
						Match(input,NAMEDVALUE,Follow._NAMEDVALUE_in_objectLiteral2967); 

						Match(input, TokenTypes.Down, null); 
						DebugLocation(411, 31);
						PushFollow(Follow._propertyName_in_objectLiteral2971);
						n=propertyName();
						PopFollow();

						DebugLocation(411, 46);
						PushFollow(Follow._expr_in_objectLiteral2975);
						x=expr();
						PopFollow();

						DebugLocation(411, 52);
						 props.Add(new JsObjectLiteralProperty(n, x)); 

						Match(input, TokenTypes.Up, null); 


						}
						break;

					default:
						goto loop45;
					}
				}

				loop45:
					;

				} finally { DebugExitSubRule(45); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(411, 109);
			 result = JsExpression.ObjectLiteral(props); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("objectLiteral", 40);
			LeaveRule("objectLiteral", 40);
			LeaveRule_objectLiteral();
		}
		DebugLocation(412, 1);
		} finally { DebugExitRule(GrammarFileName, "objectLiteral"); }
		return result;

	}
	// $ANTLR end "objectLiteral"

	partial void EnterRule_propertyName();
	partial void LeaveRule_propertyName();
	// $ANTLR start "propertyName"
	// TypeScriptWalker.g3:414:1: propertyName returns [ string result ] : (i= identifier | StringLiteral |x= numericLiteral );
	[GrammarRule("propertyName")]
	private string propertyName()
	{
		EnterRule_propertyName();
		EnterRule("propertyName", 41);
		TraceIn("propertyName", 41);
		string result = default(string);


		CommonTree StringLiteral6 = default(CommonTree);
		string i = default(string);
		JsExpression x = default(JsExpression);

		try { DebugEnterRule(GrammarFileName, "propertyName");
		DebugLocation(414, 1);
		try
		{
			// TypeScriptWalker.g3:415:2: (i= identifier | StringLiteral |x= numericLiteral )
			int alt46=3;
			try { DebugEnterDecision(46, false);
			switch (input.LA(1))
			{
			case ANY:
			case CONSTRUCTOR:
			case DECLARE:
			case FINAL:
			case GET:
			case Identifier:
			case MODULE:
			case NUMBER:
			case REQUIRE:
			case SET:
			case STRING:
			case THROWS:
			case TYPE:
				{
				alt46 = 1;
				}
				break;
			case StringLiteral:
				{
				alt46 = 2;
				}
				break;
			case DecimalLiteral:
			case HexIntegerLiteral:
			case OctalIntegerLiteral:
				{
				alt46 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 46, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:415:4: i= identifier
				{
				DebugLocation(415, 5);
				PushFollow(Follow._identifier_in_propertyName3003);
				i=identifier();
				PopFollow();

				DebugLocation(415, 23);
				 result = i; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:416:4: StringLiteral
				{
				DebugLocation(416, 4);
				StringLiteral6=(CommonTree)Match(input,StringLiteral,Follow._StringLiteral_in_propertyName3016); 
				DebugLocation(416, 21);
				 result = StringLiteral6.Text.Substring(1, StringLiteral6.Text.Length - 2); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:417:4: x= numericLiteral
				{
				DebugLocation(417, 5);
				PushFollow(Follow._numericLiteral_in_propertyName3028);
				x=numericLiteral();
				PopFollow();

				DebugLocation(417, 21);
				 result = ((JsConstantExpression)x).NumberValue.ToString(CultureInfo.InvariantCulture); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("propertyName", 41);
			LeaveRule("propertyName", 41);
			LeaveRule_propertyName();
		}
		DebugLocation(418, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyName"); }
		return result;

	}
	// $ANTLR end "propertyName"

	partial void EnterRule_type();
	partial void LeaveRule_type();
	// $ANTLR start "type"
	// TypeScriptWalker.g3:420:8: public type returns [TsType result] : ( (t= typeReference ) | (t= primitiveType ) | (t= objectType ) | (t= constructorType ) | (t= functionType ) | (t= tupleType ) ) ( ARRAY_TYPE )* ;
	[GrammarRule("type")]
	public TsType type()
	{
		EnterRule_type();
		EnterRule("type", 42);
		TraceIn("type", 42);
		TsType result = default(TsType);


		TsType t = default(TsType);

		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(420, 1);
		try
		{
			// TypeScriptWalker.g3:421:5: ( ( (t= typeReference ) | (t= primitiveType ) | (t= objectType ) | (t= constructorType ) | (t= functionType ) | (t= tupleType ) ) ( ARRAY_TYPE )* )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:421:7: ( (t= typeReference ) | (t= primitiveType ) | (t= objectType ) | (t= constructorType ) | (t= functionType ) | (t= tupleType ) ) ( ARRAY_TYPE )*
			{
			DebugLocation(421, 7);
			// TypeScriptWalker.g3:421:7: ( (t= typeReference ) | (t= primitiveType ) | (t= objectType ) | (t= constructorType ) | (t= functionType ) | (t= tupleType ) )
			int alt47=6;
			try { DebugEnterSubRule(47);
			try { DebugEnterDecision(47, false);
			switch (input.LA(1))
			{
			case TYPEREF:
				{
				alt47 = 1;
				}
				break;
			case ANY:
			case BOOLEAN:
			case NUMBER:
			case STRING:
			case VOID:
				{
				alt47 = 2;
				}
				break;
			case OBJECT_TYPE:
				{
				alt47 = 3;
				}
				break;
			case CONST_TYPE:
				{
				alt47 = 4;
				}
				break;
			case FUNC_TYPE:
				{
				alt47 = 5;
				}
				break;
			case TUPLE_TYPE:
				{
				alt47 = 6;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 47, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:421:8: (t= typeReference )
				{
				DebugLocation(421, 8);
				// TypeScriptWalker.g3:421:8: (t= typeReference )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:421:10: t= typeReference
				{
				DebugLocation(421, 11);
				PushFollow(Follow._typeReference_in_type3055);
				t=typeReference();
				PopFollow();


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:422:8: (t= primitiveType )
				{
				DebugLocation(422, 8);
				// TypeScriptWalker.g3:422:8: (t= primitiveType )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:422:10: t= primitiveType
				{
				DebugLocation(422, 11);
				PushFollow(Follow._primitiveType_in_type3070);
				t=primitiveType();
				PopFollow();


				}


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:423:8: (t= objectType )
				{
				DebugLocation(423, 8);
				// TypeScriptWalker.g3:423:8: (t= objectType )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:423:10: t= objectType
				{
				DebugLocation(423, 11);
				PushFollow(Follow._objectType_in_type3085);
				t=objectType();
				PopFollow();


				}


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScriptWalker.g3:424:8: (t= constructorType )
				{
				DebugLocation(424, 8);
				// TypeScriptWalker.g3:424:8: (t= constructorType )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:424:10: t= constructorType
				{
				DebugLocation(424, 11);
				PushFollow(Follow._constructorType_in_type3100);
				t=constructorType();
				PopFollow();


				}


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScriptWalker.g3:425:8: (t= functionType )
				{
				DebugLocation(425, 8);
				// TypeScriptWalker.g3:425:8: (t= functionType )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:425:10: t= functionType
				{
				DebugLocation(425, 11);
				PushFollow(Follow._functionType_in_type3115);
				t=functionType();
				PopFollow();


				}


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScriptWalker.g3:426:8: (t= tupleType )
				{
				DebugLocation(426, 8);
				// TypeScriptWalker.g3:426:8: (t= tupleType )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:426:10: t= tupleType
				{
				DebugLocation(426, 11);
				PushFollow(Follow._tupleType_in_type3130);
				t=tupleType();
				PopFollow();


				}


				}
				break;

			}
			} finally { DebugExitSubRule(47); }

			DebugLocation(427, 5);
			// TypeScriptWalker.g3:427:5: ( ARRAY_TYPE )*
			try { DebugEnterSubRule(48);
			while (true)
			{
				int alt48=2;
				try { DebugEnterDecision(48, false);
				int LA48_1 = input.LA(1);

				if ((LA48_1==ARRAY_TYPE))
				{
					alt48 = 1;
				}


				} finally { DebugExitDecision(48); }
				switch ( alt48 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:427:6: ARRAY_TYPE
					{
					DebugLocation(427, 6);
					Match(input,ARRAY_TYPE,Follow._ARRAY_TYPE_in_type3140); 
					DebugLocation(427, 17);
					t= new TsArrayType(t);

					}
					break;

				default:
					goto loop48;
				}
			}

			loop48:
				;

			} finally { DebugExitSubRule(48); }

			DebugLocation(428, 2);
			 result = t; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("type", 42);
			LeaveRule("type", 42);
			LeaveRule_type();
		}
		DebugLocation(429, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return result;

	}
	// $ANTLR end "type"

	partial void EnterRule_typeReference();
	partial void LeaveRule_typeReference();
	// $ANTLR start "typeReference"
	// TypeScriptWalker.g3:431:1: typeReference returns [TsType result] : ^( TYPEREF n= identifier (args= typeArguments )? ) ;
	[GrammarRule("typeReference")]
	private TsType typeReference()
	{
		EnterRule_typeReference();
		EnterRule("typeReference", 43);
		TraceIn("typeReference", 43);
		TsType result = default(TsType);


		string n = default(string);
		IList<TsType> args = default(IList<TsType>);

		try { DebugEnterRule(GrammarFileName, "typeReference");
		DebugLocation(431, 1);
		try
		{
			// TypeScriptWalker.g3:432:5: ( ^( TYPEREF n= identifier (args= typeArguments )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:432:7: ^( TYPEREF n= identifier (args= typeArguments )? )
			{
			DebugLocation(432, 7);
			DebugLocation(432, 10);
			Match(input,TYPEREF,Follow._TYPEREF_in_typeReference3167); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(432, 19);
			PushFollow(Follow._identifier_in_typeReference3171);
			n=identifier();
			PopFollow();

			DebugLocation(432, 35);
			// TypeScriptWalker.g3:432:35: (args= typeArguments )?
			int alt49=2;
			try { DebugEnterSubRule(49);
			try { DebugEnterDecision(49, false);
			int LA49_1 = input.LA(1);

			if ((LA49_1==TYPE_ARGS))
			{
				alt49 = 1;
			}
			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:432:35: args= typeArguments
				{
				DebugLocation(432, 35);
				PushFollow(Follow._typeArguments_in_typeReference3175);
				args=typeArguments();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(49); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(433, 5);
			 result = new TsTypeReference(n, args); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeReference", 43);
			LeaveRule("typeReference", 43);
			LeaveRule_typeReference();
		}
		DebugLocation(434, 1);
		} finally { DebugExitRule(GrammarFileName, "typeReference"); }
		return result;

	}
	// $ANTLR end "typeReference"

	partial void EnterRule_typeArguments();
	partial void LeaveRule_typeArguments();
	// $ANTLR start "typeArguments"
	// TypeScriptWalker.g3:436:1: typeArguments returns [IList<TsType> result] : ^( TYPE_ARGS (a= type )* ) ;
	[GrammarRule("typeArguments")]
	private IList<TsType> typeArguments()
	{
		EnterRule_typeArguments();
		EnterRule("typeArguments", 44);
		TraceIn("typeArguments", 44);
		IList<TsType> result = default(IList<TsType>);


		TsType a = default(TsType);

		 var args = new List<TsType>(); 
		try { DebugEnterRule(GrammarFileName, "typeArguments");
		DebugLocation(436, 4);
		try
		{
			// TypeScriptWalker.g3:438:2: ( ^( TYPE_ARGS (a= type )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:438:4: ^( TYPE_ARGS (a= type )* )
			{
			DebugLocation(438, 4);
			DebugLocation(438, 7);
			Match(input,TYPE_ARGS,Follow._TYPE_ARGS_in_typeArguments3211); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(438, 17);
				// TypeScriptWalker.g3:438:17: (a= type )*
				try { DebugEnterSubRule(50);
				while (true)
				{
					int alt50=2;
					try { DebugEnterDecision(50, false);
					int LA50_1 = input.LA(1);

					if ((LA50_1==ANY||LA50_1==BOOLEAN||LA50_1==CONST_TYPE||LA50_1==FUNC_TYPE||LA50_1==NUMBER||LA50_1==OBJECT_TYPE||LA50_1==STRING||LA50_1==TUPLE_TYPE||LA50_1==TYPEREF||LA50_1==VOID))
					{
						alt50 = 1;
					}


					} finally { DebugExitDecision(50); }
					switch ( alt50 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:438:18: a= type
						{
						DebugLocation(438, 19);
						PushFollow(Follow._type_in_typeArguments3216);
						a=type();
						PopFollow();

						DebugLocation(438, 25);
						 args.Add(a); 

						}
						break;

					default:
						goto loop50;
					}
				}

				loop50:
					;

				} finally { DebugExitSubRule(50); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(439, 5);
			 result = args; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeArguments", 44);
			LeaveRule("typeArguments", 44);
			LeaveRule_typeArguments();
		}
		DebugLocation(440, 4);
		} finally { DebugExitRule(GrammarFileName, "typeArguments"); }
		return result;

	}
	// $ANTLR end "typeArguments"

	partial void EnterRule_primitiveType();
	partial void LeaveRule_primitiveType();
	// $ANTLR start "primitiveType"
	// TypeScriptWalker.g3:442:1: primitiveType returns [TsType result] : ( ( ANY ) | ( NUMBER ) | ( BOOLEAN ) | ( STRING ) | ( VOID ) );
	[GrammarRule("primitiveType")]
	private TsType primitiveType()
	{
		EnterRule_primitiveType();
		EnterRule("primitiveType", 45);
		TraceIn("primitiveType", 45);
		TsType result = default(TsType);


		try { DebugEnterRule(GrammarFileName, "primitiveType");
		DebugLocation(442, 4);
		try
		{
			// TypeScriptWalker.g3:443:5: ( ( ANY ) | ( NUMBER ) | ( BOOLEAN ) | ( STRING ) | ( VOID ) )
			int alt51=5;
			try { DebugEnterDecision(51, false);
			switch (input.LA(1))
			{
			case ANY:
				{
				alt51 = 1;
				}
				break;
			case NUMBER:
				{
				alt51 = 2;
				}
				break;
			case BOOLEAN:
				{
				alt51 = 3;
				}
				break;
			case STRING:
				{
				alt51 = 4;
				}
				break;
			case VOID:
				{
				alt51 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 51, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:443:7: ( ANY )
				{
				DebugLocation(443, 7);
				// TypeScriptWalker.g3:443:7: ( ANY )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:443:8: ANY
				{
				DebugLocation(443, 8);
				Match(input,ANY,Follow._ANY_in_primitiveType3250); 

				}

				DebugLocation(443, 13);
				result = TsPrimitiveType.Any; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:444:7: ( NUMBER )
				{
				DebugLocation(444, 7);
				// TypeScriptWalker.g3:444:7: ( NUMBER )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:444:8: NUMBER
				{
				DebugLocation(444, 8);
				Match(input,NUMBER,Follow._NUMBER_in_primitiveType3262); 

				}

				DebugLocation(444, 16);
				result = TsPrimitiveType.Number; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:445:7: ( BOOLEAN )
				{
				DebugLocation(445, 7);
				// TypeScriptWalker.g3:445:7: ( BOOLEAN )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:445:8: BOOLEAN
				{
				DebugLocation(445, 8);
				Match(input,BOOLEAN,Follow._BOOLEAN_in_primitiveType3274); 

				}

				DebugLocation(445, 17);
				result = TsPrimitiveType.Boolean; 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScriptWalker.g3:446:7: ( STRING )
				{
				DebugLocation(446, 7);
				// TypeScriptWalker.g3:446:7: ( STRING )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:446:8: STRING
				{
				DebugLocation(446, 8);
				Match(input,STRING,Follow._STRING_in_primitiveType3286); 

				}

				DebugLocation(446, 16);
				result = TsPrimitiveType.String; 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScriptWalker.g3:447:7: ( VOID )
				{
				DebugLocation(447, 7);
				// TypeScriptWalker.g3:447:7: ( VOID )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:447:8: VOID
				{
				DebugLocation(447, 8);
				Match(input,VOID,Follow._VOID_in_primitiveType3298); 

				}

				DebugLocation(447, 14);
				result = TsPrimitiveType.Void; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("primitiveType", 45);
			LeaveRule("primitiveType", 45);
			LeaveRule_primitiveType();
		}
		DebugLocation(448, 4);
		} finally { DebugExitRule(GrammarFileName, "primitiveType"); }
		return result;

	}
	// $ANTLR end "primitiveType"

	partial void EnterRule_objectType();
	partial void LeaveRule_objectType();
	// $ANTLR start "objectType"
	// TypeScriptWalker.g3:450:1: objectType returns [TsType result] : ^( OBJECT_TYPE (m= typeMember )* ) ;
	[GrammarRule("objectType")]
	private TsType objectType()
	{
		EnterRule_objectType();
		EnterRule("objectType", 46);
		TraceIn("objectType", 46);
		TsType result = default(TsType);


		TsTypeMember m = default(TsTypeMember);

		 var members = new List<TsTypeMember>(); 
		try { DebugEnterRule(GrammarFileName, "objectType");
		DebugLocation(450, 4);
		try
		{
			// TypeScriptWalker.g3:452:5: ( ^( OBJECT_TYPE (m= typeMember )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:452:7: ^( OBJECT_TYPE (m= typeMember )* )
			{
			DebugLocation(452, 7);
			DebugLocation(452, 9);
			Match(input,OBJECT_TYPE,Follow._OBJECT_TYPE_in_objectType3332); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(452, 21);
				// TypeScriptWalker.g3:452:21: (m= typeMember )*
				try { DebugEnterSubRule(52);
				while (true)
				{
					int alt52=2;
					try { DebugEnterDecision(52, false);
					int LA52_1 = input.LA(1);

					if ((LA52_1==CALL_SIG||LA52_1==CONST_SIG||LA52_1==INDEX_SIG||LA52_1==METH_SIG||LA52_1==PROP_SIG))
					{
						alt52 = 1;
					}


					} finally { DebugExitDecision(52); }
					switch ( alt52 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:452:22: m= typeMember
						{
						DebugLocation(452, 23);
						PushFollow(Follow._typeMember_in_objectType3337);
						m=typeMember();
						PopFollow();

						DebugLocation(452, 35);
						 members.Add(m); 

						}
						break;

					default:
						goto loop52;
					}
				}

				loop52:
					;

				} finally { DebugExitSubRule(52); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(453, 5);
			 result = new TsObjectType(members); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("objectType", 46);
			LeaveRule("objectType", 46);
			LeaveRule_objectType();
		}
		DebugLocation(454, 4);
		} finally { DebugExitRule(GrammarFileName, "objectType"); }
		return result;

	}
	// $ANTLR end "objectType"

	partial void EnterRule_typeMember();
	partial void LeaveRule_typeMember();
	// $ANTLR start "typeMember"
	// TypeScriptWalker.g3:456:1: typeMember returns [TsTypeMember result] : ( (m= propertySignature ) | (m= callSignature ) | (m= indexSignature ) | (m= methodSignature ) | (m= constructSignature ) ) ;
	[GrammarRule("typeMember")]
	private TsTypeMember typeMember()
	{
		EnterRule_typeMember();
		EnterRule("typeMember", 47);
		TraceIn("typeMember", 47);
		TsTypeMember result = default(TsTypeMember);


		TsTypeMember m = default(TsTypeMember);

		try { DebugEnterRule(GrammarFileName, "typeMember");
		DebugLocation(456, 4);
		try
		{
			// TypeScriptWalker.g3:457:5: ( ( (m= propertySignature ) | (m= callSignature ) | (m= indexSignature ) | (m= methodSignature ) | (m= constructSignature ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:457:7: ( (m= propertySignature ) | (m= callSignature ) | (m= indexSignature ) | (m= methodSignature ) | (m= constructSignature ) )
			{
			DebugLocation(457, 7);
			// TypeScriptWalker.g3:457:7: ( (m= propertySignature ) | (m= callSignature ) | (m= indexSignature ) | (m= methodSignature ) | (m= constructSignature ) )
			int alt53=5;
			try { DebugEnterSubRule(53);
			try { DebugEnterDecision(53, false);
			switch (input.LA(1))
			{
			case PROP_SIG:
				{
				alt53 = 1;
				}
				break;
			case CALL_SIG:
				{
				alt53 = 2;
				}
				break;
			case INDEX_SIG:
				{
				alt53 = 3;
				}
				break;
			case METH_SIG:
				{
				alt53 = 4;
				}
				break;
			case CONST_SIG:
				{
				alt53 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 53, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(53); }
			switch (alt53)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:457:8: (m= propertySignature )
				{
				DebugLocation(457, 8);
				// TypeScriptWalker.g3:457:8: (m= propertySignature )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:457:10: m= propertySignature
				{
				DebugLocation(457, 11);
				PushFollow(Follow._propertySignature_in_typeMember3374);
				m=propertySignature();
				PopFollow();


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:458:7: (m= callSignature )
				{
				DebugLocation(458, 7);
				// TypeScriptWalker.g3:458:7: (m= callSignature )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:458:8: m= callSignature
				{
				DebugLocation(458, 10);
				PushFollow(Follow._callSignature_in_typeMember3389);
				m=callSignature();
				PopFollow();


				}


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:459:7: (m= indexSignature )
				{
				DebugLocation(459, 7);
				// TypeScriptWalker.g3:459:7: (m= indexSignature )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:459:8: m= indexSignature
				{
				DebugLocation(459, 10);
				PushFollow(Follow._indexSignature_in_typeMember3403);
				m=indexSignature();
				PopFollow();


				}


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScriptWalker.g3:460:7: (m= methodSignature )
				{
				DebugLocation(460, 7);
				// TypeScriptWalker.g3:460:7: (m= methodSignature )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:460:8: m= methodSignature
				{
				DebugLocation(460, 10);
				PushFollow(Follow._methodSignature_in_typeMember3417);
				m=methodSignature();
				PopFollow();


				}


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScriptWalker.g3:461:7: (m= constructSignature )
				{
				DebugLocation(461, 7);
				// TypeScriptWalker.g3:461:7: (m= constructSignature )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:461:8: m= constructSignature
				{
				DebugLocation(461, 10);
				PushFollow(Follow._constructSignature_in_typeMember3431);
				m=constructSignature();
				PopFollow();


				}


				}
				break;

			}
			} finally { DebugExitSubRule(53); }

			DebugLocation(463, 5);
			 result = m; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeMember", 47);
			LeaveRule("typeMember", 47);
			LeaveRule_typeMember();
		}
		DebugLocation(464, 4);
		} finally { DebugExitRule(GrammarFileName, "typeMember"); }
		return result;

	}
	// $ANTLR end "typeMember"

	partial void EnterRule_propertySignature();
	partial void LeaveRule_propertySignature();
	// $ANTLR start "propertySignature"
	// TypeScriptWalker.g3:466:1: propertySignature returns [TsTypeMember result] : ^( PROP_SIG n= propertyName ( QUE )? (a= typeAnnotation )? ) ;
	[GrammarRule("propertySignature")]
	private TsTypeMember propertySignature()
	{
		EnterRule_propertySignature();
		EnterRule("propertySignature", 48);
		TraceIn("propertySignature", 48);
		TsTypeMember result = default(TsTypeMember);


		string n = default(string);
		TsType a = default(TsType);

		 bool optional = false; 
		try { DebugEnterRule(GrammarFileName, "propertySignature");
		DebugLocation(466, 1);
		try
		{
			// TypeScriptWalker.g3:468:5: ( ^( PROP_SIG n= propertyName ( QUE )? (a= typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:468:7: ^( PROP_SIG n= propertyName ( QUE )? (a= typeAnnotation )? )
			{
			DebugLocation(468, 7);
			DebugLocation(468, 9);
			Match(input,PROP_SIG,Follow._PROP_SIG_in_propertySignature3475); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(468, 19);
			PushFollow(Follow._propertyName_in_propertySignature3479);
			n=propertyName();
			PopFollow();

			DebugLocation(468, 33);
			// TypeScriptWalker.g3:468:33: ( QUE )?
			int alt54=2;
			try { DebugEnterSubRule(54);
			try { DebugEnterDecision(54, false);
			int LA54_1 = input.LA(1);

			if ((LA54_1==QUE))
			{
				alt54 = 1;
			}
			} finally { DebugExitDecision(54); }
			switch (alt54)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:468:34: QUE
				{
				DebugLocation(468, 34);
				Match(input,QUE,Follow._QUE_in_propertySignature3482); 
				DebugLocation(468, 38);
				optional = true;

				}
				break;

			}
			} finally { DebugExitSubRule(54); }

			DebugLocation(468, 60);
			// TypeScriptWalker.g3:468:60: (a= typeAnnotation )?
			int alt55=2;
			try { DebugEnterSubRule(55);
			try { DebugEnterDecision(55, false);
			int LA55_1 = input.LA(1);

			if ((LA55_1==COLON))
			{
				alt55 = 1;
			}
			} finally { DebugExitDecision(55); }
			switch (alt55)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:468:60: a= typeAnnotation
				{
				DebugLocation(468, 60);
				PushFollow(Follow._typeAnnotation_in_propertySignature3490);
				a=typeAnnotation();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(55); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(469, 2);
			 result = new TsPropertySignature(n, a, optional); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("propertySignature", 48);
			LeaveRule("propertySignature", 48);
			LeaveRule_propertySignature();
		}
		DebugLocation(470, 1);
		} finally { DebugExitRule(GrammarFileName, "propertySignature"); }
		return result;

	}
	// $ANTLR end "propertySignature"

	partial void EnterRule_typeAnnotation();
	partial void LeaveRule_typeAnnotation();
	// $ANTLR start "typeAnnotation"
	// TypeScriptWalker.g3:472:1: typeAnnotation returns [TsType result] : ^( COLON t= type ) ;
	[GrammarRule("typeAnnotation")]
	private TsType typeAnnotation()
	{
		EnterRule_typeAnnotation();
		EnterRule("typeAnnotation", 49);
		TraceIn("typeAnnotation", 49);
		TsType result = default(TsType);


		TsType t = default(TsType);

		try { DebugEnterRule(GrammarFileName, "typeAnnotation");
		DebugLocation(472, 4);
		try
		{
			// TypeScriptWalker.g3:473:5: ( ^( COLON t= type ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:473:7: ^( COLON t= type )
			{
			DebugLocation(473, 7);
			DebugLocation(473, 9);
			Match(input,COLON,Follow._COLON_in_typeAnnotation3514); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(473, 16);
			PushFollow(Follow._type_in_typeAnnotation3518);
			t=type();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(474, 2);
			 result = t; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeAnnotation", 49);
			LeaveRule("typeAnnotation", 49);
			LeaveRule_typeAnnotation();
		}
		DebugLocation(475, 4);
		} finally { DebugExitRule(GrammarFileName, "typeAnnotation"); }
		return result;

	}
	// $ANTLR end "typeAnnotation"

	partial void EnterRule_callSignature();
	partial void LeaveRule_callSignature();
	// $ANTLR start "callSignature"
	// TypeScriptWalker.g3:477:1: callSignature returns [TsTypeMember result] : ^( CALL_SIG (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? ) ;
	[GrammarRule("callSignature")]
	private TsTypeMember callSignature()
	{
		EnterRule_callSignature();
		EnterRule("callSignature", 50);
		TraceIn("callSignature", 50);
		TsTypeMember result = default(TsTypeMember);


		IList<TsTypeParameter> typeParams = default(IList<TsTypeParameter>);
		IList<TsParameter> parameters = default(IList<TsParameter>);
		TsType annotation = default(TsType);

		try { DebugEnterRule(GrammarFileName, "callSignature");
		DebugLocation(477, 1);
		try
		{
			// TypeScriptWalker.g3:478:5: ( ^( CALL_SIG (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:478:7: ^( CALL_SIG (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? )
			{
			DebugLocation(478, 7);
			DebugLocation(478, 9);
			Match(input,CALL_SIG,Follow._CALL_SIG_in_callSignature3544); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(478, 18);
				// TypeScriptWalker.g3:478:18: (typeParams= typeParameters )?
				int alt56=2;
				try { DebugEnterSubRule(56);
				try { DebugEnterDecision(56, false);
				int LA56_1 = input.LA(1);

				if ((LA56_1==TYPE_PARAMS))
				{
					alt56 = 1;
				}
				} finally { DebugExitDecision(56); }
				switch (alt56)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:478:19: typeParams= typeParameters
					{
					DebugLocation(478, 30);
					PushFollow(Follow._typeParameters_in_callSignature3551);
					typeParams=typeParameters();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(56); }

				DebugLocation(478, 49);
				// TypeScriptWalker.g3:478:49: (parameters= parameterList )?
				int alt57=2;
				try { DebugEnterSubRule(57);
				try { DebugEnterDecision(57, false);
				int LA57_1 = input.LA(1);

				if ((LA57_1==ELLIPSIS||LA57_1==PARAMS))
				{
					alt57 = 1;
				}
				} finally { DebugExitDecision(57); }
				switch (alt57)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:478:50: parameters= parameterList
					{
					DebugLocation(478, 61);
					PushFollow(Follow._parameterList_in_callSignature3560);
					parameters=parameterList();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(57); }

				DebugLocation(478, 79);
				// TypeScriptWalker.g3:478:79: (annotation= typeAnnotation )?
				int alt58=2;
				try { DebugEnterSubRule(58);
				try { DebugEnterDecision(58, false);
				int LA58_1 = input.LA(1);

				if ((LA58_1==COLON))
				{
					alt58 = 1;
				}
				} finally { DebugExitDecision(58); }
				switch (alt58)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:478:80: annotation= typeAnnotation
					{
					DebugLocation(478, 91);
					PushFollow(Follow._typeAnnotation_in_callSignature3569);
					annotation=typeAnnotation();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(58); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(479, 2);
			 result = new TsCallSignature(typeParams, parameters, annotation); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("callSignature", 50);
			LeaveRule("callSignature", 50);
			LeaveRule_callSignature();
		}
		DebugLocation(480, 1);
		} finally { DebugExitRule(GrammarFileName, "callSignature"); }
		return result;

	}
	// $ANTLR end "callSignature"

	partial void EnterRule_typeParameters();
	partial void LeaveRule_typeParameters();
	// $ANTLR start "typeParameters"
	// TypeScriptWalker.g3:482:1: typeParameters returns [IList<TsTypeParameter> result] : ^( TYPE_PARAMS (t= typeParameter )* ) ;
	[GrammarRule("typeParameters")]
	private IList<TsTypeParameter> typeParameters()
	{
		EnterRule_typeParameters();
		EnterRule("typeParameters", 51);
		TraceIn("typeParameters", 51);
		IList<TsTypeParameter> result = default(IList<TsTypeParameter>);


		TsTypeParameter t = default(TsTypeParameter);

		 var parameters = new List<TsTypeParameter>(); 
		try { DebugEnterRule(GrammarFileName, "typeParameters");
		DebugLocation(482, 4);
		try
		{
			// TypeScriptWalker.g3:484:5: ( ^( TYPE_PARAMS (t= typeParameter )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:484:7: ^( TYPE_PARAMS (t= typeParameter )* )
			{
			DebugLocation(484, 7);
			DebugLocation(484, 9);
			Match(input,TYPE_PARAMS,Follow._TYPE_PARAMS_in_typeParameters3603); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(484, 21);
				// TypeScriptWalker.g3:484:21: (t= typeParameter )*
				try { DebugEnterSubRule(59);
				while (true)
				{
					int alt59=2;
					try { DebugEnterDecision(59, false);
					int LA59_1 = input.LA(1);

					if ((LA59_1==ANY||LA59_1==CONSTRUCTOR||LA59_1==DECLARE||LA59_1==FINAL||LA59_1==GET||LA59_1==Identifier||LA59_1==MODULE||LA59_1==NUMBER||LA59_1==REQUIRE||LA59_1==SET||LA59_1==STRING||LA59_1==THROWS||LA59_1==TYPE))
					{
						alt59 = 1;
					}


					} finally { DebugExitDecision(59); }
					switch ( alt59 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:484:22: t= typeParameter
						{
						DebugLocation(484, 23);
						PushFollow(Follow._typeParameter_in_typeParameters3609);
						t=typeParameter();
						PopFollow();

						DebugLocation(484, 39);
						parameters.Add(t);

						}
						break;

					default:
						goto loop59;
					}
				}

				loop59:
					;

				} finally { DebugExitSubRule(59); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(485, 5);
			 result = parameters; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeParameters", 51);
			LeaveRule("typeParameters", 51);
			LeaveRule_typeParameters();
		}
		DebugLocation(486, 4);
		} finally { DebugExitRule(GrammarFileName, "typeParameters"); }
		return result;

	}
	// $ANTLR end "typeParameters"

	partial void EnterRule_typeParameter();
	partial void LeaveRule_typeParameter();
	// $ANTLR start "typeParameter"
	// TypeScriptWalker.g3:488:1: typeParameter returns [TsTypeParameter result] : ^( (i= identifier ) (c= typeConstraint )? ) ;
	[GrammarRule("typeParameter")]
	private TsTypeParameter typeParameter()
	{
		EnterRule_typeParameter();
		EnterRule("typeParameter", 52);
		TraceIn("typeParameter", 52);
		TsTypeParameter result = default(TsTypeParameter);


		string i = default(string);
		TsType c = default(TsType);

		try { DebugEnterRule(GrammarFileName, "typeParameter");
		DebugLocation(488, 4);
		try
		{
			// TypeScriptWalker.g3:489:5: ( ^( (i= identifier ) (c= typeConstraint )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:489:7: ^( (i= identifier ) (c= typeConstraint )? )
			{
			DebugLocation(489, 7);
			DebugLocation(489, 9);
			// TypeScriptWalker.g3:489:9: (i= identifier )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:489:10: i= identifier
			{
			DebugLocation(489, 12);
			PushFollow(Follow._identifier_in_typeParameter3647);
			i=identifier();
			PopFollow();


			}


			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(489, 26);
				// TypeScriptWalker.g3:489:26: (c= typeConstraint )?
				int alt60=2;
				try { DebugEnterSubRule(60);
				try { DebugEnterDecision(60, false);
				int LA60_1 = input.LA(1);

				if ((LA60_1==EXTENDS))
				{
					alt60 = 1;
				}
				} finally { DebugExitDecision(60); }
				switch (alt60)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:489:27: c= typeConstraint
					{
					DebugLocation(489, 29);
					PushFollow(Follow._typeConstraint_in_typeParameter3655);
					c=typeConstraint();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(60); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(490, 5);
			 result = new TsTypeParameter(i, c);  

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeParameter", 52);
			LeaveRule("typeParameter", 52);
			LeaveRule_typeParameter();
		}
		DebugLocation(491, 4);
		} finally { DebugExitRule(GrammarFileName, "typeParameter"); }
		return result;

	}
	// $ANTLR end "typeParameter"

	partial void EnterRule_typeConstraint();
	partial void LeaveRule_typeConstraint();
	// $ANTLR start "typeConstraint"
	// TypeScriptWalker.g3:493:1: typeConstraint returns [TsType result] : ^( EXTENDS (t= type ) ) ;
	[GrammarRule("typeConstraint")]
	private TsType typeConstraint()
	{
		EnterRule_typeConstraint();
		EnterRule("typeConstraint", 53);
		TraceIn("typeConstraint", 53);
		TsType result = default(TsType);


		TsType t = default(TsType);

		try { DebugEnterRule(GrammarFileName, "typeConstraint");
		DebugLocation(493, 4);
		try
		{
			// TypeScriptWalker.g3:494:5: ( ^( EXTENDS (t= type ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:494:7: ^( EXTENDS (t= type ) )
			{
			DebugLocation(494, 7);
			DebugLocation(494, 9);
			Match(input,EXTENDS,Follow._EXTENDS_in_typeConstraint3686); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(494, 17);
			// TypeScriptWalker.g3:494:17: (t= type )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:494:18: t= type
			{
			DebugLocation(494, 19);
			PushFollow(Follow._type_in_typeConstraint3691);
			t=type();
			PopFollow();


			}


			Match(input, TokenTypes.Up, null); 

			DebugLocation(495, 5);
			 result = t;  

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeConstraint", 53);
			LeaveRule("typeConstraint", 53);
			LeaveRule_typeConstraint();
		}
		DebugLocation(496, 4);
		} finally { DebugExitRule(GrammarFileName, "typeConstraint"); }
		return result;

	}
	// $ANTLR end "typeConstraint"

	partial void EnterRule_parameterList();
	partial void LeaveRule_parameterList();
	// $ANTLR start "parameterList"
	// TypeScriptWalker.g3:498:1: parameterList returns [IList<TsParameter> result] : ( ^( PARAMS (p= parameter )* (r= restParameter )? ) | (r= restParameter ) ) ;
	[GrammarRule("parameterList")]
	private IList<TsParameter> parameterList()
	{
		EnterRule_parameterList();
		EnterRule("parameterList", 54);
		TraceIn("parameterList", 54);
		IList<TsParameter> result = default(IList<TsParameter>);


		TsParameter p = default(TsParameter);
		TsParameter r = default(TsParameter);

		 var parameters = new List<TsParameter>(); 
		try { DebugEnterRule(GrammarFileName, "parameterList");
		DebugLocation(498, 4);
		try
		{
			// TypeScriptWalker.g3:500:5: ( ( ^( PARAMS (p= parameter )* (r= restParameter )? ) | (r= restParameter ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:500:7: ( ^( PARAMS (p= parameter )* (r= restParameter )? ) | (r= restParameter ) )
			{
			DebugLocation(500, 7);
			// TypeScriptWalker.g3:500:7: ( ^( PARAMS (p= parameter )* (r= restParameter )? ) | (r= restParameter ) )
			int alt63=2;
			try { DebugEnterSubRule(63);
			try { DebugEnterDecision(63, false);
			int LA63_1 = input.LA(1);

			if ((LA63_1==PARAMS))
			{
				alt63 = 1;
			}
			else if ((LA63_1==ELLIPSIS))
			{
				alt63 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 63, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:500:8: ^( PARAMS (p= parameter )* (r= restParameter )? )
				{
				DebugLocation(500, 8);
				DebugLocation(500, 10);
				Match(input,PARAMS,Follow._PARAMS_in_parameterList3731); 

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); 
					DebugLocation(500, 17);
					// TypeScriptWalker.g3:500:17: (p= parameter )*
					try { DebugEnterSubRule(61);
					while (true)
					{
						int alt61=2;
						try { DebugEnterDecision(61, false);
						int LA61_1 = input.LA(1);

						if ((LA61_1==PARAM))
						{
							alt61 = 1;
						}


						} finally { DebugExitDecision(61); }
						switch ( alt61 )
						{
						case 1:
							DebugEnterAlt(1);
							// TypeScriptWalker.g3:500:18: p= parameter
							{
							DebugLocation(500, 19);
							PushFollow(Follow._parameter_in_parameterList3736);
							p=parameter();
							PopFollow();

							DebugLocation(500, 30);
							parameters.Add(p);

							}
							break;

						default:
							goto loop61;
						}
					}

					loop61:
						;

					} finally { DebugExitSubRule(61); }

					DebugLocation(500, 53);
					// TypeScriptWalker.g3:500:53: (r= restParameter )?
					int alt62=2;
					try { DebugEnterSubRule(62);
					try { DebugEnterDecision(62, false);
					int LA62_1 = input.LA(1);

					if ((LA62_1==ELLIPSIS))
					{
						alt62 = 1;
					}
					} finally { DebugExitDecision(62); }
					switch (alt62)
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:500:54: r= restParameter
						{
						DebugLocation(500, 55);
						PushFollow(Follow._restParameter_in_parameterList3745);
						r=restParameter();
						PopFollow();

						DebugLocation(500, 70);
						parameters.Add(r);

						}
						break;

					}
					} finally { DebugExitSubRule(62); }


					Match(input, TokenTypes.Up, null); 
				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:501:7: (r= restParameter )
				{
				DebugLocation(501, 7);
				// TypeScriptWalker.g3:501:7: (r= restParameter )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:501:8: r= restParameter
				{
				DebugLocation(501, 9);
				PushFollow(Follow._restParameter_in_parameterList3761);
				r=restParameter();
				PopFollow();

				DebugLocation(501, 24);
				parameters.Add(r);

				}


				}
				break;

			}
			} finally { DebugExitSubRule(63); }

			DebugLocation(502, 5);
			 result = parameters;  

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parameterList", 54);
			LeaveRule("parameterList", 54);
			LeaveRule_parameterList();
		}
		DebugLocation(503, 4);
		} finally { DebugExitRule(GrammarFileName, "parameterList"); }
		return result;

	}
	// $ANTLR end "parameterList"

	partial void EnterRule_parameter();
	partial void LeaveRule_parameter();
	// $ANTLR start "parameter"
	// TypeScriptWalker.g3:505:1: parameter returns [TsParameter result] : ^( PARAM (name= identifier ) (modifier= accessibilityModifier )? ( QUE )? (a= typeAnnotation )? (x= expr )? ) ;
	[GrammarRule("parameter")]
	private TsParameter parameter()
	{
		EnterRule_parameter();
		EnterRule("parameter", 55);
		TraceIn("parameter", 55);
		TsParameter result = default(TsParameter);


		string name = default(string);
		AccessibilityModifier modifier = default(AccessibilityModifier);
		TsType a = default(TsType);
		JsExpression x = default(JsExpression);

		 var optional = false; AccessibilityModifier? m = null; 
		try { DebugEnterRule(GrammarFileName, "parameter");
		DebugLocation(505, 4);
		try
		{
			// TypeScriptWalker.g3:507:5: ( ^( PARAM (name= identifier ) (modifier= accessibilityModifier )? ( QUE )? (a= typeAnnotation )? (x= expr )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:507:7: ^( PARAM (name= identifier ) (modifier= accessibilityModifier )? ( QUE )? (a= typeAnnotation )? (x= expr )? )
			{
			DebugLocation(507, 7);
			DebugLocation(507, 9);
			Match(input,PARAM,Follow._PARAM_in_parameter3802); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(507, 15);
			// TypeScriptWalker.g3:507:15: (name= identifier )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:507:16: name= identifier
			{
			DebugLocation(507, 20);
			PushFollow(Follow._identifier_in_parameter3807);
			name=identifier();
			PopFollow();


			}

			DebugLocation(507, 33);
			// TypeScriptWalker.g3:507:33: (modifier= accessibilityModifier )?
			int alt64=2;
			try { DebugEnterSubRule(64);
			try { DebugEnterDecision(64, false);
			try
			{
				alt64 = dfa64.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:507:34: modifier= accessibilityModifier
				{
				DebugLocation(507, 43);
				PushFollow(Follow._accessibilityModifier_in_parameter3815);
				modifier=accessibilityModifier();
				PopFollow();

				DebugLocation(507, 66);
				m = modifier;

				}
				break;

			}
			} finally { DebugExitSubRule(64); }

			DebugLocation(507, 84);
			// TypeScriptWalker.g3:507:84: ( QUE )?
			int alt65=2;
			try { DebugEnterSubRule(65);
			try { DebugEnterDecision(65, false);
			try
			{
				alt65 = dfa65.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:507:85: QUE
				{
				DebugLocation(507, 85);
				Match(input,QUE,Follow._QUE_in_parameter3821); 
				DebugLocation(507, 89);
				optional = true;

				}
				break;

			}
			} finally { DebugExitSubRule(65); }

			DebugLocation(507, 110);
			// TypeScriptWalker.g3:507:110: (a= typeAnnotation )?
			int alt66=2;
			try { DebugEnterSubRule(66);
			try { DebugEnterDecision(66, false);
			try
			{
				alt66 = dfa66.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:507:111: a= typeAnnotation
				{
				DebugLocation(507, 112);
				PushFollow(Follow._typeAnnotation_in_parameter3830);
				a=typeAnnotation();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(66); }

			DebugLocation(507, 131);
			// TypeScriptWalker.g3:507:131: (x= expr )?
			int alt67=2;
			try { DebugEnterSubRule(67);
			try { DebugEnterDecision(67, false);
			try
			{
				alt67 = dfa67.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(67); }
			switch (alt67)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:507:132: x= expr
				{
				DebugLocation(507, 133);
				PushFollow(Follow._expr_in_parameter3838);
				x=expr();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(67); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(508, 5);
			 result = new TsParameter(name, a, optional, false, m);  

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parameter", 55);
			LeaveRule("parameter", 55);
			LeaveRule_parameter();
		}
		DebugLocation(509, 4);
		} finally { DebugExitRule(GrammarFileName, "parameter"); }
		return result;

	}
	// $ANTLR end "parameter"

	partial void EnterRule_accessibilityModifier();
	partial void LeaveRule_accessibilityModifier();
	// $ANTLR start "accessibilityModifier"
	// TypeScriptWalker.g3:511:1: accessibilityModifier returns [AccessibilityModifier result] : ( ( PUBLIC ) | ( PRIVATE ) | ( PROTECTED ) );
	[GrammarRule("accessibilityModifier")]
	private AccessibilityModifier accessibilityModifier()
	{
		EnterRule_accessibilityModifier();
		EnterRule("accessibilityModifier", 56);
		TraceIn("accessibilityModifier", 56);
		AccessibilityModifier result = default(AccessibilityModifier);


		try { DebugEnterRule(GrammarFileName, "accessibilityModifier");
		DebugLocation(511, 4);
		try
		{
			// TypeScriptWalker.g3:512:5: ( ( PUBLIC ) | ( PRIVATE ) | ( PROTECTED ) )
			int alt68=3;
			try { DebugEnterDecision(68, false);
			switch (input.LA(1))
			{
			case PUBLIC:
				{
				alt68 = 1;
				}
				break;
			case PRIVATE:
				{
				alt68 = 2;
				}
				break;
			case PROTECTED:
				{
				alt68 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 68, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(68); }
			switch (alt68)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:512:7: ( PUBLIC )
				{
				DebugLocation(512, 7);
				// TypeScriptWalker.g3:512:7: ( PUBLIC )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:512:8: PUBLIC
				{
				DebugLocation(512, 8);
				Match(input,PUBLIC,Follow._PUBLIC_in_accessibilityModifier3869); 

				}

				DebugLocation(512, 16);
				result = AccessibilityModifier.Public; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:513:7: ( PRIVATE )
				{
				DebugLocation(513, 7);
				// TypeScriptWalker.g3:513:7: ( PRIVATE )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:513:8: PRIVATE
				{
				DebugLocation(513, 8);
				Match(input,PRIVATE,Follow._PRIVATE_in_accessibilityModifier3881); 

				}

				DebugLocation(513, 17);
				result = AccessibilityModifier.Private; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:514:7: ( PROTECTED )
				{
				DebugLocation(514, 7);
				// TypeScriptWalker.g3:514:7: ( PROTECTED )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:514:8: PROTECTED
				{
				DebugLocation(514, 8);
				Match(input,PROTECTED,Follow._PROTECTED_in_accessibilityModifier3893); 

				}

				DebugLocation(514, 19);
				result = AccessibilityModifier.Protected; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("accessibilityModifier", 56);
			LeaveRule("accessibilityModifier", 56);
			LeaveRule_accessibilityModifier();
		}
		DebugLocation(515, 4);
		} finally { DebugExitRule(GrammarFileName, "accessibilityModifier"); }
		return result;

	}
	// $ANTLR end "accessibilityModifier"

	partial void EnterRule_restParameter();
	partial void LeaveRule_restParameter();
	// $ANTLR start "restParameter"
	// TypeScriptWalker.g3:517:1: restParameter returns [TsParameter result] : ^( ELLIPSIS (n= identifier ) (a= typeAnnotation )? ) ;
	[GrammarRule("restParameter")]
	private TsParameter restParameter()
	{
		EnterRule_restParameter();
		EnterRule("restParameter", 57);
		TraceIn("restParameter", 57);
		TsParameter result = default(TsParameter);


		string n = default(string);
		TsType a = default(TsType);

		try { DebugEnterRule(GrammarFileName, "restParameter");
		DebugLocation(517, 4);
		try
		{
			// TypeScriptWalker.g3:518:5: ( ^( ELLIPSIS (n= identifier ) (a= typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:518:7: ^( ELLIPSIS (n= identifier ) (a= typeAnnotation )? )
			{
			DebugLocation(518, 7);
			DebugLocation(518, 9);
			Match(input,ELLIPSIS,Follow._ELLIPSIS_in_restParameter3918); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(518, 18);
			// TypeScriptWalker.g3:518:18: (n= identifier )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:518:19: n= identifier
			{
			DebugLocation(518, 20);
			PushFollow(Follow._identifier_in_restParameter3923);
			n=identifier();
			PopFollow();


			}

			DebugLocation(518, 33);
			// TypeScriptWalker.g3:518:33: (a= typeAnnotation )?
			int alt69=2;
			try { DebugEnterSubRule(69);
			try { DebugEnterDecision(69, false);
			int LA69_1 = input.LA(1);

			if ((LA69_1==COLON))
			{
				alt69 = 1;
			}
			} finally { DebugExitDecision(69); }
			switch (alt69)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:518:34: a= typeAnnotation
				{
				DebugLocation(518, 35);
				PushFollow(Follow._typeAnnotation_in_restParameter3929);
				a=typeAnnotation();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(69); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(519, 5);
			 result = new TsParameter(n, a, false, true, null);  

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("restParameter", 57);
			LeaveRule("restParameter", 57);
			LeaveRule_restParameter();
		}
		DebugLocation(520, 4);
		} finally { DebugExitRule(GrammarFileName, "restParameter"); }
		return result;

	}
	// $ANTLR end "restParameter"

	partial void EnterRule_indexSignature();
	partial void LeaveRule_indexSignature();
	// $ANTLR start "indexSignature"
	// TypeScriptWalker.g3:522:1: indexSignature returns [TsTypeMember result] : ^( INDEX_SIG (n= identifier ) ( ( STRING ) | ( NUMBER ) ) (a= typeAnnotation ) ) ;
	[GrammarRule("indexSignature")]
	private TsTypeMember indexSignature()
	{
		EnterRule_indexSignature();
		EnterRule("indexSignature", 58);
		TraceIn("indexSignature", 58);
		TsTypeMember result = default(TsTypeMember);


		string n = default(string);
		TsType a = default(TsType);

		 TsPrimitiveType parameterType = null; 
		try { DebugEnterRule(GrammarFileName, "indexSignature");
		DebugLocation(522, 4);
		try
		{
			// TypeScriptWalker.g3:524:5: ( ^( INDEX_SIG (n= identifier ) ( ( STRING ) | ( NUMBER ) ) (a= typeAnnotation ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:524:6: ^( INDEX_SIG (n= identifier ) ( ( STRING ) | ( NUMBER ) ) (a= typeAnnotation ) )
			{
			DebugLocation(524, 6);
			DebugLocation(524, 8);
			Match(input,INDEX_SIG,Follow._INDEX_SIG_in_indexSignature3968); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(524, 18);
			// TypeScriptWalker.g3:524:18: (n= identifier )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:524:19: n= identifier
			{
			DebugLocation(524, 20);
			PushFollow(Follow._identifier_in_indexSignature3973);
			n=identifier();
			PopFollow();


			}

			DebugLocation(524, 33);
			// TypeScriptWalker.g3:524:33: ( ( STRING ) | ( NUMBER ) )
			int alt70=2;
			try { DebugEnterSubRule(70);
			try { DebugEnterDecision(70, false);
			int LA70_1 = input.LA(1);

			if ((LA70_1==STRING))
			{
				alt70 = 1;
			}
			else if ((LA70_1==NUMBER))
			{
				alt70 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 70, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(70); }
			switch (alt70)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:524:34: ( STRING )
				{
				DebugLocation(524, 34);
				// TypeScriptWalker.g3:524:34: ( STRING )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:524:35: STRING
				{
				DebugLocation(524, 35);
				Match(input,STRING,Follow._STRING_in_indexSignature3978); 
				DebugLocation(524, 42);
				parameterType = TsPrimitiveType.String;

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:524:87: ( NUMBER )
				{
				DebugLocation(524, 87);
				// TypeScriptWalker.g3:524:87: ( NUMBER )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:524:88: NUMBER
				{
				DebugLocation(524, 88);
				Match(input,NUMBER,Follow._NUMBER_in_indexSignature3986); 
				DebugLocation(524, 94);
				parameterType = TsPrimitiveType.Number;

				}


				}
				break;

			}
			} finally { DebugExitSubRule(70); }

			DebugLocation(524, 138);
			// TypeScriptWalker.g3:524:138: (a= typeAnnotation )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:524:139: a= typeAnnotation
			{
			DebugLocation(524, 140);
			PushFollow(Follow._typeAnnotation_in_indexSignature3994);
			a=typeAnnotation();
			PopFollow();


			}


			Match(input, TokenTypes.Up, null); 

			DebugLocation(525, 5);
			result = new TsIndexSignature(n, parameterType, a);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("indexSignature", 58);
			LeaveRule("indexSignature", 58);
			LeaveRule_indexSignature();
		}
		DebugLocation(526, 4);
		} finally { DebugExitRule(GrammarFileName, "indexSignature"); }
		return result;

	}
	// $ANTLR end "indexSignature"

	partial void EnterRule_methodSignature();
	partial void LeaveRule_methodSignature();
	// $ANTLR start "methodSignature"
	// TypeScriptWalker.g3:528:1: methodSignature returns [TsTypeMember result] : ^( METH_SIG p= propertyName ( QUE )? (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? ) ;
	[GrammarRule("methodSignature")]
	private TsTypeMember methodSignature()
	{
		EnterRule_methodSignature();
		EnterRule("methodSignature", 59);
		TraceIn("methodSignature", 59);
		TsTypeMember result = default(TsTypeMember);


		string p = default(string);
		IList<TsTypeParameter> typeParams = default(IList<TsTypeParameter>);
		IList<TsParameter> parameters = default(IList<TsParameter>);
		TsType annotation = default(TsType);

		 bool optional = false; 
		try { DebugEnterRule(GrammarFileName, "methodSignature");
		DebugLocation(528, 4);
		try
		{
			// TypeScriptWalker.g3:530:5: ( ^( METH_SIG p= propertyName ( QUE )? (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:530:6: ^( METH_SIG p= propertyName ( QUE )? (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? )
			{
			DebugLocation(530, 6);
			DebugLocation(530, 8);
			Match(input,METH_SIG,Follow._METH_SIG_in_methodSignature4032); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(530, 18);
			PushFollow(Follow._propertyName_in_methodSignature4036);
			p=propertyName();
			PopFollow();

			DebugLocation(530, 32);
			// TypeScriptWalker.g3:530:32: ( QUE )?
			int alt71=2;
			try { DebugEnterSubRule(71);
			try { DebugEnterDecision(71, false);
			int LA71_1 = input.LA(1);

			if ((LA71_1==QUE))
			{
				alt71 = 1;
			}
			} finally { DebugExitDecision(71); }
			switch (alt71)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:530:33: QUE
				{
				DebugLocation(530, 33);
				Match(input,QUE,Follow._QUE_in_methodSignature4039); 
				DebugLocation(530, 37);
				optional = true;

				}
				break;

			}
			} finally { DebugExitSubRule(71); }

			DebugLocation(530, 58);
			// TypeScriptWalker.g3:530:58: (typeParams= typeParameters )?
			int alt72=2;
			try { DebugEnterSubRule(72);
			try { DebugEnterDecision(72, false);
			int LA72_1 = input.LA(1);

			if ((LA72_1==TYPE_PARAMS))
			{
				alt72 = 1;
			}
			} finally { DebugExitDecision(72); }
			switch (alt72)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:530:59: typeParams= typeParameters
				{
				DebugLocation(530, 70);
				PushFollow(Follow._typeParameters_in_methodSignature4050);
				typeParams=typeParameters();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(72); }

			DebugLocation(530, 89);
			// TypeScriptWalker.g3:530:89: (parameters= parameterList )?
			int alt73=2;
			try { DebugEnterSubRule(73);
			try { DebugEnterDecision(73, false);
			int LA73_1 = input.LA(1);

			if ((LA73_1==ELLIPSIS||LA73_1==PARAMS))
			{
				alt73 = 1;
			}
			} finally { DebugExitDecision(73); }
			switch (alt73)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:530:90: parameters= parameterList
				{
				DebugLocation(530, 101);
				PushFollow(Follow._parameterList_in_methodSignature4059);
				parameters=parameterList();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(73); }

			DebugLocation(530, 119);
			// TypeScriptWalker.g3:530:119: (annotation= typeAnnotation )?
			int alt74=2;
			try { DebugEnterSubRule(74);
			try { DebugEnterDecision(74, false);
			int LA74_1 = input.LA(1);

			if ((LA74_1==COLON))
			{
				alt74 = 1;
			}
			} finally { DebugExitDecision(74); }
			switch (alt74)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:530:120: annotation= typeAnnotation
				{
				DebugLocation(530, 131);
				PushFollow(Follow._typeAnnotation_in_methodSignature4068);
				annotation=typeAnnotation();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(74); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(531, 5);
			result = new TsMethodSignature(p, optional, typeParams, parameters, annotation);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("methodSignature", 59);
			LeaveRule("methodSignature", 59);
			LeaveRule_methodSignature();
		}
		DebugLocation(532, 4);
		} finally { DebugExitRule(GrammarFileName, "methodSignature"); }
		return result;

	}
	// $ANTLR end "methodSignature"

	partial void EnterRule_ambientFunctionDeclaration();
	partial void LeaveRule_ambientFunctionDeclaration();
	// $ANTLR start "ambientFunctionDeclaration"
	// TypeScriptWalker.g3:534:1: ambientFunctionDeclaration returns [TsSourceElement result] : ^( AMBIENTFUNCTION i= identifier ( QUE )? (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? ) ;
	[GrammarRule("ambientFunctionDeclaration")]
	private TsSourceElement ambientFunctionDeclaration()
	{
		EnterRule_ambientFunctionDeclaration();
		EnterRule("ambientFunctionDeclaration", 60);
		TraceIn("ambientFunctionDeclaration", 60);
		TsSourceElement result = default(TsSourceElement);


		string i = default(string);
		IList<TsTypeParameter> typeParams = default(IList<TsTypeParameter>);
		IList<TsParameter> parameters = default(IList<TsParameter>);
		TsType annotation = default(TsType);

		 bool optional = false; 
		try { DebugEnterRule(GrammarFileName, "ambientFunctionDeclaration");
		DebugLocation(534, 4);
		try
		{
			// TypeScriptWalker.g3:536:5: ( ^( AMBIENTFUNCTION i= identifier ( QUE )? (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:536:6: ^( AMBIENTFUNCTION i= identifier ( QUE )? (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? )
			{
			DebugLocation(536, 6);
			DebugLocation(536, 8);
			Match(input,AMBIENTFUNCTION,Follow._AMBIENTFUNCTION_in_ambientFunctionDeclaration4107); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(536, 25);
			PushFollow(Follow._identifier_in_ambientFunctionDeclaration4111);
			i=identifier();
			PopFollow();

			DebugLocation(536, 37);
			// TypeScriptWalker.g3:536:37: ( QUE )?
			int alt75=2;
			try { DebugEnterSubRule(75);
			try { DebugEnterDecision(75, false);
			int LA75_1 = input.LA(1);

			if ((LA75_1==QUE))
			{
				alt75 = 1;
			}
			} finally { DebugExitDecision(75); }
			switch (alt75)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:536:38: QUE
				{
				DebugLocation(536, 38);
				Match(input,QUE,Follow._QUE_in_ambientFunctionDeclaration4114); 
				DebugLocation(536, 42);
				optional = true;

				}
				break;

			}
			} finally { DebugExitSubRule(75); }

			DebugLocation(536, 63);
			// TypeScriptWalker.g3:536:63: (typeParams= typeParameters )?
			int alt76=2;
			try { DebugEnterSubRule(76);
			try { DebugEnterDecision(76, false);
			int LA76_1 = input.LA(1);

			if ((LA76_1==TYPE_PARAMS))
			{
				alt76 = 1;
			}
			} finally { DebugExitDecision(76); }
			switch (alt76)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:536:64: typeParams= typeParameters
				{
				DebugLocation(536, 75);
				PushFollow(Follow._typeParameters_in_ambientFunctionDeclaration4125);
				typeParams=typeParameters();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(76); }

			DebugLocation(536, 94);
			// TypeScriptWalker.g3:536:94: (parameters= parameterList )?
			int alt77=2;
			try { DebugEnterSubRule(77);
			try { DebugEnterDecision(77, false);
			int LA77_1 = input.LA(1);

			if ((LA77_1==ELLIPSIS||LA77_1==PARAMS))
			{
				alt77 = 1;
			}
			} finally { DebugExitDecision(77); }
			switch (alt77)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:536:95: parameters= parameterList
				{
				DebugLocation(536, 106);
				PushFollow(Follow._parameterList_in_ambientFunctionDeclaration4134);
				parameters=parameterList();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(77); }

			DebugLocation(536, 124);
			// TypeScriptWalker.g3:536:124: (annotation= typeAnnotation )?
			int alt78=2;
			try { DebugEnterSubRule(78);
			try { DebugEnterDecision(78, false);
			int LA78_1 = input.LA(1);

			if ((LA78_1==COLON))
			{
				alt78 = 1;
			}
			} finally { DebugExitDecision(78); }
			switch (alt78)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:536:125: annotation= typeAnnotation
				{
				DebugLocation(536, 136);
				PushFollow(Follow._typeAnnotation_in_ambientFunctionDeclaration4143);
				annotation=typeAnnotation();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(78); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(537, 5);
			result = new TsAmbientFunctionDeclaration(i, optional, typeParams, parameters, annotation);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ambientFunctionDeclaration", 60);
			LeaveRule("ambientFunctionDeclaration", 60);
			LeaveRule_ambientFunctionDeclaration();
		}
		DebugLocation(538, 4);
		} finally { DebugExitRule(GrammarFileName, "ambientFunctionDeclaration"); }
		return result;

	}
	// $ANTLR end "ambientFunctionDeclaration"

	partial void EnterRule_constructSignature();
	partial void LeaveRule_constructSignature();
	// $ANTLR start "constructSignature"
	// TypeScriptWalker.g3:540:1: constructSignature returns [TsTypeMember result] : ^( CONST_SIG (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? ) ;
	[GrammarRule("constructSignature")]
	private TsTypeMember constructSignature()
	{
		EnterRule_constructSignature();
		EnterRule("constructSignature", 61);
		TraceIn("constructSignature", 61);
		TsTypeMember result = default(TsTypeMember);


		IList<TsTypeParameter> typeParams = default(IList<TsTypeParameter>);
		IList<TsParameter> parameters = default(IList<TsParameter>);
		TsType annotation = default(TsType);

		try { DebugEnterRule(GrammarFileName, "constructSignature");
		DebugLocation(540, 4);
		try
		{
			// TypeScriptWalker.g3:541:5: ( ^( CONST_SIG (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:541:6: ^( CONST_SIG (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? )
			{
			DebugLocation(541, 6);
			DebugLocation(541, 8);
			Match(input,CONST_SIG,Follow._CONST_SIG_in_constructSignature4173); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(541, 18);
				// TypeScriptWalker.g3:541:18: (typeParams= typeParameters )?
				int alt79=2;
				try { DebugEnterSubRule(79);
				try { DebugEnterDecision(79, false);
				int LA79_1 = input.LA(1);

				if ((LA79_1==TYPE_PARAMS))
				{
					alt79 = 1;
				}
				} finally { DebugExitDecision(79); }
				switch (alt79)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:541:19: typeParams= typeParameters
					{
					DebugLocation(541, 30);
					PushFollow(Follow._typeParameters_in_constructSignature4180);
					typeParams=typeParameters();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(79); }

				DebugLocation(541, 49);
				// TypeScriptWalker.g3:541:49: (parameters= parameterList )?
				int alt80=2;
				try { DebugEnterSubRule(80);
				try { DebugEnterDecision(80, false);
				int LA80_1 = input.LA(1);

				if ((LA80_1==ELLIPSIS||LA80_1==PARAMS))
				{
					alt80 = 1;
				}
				} finally { DebugExitDecision(80); }
				switch (alt80)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:541:50: parameters= parameterList
					{
					DebugLocation(541, 61);
					PushFollow(Follow._parameterList_in_constructSignature4189);
					parameters=parameterList();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(80); }

				DebugLocation(541, 79);
				// TypeScriptWalker.g3:541:79: (annotation= typeAnnotation )?
				int alt81=2;
				try { DebugEnterSubRule(81);
				try { DebugEnterDecision(81, false);
				int LA81_1 = input.LA(1);

				if ((LA81_1==COLON))
				{
					alt81 = 1;
				}
				} finally { DebugExitDecision(81); }
				switch (alt81)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:541:80: annotation= typeAnnotation
					{
					DebugLocation(541, 91);
					PushFollow(Follow._typeAnnotation_in_constructSignature4198);
					annotation=typeAnnotation();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(81); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(542, 5);
			result = new TsConstructSignature(typeParams, parameters, annotation);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("constructSignature", 61);
			LeaveRule("constructSignature", 61);
			LeaveRule_constructSignature();
		}
		DebugLocation(543, 4);
		} finally { DebugExitRule(GrammarFileName, "constructSignature"); }
		return result;

	}
	// $ANTLR end "constructSignature"

	partial void EnterRule_functionType();
	partial void LeaveRule_functionType();
	// $ANTLR start "functionType"
	// TypeScriptWalker.g3:545:1: functionType returns [TsType result] : ^( FUNC_TYPE (typeParams= typeParameters )? (parameters= parameterList )? (t= type )? ) ;
	[GrammarRule("functionType")]
	private TsType functionType()
	{
		EnterRule_functionType();
		EnterRule("functionType", 62);
		TraceIn("functionType", 62);
		TsType result = default(TsType);


		IList<TsTypeParameter> typeParams = default(IList<TsTypeParameter>);
		IList<TsParameter> parameters = default(IList<TsParameter>);
		TsType t = default(TsType);

		try { DebugEnterRule(GrammarFileName, "functionType");
		DebugLocation(545, 4);
		try
		{
			// TypeScriptWalker.g3:546:5: ( ^( FUNC_TYPE (typeParams= typeParameters )? (parameters= parameterList )? (t= type )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:546:7: ^( FUNC_TYPE (typeParams= typeParameters )? (parameters= parameterList )? (t= type )? )
			{
			DebugLocation(546, 7);
			DebugLocation(546, 9);
			Match(input,FUNC_TYPE,Follow._FUNC_TYPE_in_functionType4229); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(546, 19);
				// TypeScriptWalker.g3:546:19: (typeParams= typeParameters )?
				int alt82=2;
				try { DebugEnterSubRule(82);
				try { DebugEnterDecision(82, false);
				int LA82_1 = input.LA(1);

				if ((LA82_1==TYPE_PARAMS))
				{
					alt82 = 1;
				}
				} finally { DebugExitDecision(82); }
				switch (alt82)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:546:20: typeParams= typeParameters
					{
					DebugLocation(546, 31);
					PushFollow(Follow._typeParameters_in_functionType4236);
					typeParams=typeParameters();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(82); }

				DebugLocation(546, 50);
				// TypeScriptWalker.g3:546:50: (parameters= parameterList )?
				int alt83=2;
				try { DebugEnterSubRule(83);
				try { DebugEnterDecision(83, false);
				int LA83_1 = input.LA(1);

				if ((LA83_1==ELLIPSIS||LA83_1==PARAMS))
				{
					alt83 = 1;
				}
				} finally { DebugExitDecision(83); }
				switch (alt83)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:546:51: parameters= parameterList
					{
					DebugLocation(546, 62);
					PushFollow(Follow._parameterList_in_functionType4245);
					parameters=parameterList();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(83); }

				DebugLocation(546, 80);
				// TypeScriptWalker.g3:546:80: (t= type )?
				int alt84=2;
				try { DebugEnterSubRule(84);
				try { DebugEnterDecision(84, false);
				int LA84_1 = input.LA(1);

				if ((LA84_1==ANY||LA84_1==BOOLEAN||LA84_1==CONST_TYPE||LA84_1==FUNC_TYPE||LA84_1==NUMBER||LA84_1==OBJECT_TYPE||LA84_1==STRING||LA84_1==TUPLE_TYPE||LA84_1==TYPEREF||LA84_1==VOID))
				{
					alt84 = 1;
				}
				} finally { DebugExitDecision(84); }
				switch (alt84)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:546:81: t= type
					{
					DebugLocation(546, 83);
					PushFollow(Follow._type_in_functionType4254);
					t=type();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(84); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(547, 5);
			 result = new TsFunctionType(typeParams, parameters, t); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("functionType", 62);
			LeaveRule("functionType", 62);
			LeaveRule_functionType();
		}
		DebugLocation(548, 4);
		} finally { DebugExitRule(GrammarFileName, "functionType"); }
		return result;

	}
	// $ANTLR end "functionType"

	partial void EnterRule_constructorType();
	partial void LeaveRule_constructorType();
	// $ANTLR start "constructorType"
	// TypeScriptWalker.g3:550:1: constructorType returns [TsType result] : ^( CONST_TYPE (typeParams= typeParameters )? (parameters= parameterList )? (t= type )? ) ;
	[GrammarRule("constructorType")]
	private TsType constructorType()
	{
		EnterRule_constructorType();
		EnterRule("constructorType", 63);
		TraceIn("constructorType", 63);
		TsType result = default(TsType);


		IList<TsTypeParameter> typeParams = default(IList<TsTypeParameter>);
		IList<TsParameter> parameters = default(IList<TsParameter>);
		TsType t = default(TsType);

		try { DebugEnterRule(GrammarFileName, "constructorType");
		DebugLocation(550, 4);
		try
		{
			// TypeScriptWalker.g3:551:5: ( ^( CONST_TYPE (typeParams= typeParameters )? (parameters= parameterList )? (t= type )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:551:7: ^( CONST_TYPE (typeParams= typeParameters )? (parameters= parameterList )? (t= type )? )
			{
			DebugLocation(551, 7);
			DebugLocation(551, 9);
			Match(input,CONST_TYPE,Follow._CONST_TYPE_in_constructorType4285); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(551, 20);
				// TypeScriptWalker.g3:551:20: (typeParams= typeParameters )?
				int alt85=2;
				try { DebugEnterSubRule(85);
				try { DebugEnterDecision(85, false);
				int LA85_1 = input.LA(1);

				if ((LA85_1==TYPE_PARAMS))
				{
					alt85 = 1;
				}
				} finally { DebugExitDecision(85); }
				switch (alt85)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:551:21: typeParams= typeParameters
					{
					DebugLocation(551, 32);
					PushFollow(Follow._typeParameters_in_constructorType4292);
					typeParams=typeParameters();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(85); }

				DebugLocation(551, 51);
				// TypeScriptWalker.g3:551:51: (parameters= parameterList )?
				int alt86=2;
				try { DebugEnterSubRule(86);
				try { DebugEnterDecision(86, false);
				int LA86_1 = input.LA(1);

				if ((LA86_1==ELLIPSIS||LA86_1==PARAMS))
				{
					alt86 = 1;
				}
				} finally { DebugExitDecision(86); }
				switch (alt86)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:551:52: parameters= parameterList
					{
					DebugLocation(551, 63);
					PushFollow(Follow._parameterList_in_constructorType4301);
					parameters=parameterList();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(86); }

				DebugLocation(551, 81);
				// TypeScriptWalker.g3:551:81: (t= type )?
				int alt87=2;
				try { DebugEnterSubRule(87);
				try { DebugEnterDecision(87, false);
				int LA87_1 = input.LA(1);

				if ((LA87_1==ANY||LA87_1==BOOLEAN||LA87_1==CONST_TYPE||LA87_1==FUNC_TYPE||LA87_1==NUMBER||LA87_1==OBJECT_TYPE||LA87_1==STRING||LA87_1==TUPLE_TYPE||LA87_1==TYPEREF||LA87_1==VOID))
				{
					alt87 = 1;
				}
				} finally { DebugExitDecision(87); }
				switch (alt87)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:551:82: t= type
					{
					DebugLocation(551, 84);
					PushFollow(Follow._type_in_constructorType4310);
					t=type();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(87); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(552, 5);
			 result = new TsConstructorType(typeParams, parameters, t); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("constructorType", 63);
			LeaveRule("constructorType", 63);
			LeaveRule_constructorType();
		}
		DebugLocation(553, 4);
		} finally { DebugExitRule(GrammarFileName, "constructorType"); }
		return result;

	}
	// $ANTLR end "constructorType"

	partial void EnterRule_tupleType();
	partial void LeaveRule_tupleType();
	// $ANTLR start "tupleType"
	// TypeScriptWalker.g3:555:1: tupleType returns [TsType result] : ^( TUPLE_TYPE (t= type )* ) ;
	[GrammarRule("tupleType")]
	private TsType tupleType()
	{
		EnterRule_tupleType();
		EnterRule("tupleType", 64);
		TraceIn("tupleType", 64);
		TsType result = default(TsType);


		TsType t = default(TsType);

		 List<TsType> types = new List<TsType>(); 
		try { DebugEnterRule(GrammarFileName, "tupleType");
		DebugLocation(555, 4);
		try
		{
			// TypeScriptWalker.g3:557:5: ( ^( TUPLE_TYPE (t= type )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:557:7: ^( TUPLE_TYPE (t= type )* )
			{
			DebugLocation(557, 7);
			DebugLocation(557, 9);
			Match(input,TUPLE_TYPE,Follow._TUPLE_TYPE_in_tupleType4350); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(557, 20);
				// TypeScriptWalker.g3:557:20: (t= type )*
				try { DebugEnterSubRule(88);
				while (true)
				{
					int alt88=2;
					try { DebugEnterDecision(88, false);
					int LA88_1 = input.LA(1);

					if ((LA88_1==ANY||LA88_1==BOOLEAN||LA88_1==CONST_TYPE||LA88_1==FUNC_TYPE||LA88_1==NUMBER||LA88_1==OBJECT_TYPE||LA88_1==STRING||LA88_1==TUPLE_TYPE||LA88_1==TYPEREF||LA88_1==VOID))
					{
						alt88 = 1;
					}


					} finally { DebugExitDecision(88); }
					switch ( alt88 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:557:21: t= type
						{
						DebugLocation(557, 23);
						PushFollow(Follow._type_in_tupleType4357);
						t=type();
						PopFollow();

						DebugLocation(557, 30);
						types.Add(t);

						}
						break;

					default:
						goto loop88;
					}
				}

				loop88:
					;

				} finally { DebugExitSubRule(88); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(558, 5);
			 result = new TsTupleType(types); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("tupleType", 64);
			LeaveRule("tupleType", 64);
			LeaveRule_tupleType();
		}
		DebugLocation(559, 4);
		} finally { DebugExitRule(GrammarFileName, "tupleType"); }
		return result;

	}
	// $ANTLR end "tupleType"

	partial void EnterRule_interfaceElement();
	partial void LeaveRule_interfaceElement();
	// $ANTLR start "interfaceElement"
	// TypeScriptWalker.g3:561:1: interfaceElement returns [TsSourceElement result] : ^( INTERFACE i= identifier (p= typeParameters )? (e= extendsClause )? (m= typeMember )* ) ;
	[GrammarRule("interfaceElement")]
	private TsSourceElement interfaceElement()
	{
		EnterRule_interfaceElement();
		EnterRule("interfaceElement", 65);
		TraceIn("interfaceElement", 65);
		TsSourceElement result = default(TsSourceElement);


		string i = default(string);
		IList<TsTypeParameter> p = default(IList<TsTypeParameter>);
		List<TsTypeReference> e = default(List<TsTypeReference>);
		TsTypeMember m = default(TsTypeMember);

		 var members = new List<TsTypeMember>(); 
		try { DebugEnterRule(GrammarFileName, "interfaceElement");
		DebugLocation(561, 4);
		try
		{
			// TypeScriptWalker.g3:563:5: ( ^( INTERFACE i= identifier (p= typeParameters )? (e= extendsClause )? (m= typeMember )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:563:7: ^( INTERFACE i= identifier (p= typeParameters )? (e= extendsClause )? (m= typeMember )* )
			{
			DebugLocation(563, 7);
			DebugLocation(563, 9);
			Match(input,INTERFACE,Follow._INTERFACE_in_interfaceElement4399); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(563, 20);
			PushFollow(Follow._identifier_in_interfaceElement4403);
			i=identifier();
			PopFollow();

			DebugLocation(563, 33);
			// TypeScriptWalker.g3:563:33: (p= typeParameters )?
			int alt89=2;
			try { DebugEnterSubRule(89);
			try { DebugEnterDecision(89, false);
			int LA89_1 = input.LA(1);

			if ((LA89_1==TYPE_PARAMS))
			{
				alt89 = 1;
			}
			} finally { DebugExitDecision(89); }
			switch (alt89)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:563:33: p= typeParameters
				{
				DebugLocation(563, 33);
				PushFollow(Follow._typeParameters_in_interfaceElement4407);
				p=typeParameters();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(89); }

			DebugLocation(563, 51);
			// TypeScriptWalker.g3:563:51: (e= extendsClause )?
			int alt90=2;
			try { DebugEnterSubRule(90);
			try { DebugEnterDecision(90, false);
			int LA90_1 = input.LA(1);

			if ((LA90_1==EXTENDS))
			{
				alt90 = 1;
			}
			} finally { DebugExitDecision(90); }
			switch (alt90)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:563:51: e= extendsClause
				{
				DebugLocation(563, 51);
				PushFollow(Follow._extendsClause_in_interfaceElement4412);
				e=extendsClause();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(90); }

			DebugLocation(563, 67);
			// TypeScriptWalker.g3:563:67: (m= typeMember )*
			try { DebugEnterSubRule(91);
			while (true)
			{
				int alt91=2;
				try { DebugEnterDecision(91, false);
				int LA91_1 = input.LA(1);

				if ((LA91_1==CALL_SIG||LA91_1==CONST_SIG||LA91_1==INDEX_SIG||LA91_1==METH_SIG||LA91_1==PROP_SIG))
				{
					alt91 = 1;
				}


				} finally { DebugExitDecision(91); }
				switch ( alt91 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:563:68: m= typeMember
					{
					DebugLocation(563, 69);
					PushFollow(Follow._typeMember_in_interfaceElement4418);
					m=typeMember();
					PopFollow();

					DebugLocation(563, 81);
					 members.Add(m); 

					}
					break;

				default:
					goto loop91;
				}
			}

			loop91:
				;

			} finally { DebugExitSubRule(91); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(564, 5);
			 result = new TsInterface(i, p, e, members); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("interfaceElement", 65);
			LeaveRule("interfaceElement", 65);
			LeaveRule_interfaceElement();
		}
		DebugLocation(565, 4);
		} finally { DebugExitRule(GrammarFileName, "interfaceElement"); }
		return result;

	}
	// $ANTLR end "interfaceElement"

	partial void EnterRule_extendsClause();
	partial void LeaveRule_extendsClause();
	// $ANTLR start "extendsClause"
	// TypeScriptWalker.g3:567:1: extendsClause returns [List<TsTypeReference> result] : ^( EXTENDS (t= typeReference )* ) ;
	[GrammarRule("extendsClause")]
	private List<TsTypeReference> extendsClause()
	{
		EnterRule_extendsClause();
		EnterRule("extendsClause", 66);
		TraceIn("extendsClause", 66);
		List<TsTypeReference> result = default(List<TsTypeReference>);


		TsType t = default(TsType);

		 var refs = new List<TsTypeReference>(); 
		try { DebugEnterRule(GrammarFileName, "extendsClause");
		DebugLocation(567, 4);
		try
		{
			// TypeScriptWalker.g3:569:5: ( ^( EXTENDS (t= typeReference )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:569:7: ^( EXTENDS (t= typeReference )* )
			{
			DebugLocation(569, 7);
			DebugLocation(569, 9);
			Match(input,EXTENDS,Follow._EXTENDS_in_extendsClause4460); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(569, 17);
				// TypeScriptWalker.g3:569:17: (t= typeReference )*
				try { DebugEnterSubRule(92);
				while (true)
				{
					int alt92=2;
					try { DebugEnterDecision(92, false);
					int LA92_1 = input.LA(1);

					if ((LA92_1==TYPEREF))
					{
						alt92 = 1;
					}


					} finally { DebugExitDecision(92); }
					switch ( alt92 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:569:18: t= typeReference
						{
						DebugLocation(569, 20);
						PushFollow(Follow._typeReference_in_extendsClause4467);
						t=typeReference();
						PopFollow();

						DebugLocation(569, 35);
						refs.Add((TsTypeReference)t);

						}
						break;

					default:
						goto loop92;
					}
				}

				loop92:
					;

				} finally { DebugExitSubRule(92); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(570, 5);
			 result = refs; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("extendsClause", 66);
			LeaveRule("extendsClause", 66);
			LeaveRule_extendsClause();
		}
		DebugLocation(571, 4);
		} finally { DebugExitRule(GrammarFileName, "extendsClause"); }
		return result;

	}
	// $ANTLR end "extendsClause"

	partial void EnterRule_implementsClause();
	partial void LeaveRule_implementsClause();
	// $ANTLR start "implementsClause"
	// TypeScriptWalker.g3:573:1: implementsClause returns [List<TsTypeReference> result] : ^( IMPLEMENTS (t= typeReference )* ) ;
	[GrammarRule("implementsClause")]
	private List<TsTypeReference> implementsClause()
	{
		EnterRule_implementsClause();
		EnterRule("implementsClause", 67);
		TraceIn("implementsClause", 67);
		List<TsTypeReference> result = default(List<TsTypeReference>);


		TsType t = default(TsType);

		 var refs = new List<TsTypeReference>(); 
		try { DebugEnterRule(GrammarFileName, "implementsClause");
		DebugLocation(573, 4);
		try
		{
			// TypeScriptWalker.g3:575:5: ( ^( IMPLEMENTS (t= typeReference )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:575:7: ^( IMPLEMENTS (t= typeReference )* )
			{
			DebugLocation(575, 7);
			DebugLocation(575, 9);
			Match(input,IMPLEMENTS,Follow._IMPLEMENTS_in_implementsClause4508); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(575, 20);
				// TypeScriptWalker.g3:575:20: (t= typeReference )*
				try { DebugEnterSubRule(93);
				while (true)
				{
					int alt93=2;
					try { DebugEnterDecision(93, false);
					int LA93_1 = input.LA(1);

					if ((LA93_1==TYPEREF))
					{
						alt93 = 1;
					}


					} finally { DebugExitDecision(93); }
					switch ( alt93 )
					{
					case 1:
						DebugEnterAlt(1);
						// TypeScriptWalker.g3:575:21: t= typeReference
						{
						DebugLocation(575, 23);
						PushFollow(Follow._typeReference_in_implementsClause4515);
						t=typeReference();
						PopFollow();

						DebugLocation(575, 38);
						refs.Add((TsTypeReference)t);

						}
						break;

					default:
						goto loop93;
					}
				}

				loop93:
					;

				} finally { DebugExitSubRule(93); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(576, 5);
			 result = refs; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("implementsClause", 67);
			LeaveRule("implementsClause", 67);
			LeaveRule_implementsClause();
		}
		DebugLocation(577, 4);
		} finally { DebugExitRule(GrammarFileName, "implementsClause"); }
		return result;

	}
	// $ANTLR end "implementsClause"

	partial void EnterRule_classElement();
	partial void LeaveRule_classElement();
	// $ANTLR start "classElement"
	// TypeScriptWalker.g3:579:1: classElement returns [TsSourceElement result] : ^( CLASS (i= identifier ) (p= typeParameters )? (e= extendsClause )? (imp= implementsClause )? ( (m= classMember ) )* ) ;
	[GrammarRule("classElement")]
	private TsSourceElement classElement()
	{
		EnterRule_classElement();
		EnterRule("classElement", 68);
		TraceIn("classElement", 68);
		TsSourceElement result = default(TsSourceElement);


		string i = default(string);
		IList<TsTypeParameter> p = default(IList<TsTypeParameter>);
		List<TsTypeReference> e = default(List<TsTypeReference>);
		List<TsTypeReference> imp = default(List<TsTypeReference>);
		TsClassMember m = default(TsClassMember);

		 var members = new List<TsClassMember>(); 
		try { DebugEnterRule(GrammarFileName, "classElement");
		DebugLocation(579, 4);
		try
		{
			// TypeScriptWalker.g3:581:5: ( ^( CLASS (i= identifier ) (p= typeParameters )? (e= extendsClause )? (imp= implementsClause )? ( (m= classMember ) )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:581:7: ^( CLASS (i= identifier ) (p= typeParameters )? (e= extendsClause )? (imp= implementsClause )? ( (m= classMember ) )* )
			{
			DebugLocation(581, 7);
			DebugLocation(581, 9);
			Match(input,CLASS,Follow._CLASS_in_classElement4556); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(581, 15);
			// TypeScriptWalker.g3:581:15: (i= identifier )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:581:16: i= identifier
			{
			DebugLocation(581, 17);
			PushFollow(Follow._identifier_in_classElement4561);
			i=identifier();
			PopFollow();


			}

			DebugLocation(581, 30);
			// TypeScriptWalker.g3:581:30: (p= typeParameters )?
			int alt94=2;
			try { DebugEnterSubRule(94);
			try { DebugEnterDecision(94, false);
			int LA94_1 = input.LA(1);

			if ((LA94_1==TYPE_PARAMS))
			{
				alt94 = 1;
			}
			} finally { DebugExitDecision(94); }
			switch (alt94)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:581:31: p= typeParameters
				{
				DebugLocation(581, 32);
				PushFollow(Follow._typeParameters_in_classElement4567);
				p=typeParameters();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(94); }

			DebugLocation(581, 50);
			// TypeScriptWalker.g3:581:50: (e= extendsClause )?
			int alt95=2;
			try { DebugEnterSubRule(95);
			try { DebugEnterDecision(95, false);
			int LA95_1 = input.LA(1);

			if ((LA95_1==EXTENDS))
			{
				alt95 = 1;
			}
			} finally { DebugExitDecision(95); }
			switch (alt95)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:581:51: e= extendsClause
				{
				DebugLocation(581, 52);
				PushFollow(Follow._extendsClause_in_classElement4574);
				e=extendsClause();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(95); }

			DebugLocation(581, 69);
			// TypeScriptWalker.g3:581:69: (imp= implementsClause )?
			int alt96=2;
			try { DebugEnterSubRule(96);
			try { DebugEnterDecision(96, false);
			int LA96_1 = input.LA(1);

			if ((LA96_1==IMPLEMENTS))
			{
				alt96 = 1;
			}
			} finally { DebugExitDecision(96); }
			switch (alt96)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:581:70: imp= implementsClause
				{
				DebugLocation(581, 73);
				PushFollow(Follow._implementsClause_in_classElement4581);
				imp=implementsClause();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(96); }

			DebugLocation(581, 93);
			// TypeScriptWalker.g3:581:93: ( (m= classMember ) )*
			try { DebugEnterSubRule(97);
			while (true)
			{
				int alt97=2;
				try { DebugEnterDecision(97, false);
				int LA97_1 = input.LA(1);

				if ((LA97_1==CONST_DECL||LA97_1==GET||LA97_1==INDEX_SIG||LA97_1==METH_DECL||LA97_1==SET||LA97_1==VAR))
				{
					alt97 = 1;
				}


				} finally { DebugExitDecision(97); }
				switch ( alt97 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:581:94: (m= classMember )
					{
					DebugLocation(581, 94);
					// TypeScriptWalker.g3:581:94: (m= classMember )
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:581:95: m= classMember
					{
					DebugLocation(581, 96);
					PushFollow(Follow._classMember_in_classElement4589);
					m=classMember();
					PopFollow();


					}

					DebugLocation(581, 110);
					 members.Add(m); 

					}
					break;

				default:
					goto loop97;
				}
			}

			loop97:
				;

			} finally { DebugExitSubRule(97); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(582, 5);
			 result = new TsClass(i, p, e, imp, members); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("classElement", 68);
			LeaveRule("classElement", 68);
			LeaveRule_classElement();
		}
		DebugLocation(583, 4);
		} finally { DebugExitRule(GrammarFileName, "classElement"); }
		return result;

	}
	// $ANTLR end "classElement"

	partial void EnterRule_classMember();
	partial void LeaveRule_classMember();
	// $ANTLR start "classMember"
	// TypeScriptWalker.g3:585:1: classMember returns [TsClassMember result] : ( (m= constructorDeclaration ) | (m= methodDeclaration ) | (m= classIndexSignature ) | (m= getAccessor ) | (m= setAccessor ) | (m= memberVariableDeclaration ) ) ;
	[GrammarRule("classMember")]
	private TsClassMember classMember()
	{
		EnterRule_classMember();
		EnterRule("classMember", 69);
		TraceIn("classMember", 69);
		TsClassMember result = default(TsClassMember);


		TsClassMember m = default(TsClassMember);

		try { DebugEnterRule(GrammarFileName, "classMember");
		DebugLocation(585, 4);
		try
		{
			// TypeScriptWalker.g3:586:5: ( ( (m= constructorDeclaration ) | (m= methodDeclaration ) | (m= classIndexSignature ) | (m= getAccessor ) | (m= setAccessor ) | (m= memberVariableDeclaration ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:586:7: ( (m= constructorDeclaration ) | (m= methodDeclaration ) | (m= classIndexSignature ) | (m= getAccessor ) | (m= setAccessor ) | (m= memberVariableDeclaration ) )
			{
			DebugLocation(586, 7);
			// TypeScriptWalker.g3:586:7: ( (m= constructorDeclaration ) | (m= methodDeclaration ) | (m= classIndexSignature ) | (m= getAccessor ) | (m= setAccessor ) | (m= memberVariableDeclaration ) )
			int alt98=6;
			try { DebugEnterSubRule(98);
			try { DebugEnterDecision(98, false);
			switch (input.LA(1))
			{
			case CONST_DECL:
				{
				alt98 = 1;
				}
				break;
			case METH_DECL:
				{
				alt98 = 2;
				}
				break;
			case INDEX_SIG:
				{
				alt98 = 3;
				}
				break;
			case GET:
				{
				alt98 = 4;
				}
				break;
			case SET:
				{
				alt98 = 5;
				}
				break;
			case VAR:
				{
				alt98 = 6;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 98, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(98); }
			switch (alt98)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:586:8: (m= constructorDeclaration )
				{
				DebugLocation(586, 8);
				// TypeScriptWalker.g3:586:8: (m= constructorDeclaration )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:586:9: m= constructorDeclaration
				{
				DebugLocation(586, 11);
				PushFollow(Follow._constructorDeclaration_in_classMember4628);
				m=constructorDeclaration();
				PopFollow();


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:587:8: (m= methodDeclaration )
				{
				DebugLocation(587, 8);
				// TypeScriptWalker.g3:587:8: (m= methodDeclaration )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:587:9: m= methodDeclaration
				{
				DebugLocation(587, 11);
				PushFollow(Follow._methodDeclaration_in_classMember4643);
				m=methodDeclaration();
				PopFollow();


				}


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:588:8: (m= classIndexSignature )
				{
				DebugLocation(588, 8);
				// TypeScriptWalker.g3:588:8: (m= classIndexSignature )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:588:9: m= classIndexSignature
				{
				DebugLocation(588, 11);
				PushFollow(Follow._classIndexSignature_in_classMember4658);
				m=classIndexSignature();
				PopFollow();


				}


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScriptWalker.g3:589:8: (m= getAccessor )
				{
				DebugLocation(589, 8);
				// TypeScriptWalker.g3:589:8: (m= getAccessor )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:589:9: m= getAccessor
				{
				DebugLocation(589, 11);
				PushFollow(Follow._getAccessor_in_classMember4673);
				m=getAccessor();
				PopFollow();


				}


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScriptWalker.g3:590:8: (m= setAccessor )
				{
				DebugLocation(590, 8);
				// TypeScriptWalker.g3:590:8: (m= setAccessor )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:590:9: m= setAccessor
				{
				DebugLocation(590, 11);
				PushFollow(Follow._setAccessor_in_classMember4688);
				m=setAccessor();
				PopFollow();


				}


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScriptWalker.g3:591:8: (m= memberVariableDeclaration )
				{
				DebugLocation(591, 8);
				// TypeScriptWalker.g3:591:8: (m= memberVariableDeclaration )
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:591:9: m= memberVariableDeclaration
				{
				DebugLocation(591, 11);
				PushFollow(Follow._memberVariableDeclaration_in_classMember4703);
				m=memberVariableDeclaration();
				PopFollow();


				}


				}
				break;

			}
			} finally { DebugExitSubRule(98); }

			DebugLocation(592, 5);
			 result = m; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("classMember", 69);
			LeaveRule("classMember", 69);
			LeaveRule_classMember();
		}
		DebugLocation(593, 4);
		} finally { DebugExitRule(GrammarFileName, "classMember"); }
		return result;

	}
	// $ANTLR end "classMember"

	partial void EnterRule_constructorDeclaration();
	partial void LeaveRule_constructorDeclaration();
	// $ANTLR start "constructorDeclaration"
	// TypeScriptWalker.g3:595:1: constructorDeclaration returns [TsClassMember result] : ^( CONST_DECL (s= constructorCallSignature )* (f= block ) ) ;
	[GrammarRule("constructorDeclaration")]
	private TsClassMember constructorDeclaration()
	{
		EnterRule_constructorDeclaration();
		EnterRule("constructorDeclaration", 70);
		TraceIn("constructorDeclaration", 70);
		TsClassMember result = default(TsClassMember);


		TsClassConstructorSignature s = default(TsClassConstructorSignature);
		JsStatement f = default(JsStatement);

		 var signatures = new List<TsClassConstructorSignature>(); 
		try { DebugEnterRule(GrammarFileName, "constructorDeclaration");
		DebugLocation(595, 4);
		try
		{
			// TypeScriptWalker.g3:597:5: ( ^( CONST_DECL (s= constructorCallSignature )* (f= block ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:597:7: ^( CONST_DECL (s= constructorCallSignature )* (f= block ) )
			{
			DebugLocation(597, 7);
			DebugLocation(597, 9);
			Match(input,CONST_DECL,Follow._CONST_DECL_in_constructorDeclaration4742); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(597, 20);
			// TypeScriptWalker.g3:597:20: (s= constructorCallSignature )*
			try { DebugEnterSubRule(99);
			while (true)
			{
				int alt99=2;
				try { DebugEnterDecision(99, false);
				int LA99_1 = input.LA(1);

				if ((LA99_1==CONST_SIG))
				{
					alt99 = 1;
				}


				} finally { DebugExitDecision(99); }
				switch ( alt99 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:597:21: s= constructorCallSignature
					{
					DebugLocation(597, 23);
					PushFollow(Follow._constructorCallSignature_in_constructorDeclaration4749);
					s=constructorCallSignature();
					PopFollow();

					DebugLocation(597, 50);
					 signatures.Add(s);

					}
					break;

				default:
					goto loop99;
				}
			}

			loop99:
				;

			} finally { DebugExitSubRule(99); }

			DebugLocation(597, 74);
			// TypeScriptWalker.g3:597:74: (f= block )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:597:75: f= block
			{
			DebugLocation(597, 77);
			PushFollow(Follow._block_in_constructorDeclaration4760);
			f=block();
			PopFollow();


			}


			Match(input, TokenTypes.Up, null); 

			DebugLocation(598, 5);
			 result = new TsConstructorDeclaration(signatures, f);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("constructorDeclaration", 70);
			LeaveRule("constructorDeclaration", 70);
			LeaveRule_constructorDeclaration();
		}
		DebugLocation(599, 4);
		} finally { DebugExitRule(GrammarFileName, "constructorDeclaration"); }
		return result;

	}
	// $ANTLR end "constructorDeclaration"

	partial void EnterRule_constructorCallSignature();
	partial void LeaveRule_constructorCallSignature();
	// $ANTLR start "constructorCallSignature"
	// TypeScriptWalker.g3:601:1: constructorCallSignature returns [TsClassConstructorSignature result] : ^( CONST_SIG (a= accessibilityModifier )? (parameters= parameterList )? ) ;
	[GrammarRule("constructorCallSignature")]
	private TsClassConstructorSignature constructorCallSignature()
	{
		EnterRule_constructorCallSignature();
		EnterRule("constructorCallSignature", 71);
		TraceIn("constructorCallSignature", 71);
		TsClassConstructorSignature result = default(TsClassConstructorSignature);


		AccessibilityModifier a = default(AccessibilityModifier);
		IList<TsParameter> parameters = default(IList<TsParameter>);

		 AccessibilityModifier? accessibility = null; 
		try { DebugEnterRule(GrammarFileName, "constructorCallSignature");
		DebugLocation(601, 4);
		try
		{
			// TypeScriptWalker.g3:603:5: ( ^( CONST_SIG (a= accessibilityModifier )? (parameters= parameterList )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:603:7: ^( CONST_SIG (a= accessibilityModifier )? (parameters= parameterList )? )
			{
			DebugLocation(603, 7);
			DebugLocation(603, 9);
			Match(input,CONST_SIG,Follow._CONST_SIG_in_constructorCallSignature4799); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(603, 19);
				// TypeScriptWalker.g3:603:19: (a= accessibilityModifier )?
				int alt100=2;
				try { DebugEnterSubRule(100);
				try { DebugEnterDecision(100, false);
				int LA100_1 = input.LA(1);

				if ((LA100_1==PRIVATE||LA100_1==PROTECTED||LA100_1==PUBLIC))
				{
					alt100 = 1;
				}
				} finally { DebugExitDecision(100); }
				switch (alt100)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:603:20: a= accessibilityModifier
					{
					DebugLocation(603, 21);
					PushFollow(Follow._accessibilityModifier_in_constructorCallSignature4804);
					a=accessibilityModifier();
					PopFollow();

					DebugLocation(603, 44);
					accessibility = a;

					}
					break;

				}
				} finally { DebugExitSubRule(100); }

				DebugLocation(603, 67);
				// TypeScriptWalker.g3:603:67: (parameters= parameterList )?
				int alt101=2;
				try { DebugEnterSubRule(101);
				try { DebugEnterDecision(101, false);
				int LA101_1 = input.LA(1);

				if ((LA101_1==ELLIPSIS||LA101_1==PARAMS))
				{
					alt101 = 1;
				}
				} finally { DebugExitDecision(101); }
				switch (alt101)
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:603:68: parameters= parameterList
					{
					DebugLocation(603, 79);
					PushFollow(Follow._parameterList_in_constructorCallSignature4815);
					parameters=parameterList();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(101); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(604, 5);
			 result = new TsClassConstructorSignature(accessibility, parameters);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("constructorCallSignature", 71);
			LeaveRule("constructorCallSignature", 71);
			LeaveRule_constructorCallSignature();
		}
		DebugLocation(605, 4);
		} finally { DebugExitRule(GrammarFileName, "constructorCallSignature"); }
		return result;

	}
	// $ANTLR end "constructorCallSignature"

	partial void EnterRule_methodDeclaration();
	partial void LeaveRule_methodDeclaration();
	// $ANTLR start "methodDeclaration"
	// TypeScriptWalker.g3:607:1: methodDeclaration returns [TsClassMember result] : ^( METH_DECL (s= methodCallSignature )* (f= block ) ) ;
	[GrammarRule("methodDeclaration")]
	private TsClassMember methodDeclaration()
	{
		EnterRule_methodDeclaration();
		EnterRule("methodDeclaration", 72);
		TraceIn("methodDeclaration", 72);
		TsClassMember result = default(TsClassMember);


		TsClassMethodSignature s = default(TsClassMethodSignature);
		JsStatement f = default(JsStatement);

		 var signatures = new List<TsClassMethodSignature>(); 
		try { DebugEnterRule(GrammarFileName, "methodDeclaration");
		DebugLocation(607, 4);
		try
		{
			// TypeScriptWalker.g3:609:5: ( ^( METH_DECL (s= methodCallSignature )* (f= block ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:609:7: ^( METH_DECL (s= methodCallSignature )* (f= block ) )
			{
			DebugLocation(609, 7);
			DebugLocation(609, 9);
			Match(input,METH_DECL,Follow._METH_DECL_in_methodDeclaration4855); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(609, 19);
			// TypeScriptWalker.g3:609:19: (s= methodCallSignature )*
			try { DebugEnterSubRule(102);
			while (true)
			{
				int alt102=2;
				try { DebugEnterDecision(102, false);
				int LA102_1 = input.LA(1);

				if ((LA102_1==METH_SIG))
				{
					alt102 = 1;
				}


				} finally { DebugExitDecision(102); }
				switch ( alt102 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:609:20: s= methodCallSignature
					{
					DebugLocation(609, 22);
					PushFollow(Follow._methodCallSignature_in_methodDeclaration4862);
					s=methodCallSignature();
					PopFollow();

					DebugLocation(609, 44);
					 signatures.Add(s);

					}
					break;

				default:
					goto loop102;
				}
			}

			loop102:
				;

			} finally { DebugExitSubRule(102); }

			DebugLocation(609, 68);
			// TypeScriptWalker.g3:609:68: (f= block )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:609:69: f= block
			{
			DebugLocation(609, 71);
			PushFollow(Follow._block_in_methodDeclaration4873);
			f=block();
			PopFollow();


			}


			Match(input, TokenTypes.Up, null); 

			DebugLocation(610, 5);
			 result = new TsMethodDeclaration(signatures, f);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("methodDeclaration", 72);
			LeaveRule("methodDeclaration", 72);
			LeaveRule_methodDeclaration();
		}
		DebugLocation(611, 4);
		} finally { DebugExitRule(GrammarFileName, "methodDeclaration"); }
		return result;

	}
	// $ANTLR end "methodDeclaration"

	partial void EnterRule_methodCallSignature();
	partial void LeaveRule_methodCallSignature();
	// $ANTLR start "methodCallSignature"
	// TypeScriptWalker.g3:613:1: methodCallSignature returns [TsClassMethodSignature result] : ^( METH_SIG (a= accessibilityModifier )? ( STATIC )? (i= identifier ) (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? ) ;
	[GrammarRule("methodCallSignature")]
	private TsClassMethodSignature methodCallSignature()
	{
		EnterRule_methodCallSignature();
		EnterRule("methodCallSignature", 73);
		TraceIn("methodCallSignature", 73);
		TsClassMethodSignature result = default(TsClassMethodSignature);


		AccessibilityModifier a = default(AccessibilityModifier);
		string i = default(string);
		IList<TsTypeParameter> typeParams = default(IList<TsTypeParameter>);
		IList<TsParameter> parameters = default(IList<TsParameter>);
		TsType annotation = default(TsType);

		 AccessibilityModifier? accessibility = null; bool s = false; 
		try { DebugEnterRule(GrammarFileName, "methodCallSignature");
		DebugLocation(613, 4);
		try
		{
			// TypeScriptWalker.g3:615:5: ( ^( METH_SIG (a= accessibilityModifier )? ( STATIC )? (i= identifier ) (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:615:7: ^( METH_SIG (a= accessibilityModifier )? ( STATIC )? (i= identifier ) (typeParams= typeParameters )? (parameters= parameterList )? (annotation= typeAnnotation )? )
			{
			DebugLocation(615, 7);
			DebugLocation(615, 9);
			Match(input,METH_SIG,Follow._METH_SIG_in_methodCallSignature4912); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(615, 18);
			// TypeScriptWalker.g3:615:18: (a= accessibilityModifier )?
			int alt103=2;
			try { DebugEnterSubRule(103);
			try { DebugEnterDecision(103, false);
			int LA103_1 = input.LA(1);

			if ((LA103_1==PRIVATE||LA103_1==PROTECTED||LA103_1==PUBLIC))
			{
				alt103 = 1;
			}
			} finally { DebugExitDecision(103); }
			switch (alt103)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:615:19: a= accessibilityModifier
				{
				DebugLocation(615, 20);
				PushFollow(Follow._accessibilityModifier_in_methodCallSignature4917);
				a=accessibilityModifier();
				PopFollow();

				DebugLocation(615, 43);
				accessibility = a;

				}
				break;

			}
			} finally { DebugExitSubRule(103); }

			DebugLocation(615, 66);
			// TypeScriptWalker.g3:615:66: ( STATIC )?
			int alt104=2;
			try { DebugEnterSubRule(104);
			try { DebugEnterDecision(104, false);
			int LA104_1 = input.LA(1);

			if ((LA104_1==STATIC))
			{
				alt104 = 1;
			}
			} finally { DebugExitDecision(104); }
			switch (alt104)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:615:67: STATIC
				{
				DebugLocation(615, 67);
				Match(input,STATIC,Follow._STATIC_in_methodCallSignature4924); 
				DebugLocation(615, 74);
				s = true;

				}
				break;

			}
			} finally { DebugExitSubRule(104); }

			DebugLocation(615, 88);
			// TypeScriptWalker.g3:615:88: (i= identifier )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:615:89: i= identifier
			{
			DebugLocation(615, 90);
			PushFollow(Follow._identifier_in_methodCallSignature4933);
			i=identifier();
			PopFollow();


			}

			DebugLocation(615, 103);
			// TypeScriptWalker.g3:615:103: (typeParams= typeParameters )?
			int alt105=2;
			try { DebugEnterSubRule(105);
			try { DebugEnterDecision(105, false);
			int LA105_1 = input.LA(1);

			if ((LA105_1==TYPE_PARAMS))
			{
				alt105 = 1;
			}
			} finally { DebugExitDecision(105); }
			switch (alt105)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:615:104: typeParams= typeParameters
				{
				DebugLocation(615, 115);
				PushFollow(Follow._typeParameters_in_methodCallSignature4941);
				typeParams=typeParameters();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(105); }

			DebugLocation(615, 134);
			// TypeScriptWalker.g3:615:134: (parameters= parameterList )?
			int alt106=2;
			try { DebugEnterSubRule(106);
			try { DebugEnterDecision(106, false);
			int LA106_1 = input.LA(1);

			if ((LA106_1==ELLIPSIS||LA106_1==PARAMS))
			{
				alt106 = 1;
			}
			} finally { DebugExitDecision(106); }
			switch (alt106)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:615:135: parameters= parameterList
				{
				DebugLocation(615, 146);
				PushFollow(Follow._parameterList_in_methodCallSignature4950);
				parameters=parameterList();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(106); }

			DebugLocation(615, 164);
			// TypeScriptWalker.g3:615:164: (annotation= typeAnnotation )?
			int alt107=2;
			try { DebugEnterSubRule(107);
			try { DebugEnterDecision(107, false);
			int LA107_1 = input.LA(1);

			if ((LA107_1==COLON))
			{
				alt107 = 1;
			}
			} finally { DebugExitDecision(107); }
			switch (alt107)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:615:165: annotation= typeAnnotation
				{
				DebugLocation(615, 176);
				PushFollow(Follow._typeAnnotation_in_methodCallSignature4959);
				annotation=typeAnnotation();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(107); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(616, 5);
			 result = new TsClassMethodSignature(accessibility, s, i, parameters, typeParams, annotation);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("methodCallSignature", 73);
			LeaveRule("methodCallSignature", 73);
			LeaveRule_methodCallSignature();
		}
		DebugLocation(617, 4);
		} finally { DebugExitRule(GrammarFileName, "methodCallSignature"); }
		return result;

	}
	// $ANTLR end "methodCallSignature"

	partial void EnterRule_classIndexSignature();
	partial void LeaveRule_classIndexSignature();
	// $ANTLR start "classIndexSignature"
	// TypeScriptWalker.g3:619:1: classIndexSignature returns [TsClassMember result] : ( (s= indexSignature ) ) ;
	[GrammarRule("classIndexSignature")]
	private TsClassMember classIndexSignature()
	{
		EnterRule_classIndexSignature();
		EnterRule("classIndexSignature", 74);
		TraceIn("classIndexSignature", 74);
		TsClassMember result = default(TsClassMember);


		TsTypeMember s = default(TsTypeMember);

		try { DebugEnterRule(GrammarFileName, "classIndexSignature");
		DebugLocation(619, 4);
		try
		{
			// TypeScriptWalker.g3:620:5: ( ( (s= indexSignature ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:620:7: ( (s= indexSignature ) )
			{
			DebugLocation(620, 7);
			// TypeScriptWalker.g3:620:7: ( (s= indexSignature ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:620:8: (s= indexSignature )
			{
			DebugLocation(620, 8);
			// TypeScriptWalker.g3:620:8: (s= indexSignature )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:620:9: s= indexSignature
			{
			DebugLocation(620, 11);
			PushFollow(Follow._indexSignature_in_classIndexSignature4995);
			s=indexSignature();
			PopFollow();


			}


			}

			DebugLocation(621, 5);
			 result = new TsClassIndexSignature((TsIndexSignature)s);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("classIndexSignature", 74);
			LeaveRule("classIndexSignature", 74);
			LeaveRule_classIndexSignature();
		}
		DebugLocation(622, 4);
		} finally { DebugExitRule(GrammarFileName, "classIndexSignature"); }
		return result;

	}
	// $ANTLR end "classIndexSignature"

	partial void EnterRule_getAccessor();
	partial void LeaveRule_getAccessor();
	// $ANTLR start "getAccessor"
	// TypeScriptWalker.g3:624:1: getAccessor returns [TsClassMember result] : ^( GET (a= accessibilityModifier )? ( STATIC )? (i= identifier ) (annotation= typeAnnotation )? (f= block ) ) ;
	[GrammarRule("getAccessor")]
	private TsClassMember getAccessor()
	{
		EnterRule_getAccessor();
		EnterRule("getAccessor", 75);
		TraceIn("getAccessor", 75);
		TsClassMember result = default(TsClassMember);


		AccessibilityModifier a = default(AccessibilityModifier);
		string i = default(string);
		TsType annotation = default(TsType);
		JsStatement f = default(JsStatement);

		 AccessibilityModifier? accessibility = null; bool s = false; 
		try { DebugEnterRule(GrammarFileName, "getAccessor");
		DebugLocation(624, 4);
		try
		{
			// TypeScriptWalker.g3:626:5: ( ^( GET (a= accessibilityModifier )? ( STATIC )? (i= identifier ) (annotation= typeAnnotation )? (f= block ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:626:7: ^( GET (a= accessibilityModifier )? ( STATIC )? (i= identifier ) (annotation= typeAnnotation )? (f= block ) )
			{
			DebugLocation(626, 7);
			DebugLocation(626, 9);
			Match(input,GET,Follow._GET_in_getAccessor5034); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(626, 13);
			// TypeScriptWalker.g3:626:13: (a= accessibilityModifier )?
			int alt108=2;
			try { DebugEnterSubRule(108);
			try { DebugEnterDecision(108, false);
			int LA108_1 = input.LA(1);

			if ((LA108_1==PRIVATE||LA108_1==PROTECTED||LA108_1==PUBLIC))
			{
				alt108 = 1;
			}
			} finally { DebugExitDecision(108); }
			switch (alt108)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:626:14: a= accessibilityModifier
				{
				DebugLocation(626, 15);
				PushFollow(Follow._accessibilityModifier_in_getAccessor5039);
				a=accessibilityModifier();
				PopFollow();

				DebugLocation(626, 38);
				accessibility = a;

				}
				break;

			}
			} finally { DebugExitSubRule(108); }

			DebugLocation(626, 61);
			// TypeScriptWalker.g3:626:61: ( STATIC )?
			int alt109=2;
			try { DebugEnterSubRule(109);
			try { DebugEnterDecision(109, false);
			int LA109_1 = input.LA(1);

			if ((LA109_1==STATIC))
			{
				alt109 = 1;
			}
			} finally { DebugExitDecision(109); }
			switch (alt109)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:626:62: STATIC
				{
				DebugLocation(626, 62);
				Match(input,STATIC,Follow._STATIC_in_getAccessor5046); 
				DebugLocation(626, 69);
				s = true;

				}
				break;

			}
			} finally { DebugExitSubRule(109); }

			DebugLocation(626, 83);
			// TypeScriptWalker.g3:626:83: (i= identifier )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:626:84: i= identifier
			{
			DebugLocation(626, 85);
			PushFollow(Follow._identifier_in_getAccessor5055);
			i=identifier();
			PopFollow();


			}

			DebugLocation(626, 98);
			// TypeScriptWalker.g3:626:98: (annotation= typeAnnotation )?
			int alt110=2;
			try { DebugEnterSubRule(110);
			try { DebugEnterDecision(110, false);
			int LA110_1 = input.LA(1);

			if ((LA110_1==COLON))
			{
				alt110 = 1;
			}
			} finally { DebugExitDecision(110); }
			switch (alt110)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:626:99: annotation= typeAnnotation
				{
				DebugLocation(626, 110);
				PushFollow(Follow._typeAnnotation_in_getAccessor5063);
				annotation=typeAnnotation();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(110); }

			DebugLocation(626, 129);
			// TypeScriptWalker.g3:626:129: (f= block )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:626:130: f= block
			{
			DebugLocation(626, 132);
			PushFollow(Follow._block_in_getAccessor5072);
			f=block();
			PopFollow();


			}


			Match(input, TokenTypes.Up, null); 

			DebugLocation(627, 5);
			 result = new TsClassGetAccessor(accessibility, s, i, annotation, f); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("getAccessor", 75);
			LeaveRule("getAccessor", 75);
			LeaveRule_getAccessor();
		}
		DebugLocation(628, 4);
		} finally { DebugExitRule(GrammarFileName, "getAccessor"); }
		return result;

	}
	// $ANTLR end "getAccessor"

	partial void EnterRule_setAccessor();
	partial void LeaveRule_setAccessor();
	// $ANTLR start "setAccessor"
	// TypeScriptWalker.g3:630:1: setAccessor returns [TsClassMember result] : ^( SET (a= accessibilityModifier )? ( STATIC )? (i= identifier ) (p= parameter ) (annotation= typeAnnotation )? (f= block ) ) ;
	[GrammarRule("setAccessor")]
	private TsClassMember setAccessor()
	{
		EnterRule_setAccessor();
		EnterRule("setAccessor", 76);
		TraceIn("setAccessor", 76);
		TsClassMember result = default(TsClassMember);


		AccessibilityModifier a = default(AccessibilityModifier);
		string i = default(string);
		TsParameter p = default(TsParameter);
		TsType annotation = default(TsType);
		JsStatement f = default(JsStatement);

		 AccessibilityModifier? accessibility = null; bool s = false; 
		try { DebugEnterRule(GrammarFileName, "setAccessor");
		DebugLocation(630, 4);
		try
		{
			// TypeScriptWalker.g3:632:5: ( ^( SET (a= accessibilityModifier )? ( STATIC )? (i= identifier ) (p= parameter ) (annotation= typeAnnotation )? (f= block ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:632:7: ^( SET (a= accessibilityModifier )? ( STATIC )? (i= identifier ) (p= parameter ) (annotation= typeAnnotation )? (f= block ) )
			{
			DebugLocation(632, 7);
			DebugLocation(632, 9);
			Match(input,SET,Follow._SET_in_setAccessor5111); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(632, 13);
			// TypeScriptWalker.g3:632:13: (a= accessibilityModifier )?
			int alt111=2;
			try { DebugEnterSubRule(111);
			try { DebugEnterDecision(111, false);
			int LA111_1 = input.LA(1);

			if ((LA111_1==PRIVATE||LA111_1==PROTECTED||LA111_1==PUBLIC))
			{
				alt111 = 1;
			}
			} finally { DebugExitDecision(111); }
			switch (alt111)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:632:14: a= accessibilityModifier
				{
				DebugLocation(632, 15);
				PushFollow(Follow._accessibilityModifier_in_setAccessor5116);
				a=accessibilityModifier();
				PopFollow();

				DebugLocation(632, 38);
				accessibility = a;

				}
				break;

			}
			} finally { DebugExitSubRule(111); }

			DebugLocation(632, 61);
			// TypeScriptWalker.g3:632:61: ( STATIC )?
			int alt112=2;
			try { DebugEnterSubRule(112);
			try { DebugEnterDecision(112, false);
			int LA112_1 = input.LA(1);

			if ((LA112_1==STATIC))
			{
				alt112 = 1;
			}
			} finally { DebugExitDecision(112); }
			switch (alt112)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:632:62: STATIC
				{
				DebugLocation(632, 62);
				Match(input,STATIC,Follow._STATIC_in_setAccessor5123); 
				DebugLocation(632, 69);
				s = true;

				}
				break;

			}
			} finally { DebugExitSubRule(112); }

			DebugLocation(632, 83);
			// TypeScriptWalker.g3:632:83: (i= identifier )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:632:84: i= identifier
			{
			DebugLocation(632, 85);
			PushFollow(Follow._identifier_in_setAccessor5132);
			i=identifier();
			PopFollow();


			}

			DebugLocation(632, 98);
			// TypeScriptWalker.g3:632:98: (p= parameter )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:632:99: p= parameter
			{
			DebugLocation(632, 101);
			PushFollow(Follow._parameter_in_setAccessor5140);
			p=parameter();
			PopFollow();


			}

			DebugLocation(632, 114);
			// TypeScriptWalker.g3:632:114: (annotation= typeAnnotation )?
			int alt113=2;
			try { DebugEnterSubRule(113);
			try { DebugEnterDecision(113, false);
			int LA113_1 = input.LA(1);

			if ((LA113_1==COLON))
			{
				alt113 = 1;
			}
			} finally { DebugExitDecision(113); }
			switch (alt113)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:632:115: annotation= typeAnnotation
				{
				DebugLocation(632, 126);
				PushFollow(Follow._typeAnnotation_in_setAccessor5148);
				annotation=typeAnnotation();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(113); }

			DebugLocation(632, 145);
			// TypeScriptWalker.g3:632:145: (f= block )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:632:146: f= block
			{
			DebugLocation(632, 148);
			PushFollow(Follow._block_in_setAccessor5157);
			f=block();
			PopFollow();


			}


			Match(input, TokenTypes.Up, null); 

			DebugLocation(633, 5);
			 result = new TsClassSetAccessor(accessibility, s, i, p, annotation, f); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("setAccessor", 76);
			LeaveRule("setAccessor", 76);
			LeaveRule_setAccessor();
		}
		DebugLocation(634, 4);
		} finally { DebugExitRule(GrammarFileName, "setAccessor"); }
		return result;

	}
	// $ANTLR end "setAccessor"

	partial void EnterRule_moduleElement();
	partial void LeaveRule_moduleElement();
	// $ANTLR start "moduleElement"
	// TypeScriptWalker.g3:636:1: moduleElement returns [TsSourceElement result] : ^( MODULE (i= StringLiteral ) (e= sourceElement )* ) ;
	[GrammarRule("moduleElement")]
	private TsSourceElement moduleElement()
	{
		EnterRule_moduleElement();
		EnterRule("moduleElement", 77);
		TraceIn("moduleElement", 77);
		TsSourceElement result = default(TsSourceElement);


		CommonTree i = default(CommonTree);
		TsSourceElement e = default(TsSourceElement);

		 var elements = new List<TsSourceElement>(); 
		try { DebugEnterRule(GrammarFileName, "moduleElement");
		DebugLocation(636, 4);
		try
		{
			// TypeScriptWalker.g3:638:5: ( ^( MODULE (i= StringLiteral ) (e= sourceElement )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:638:7: ^( MODULE (i= StringLiteral ) (e= sourceElement )* )
			{
			DebugLocation(638, 7);
			DebugLocation(638, 9);
			Match(input,MODULE,Follow._MODULE_in_moduleElement5196); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(638, 16);
			// TypeScriptWalker.g3:638:16: (i= StringLiteral )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:638:17: i= StringLiteral
			{
			DebugLocation(638, 18);
			i=(CommonTree)Match(input,StringLiteral,Follow._StringLiteral_in_moduleElement5201); 

			}

			DebugLocation(638, 34);
			// TypeScriptWalker.g3:638:34: (e= sourceElement )*
			try { DebugEnterSubRule(114);
			while (true)
			{
				int alt114=2;
				try { DebugEnterDecision(114, false);
				try
				{
					alt114 = dfa114.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(114); }
				switch ( alt114 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:638:35: e= sourceElement
					{
					DebugLocation(638, 37);
					PushFollow(Follow._sourceElement_in_moduleElement5209);
					e=sourceElement();
					PopFollow();

					DebugLocation(638, 53);
					elements.Add(e);

					}
					break;

				default:
					goto loop114;
				}
			}

			loop114:
				;

			} finally { DebugExitSubRule(114); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(639, 5);
			 result = new TsModule(i.Text.Substring(1, i.Text.Length - 2), elements); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("moduleElement", 77);
			LeaveRule("moduleElement", 77);
			LeaveRule_moduleElement();
		}
		DebugLocation(640, 4);
		} finally { DebugExitRule(GrammarFileName, "moduleElement"); }
		return result;

	}
	// $ANTLR end "moduleElement"

	partial void EnterRule_namespaceElement();
	partial void LeaveRule_namespaceElement();
	// $ANTLR start "namespaceElement"
	// TypeScriptWalker.g3:642:1: namespaceElement returns [TsSourceElement result] : ^( MODULE (i= identifier ) (e= sourceElement )* ) ;
	[GrammarRule("namespaceElement")]
	private TsSourceElement namespaceElement()
	{
		EnterRule_namespaceElement();
		EnterRule("namespaceElement", 78);
		TraceIn("namespaceElement", 78);
		TsSourceElement result = default(TsSourceElement);


		string i = default(string);
		TsSourceElement e = default(TsSourceElement);

		 var elements = new List<TsSourceElement>(); 
		try { DebugEnterRule(GrammarFileName, "namespaceElement");
		DebugLocation(642, 4);
		try
		{
			// TypeScriptWalker.g3:644:5: ( ^( MODULE (i= identifier ) (e= sourceElement )* ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:644:7: ^( MODULE (i= identifier ) (e= sourceElement )* )
			{
			DebugLocation(644, 7);
			DebugLocation(644, 9);
			Match(input,MODULE,Follow._MODULE_in_namespaceElement5251); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(644, 16);
			// TypeScriptWalker.g3:644:16: (i= identifier )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:644:17: i= identifier
			{
			DebugLocation(644, 18);
			PushFollow(Follow._identifier_in_namespaceElement5256);
			i=identifier();
			PopFollow();


			}

			DebugLocation(644, 31);
			// TypeScriptWalker.g3:644:31: (e= sourceElement )*
			try { DebugEnterSubRule(115);
			while (true)
			{
				int alt115=2;
				try { DebugEnterDecision(115, false);
				try
				{
					alt115 = dfa115.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(115); }
				switch ( alt115 )
				{
				case 1:
					DebugEnterAlt(1);
					// TypeScriptWalker.g3:644:32: e= sourceElement
					{
					DebugLocation(644, 34);
					PushFollow(Follow._sourceElement_in_namespaceElement5264);
					e=sourceElement();
					PopFollow();

					DebugLocation(644, 50);
					elements.Add(e);

					}
					break;

				default:
					goto loop115;
				}
			}

			loop115:
				;

			} finally { DebugExitSubRule(115); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(645, 5);
			 result = new TsModule(i, elements); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("namespaceElement", 78);
			LeaveRule("namespaceElement", 78);
			LeaveRule_namespaceElement();
		}
		DebugLocation(646, 4);
		} finally { DebugExitRule(GrammarFileName, "namespaceElement"); }
		return result;

	}
	// $ANTLR end "namespaceElement"

	partial void EnterRule_exportDeclaration();
	partial void LeaveRule_exportDeclaration();
	// $ANTLR start "exportDeclaration"
	// TypeScriptWalker.g3:648:1: exportDeclaration returns [TsSourceElement result] : ^( EXPORT (e= sourceElement ) ) ;
	[GrammarRule("exportDeclaration")]
	private TsSourceElement exportDeclaration()
	{
		EnterRule_exportDeclaration();
		EnterRule("exportDeclaration", 79);
		TraceIn("exportDeclaration", 79);
		TsSourceElement result = default(TsSourceElement);


		TsSourceElement e = default(TsSourceElement);

		try { DebugEnterRule(GrammarFileName, "exportDeclaration");
		DebugLocation(648, 4);
		try
		{
			// TypeScriptWalker.g3:649:5: ( ^( EXPORT (e= sourceElement ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:649:7: ^( EXPORT (e= sourceElement ) )
			{
			DebugLocation(649, 7);
			DebugLocation(649, 9);
			Match(input,EXPORT,Follow._EXPORT_in_exportDeclaration5297); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(649, 17);
			// TypeScriptWalker.g3:649:17: (e= sourceElement )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:649:18: e= sourceElement
			{
			DebugLocation(649, 20);
			PushFollow(Follow._sourceElement_in_exportDeclaration5305);
			e=sourceElement();
			PopFollow();


			}


			Match(input, TokenTypes.Up, null); 

			DebugLocation(650, 5);
			 result = new TsExportElement(e); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exportDeclaration", 79);
			LeaveRule("exportDeclaration", 79);
			LeaveRule_exportDeclaration();
		}
		DebugLocation(651, 4);
		} finally { DebugExitRule(GrammarFileName, "exportDeclaration"); }
		return result;

	}
	// $ANTLR end "exportDeclaration"

	partial void EnterRule_ambientDeclaration();
	partial void LeaveRule_ambientDeclaration();
	// $ANTLR start "ambientDeclaration"
	// TypeScriptWalker.g3:653:1: ambientDeclaration returns [TsSourceElement result] : ^( DECLARE (e= sourceElement ) ) ;
	[GrammarRule("ambientDeclaration")]
	private TsSourceElement ambientDeclaration()
	{
		EnterRule_ambientDeclaration();
		EnterRule("ambientDeclaration", 80);
		TraceIn("ambientDeclaration", 80);
		TsSourceElement result = default(TsSourceElement);


		TsSourceElement e = default(TsSourceElement);

		try { DebugEnterRule(GrammarFileName, "ambientDeclaration");
		DebugLocation(653, 4);
		try
		{
			// TypeScriptWalker.g3:654:5: ( ^( DECLARE (e= sourceElement ) ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:654:7: ^( DECLARE (e= sourceElement ) )
			{
			DebugLocation(654, 7);
			DebugLocation(654, 9);
			Match(input,DECLARE,Follow._DECLARE_in_ambientDeclaration5335); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(654, 18);
			// TypeScriptWalker.g3:654:18: (e= sourceElement )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:654:19: e= sourceElement
			{
			DebugLocation(654, 21);
			PushFollow(Follow._sourceElement_in_ambientDeclaration5343);
			e=sourceElement();
			PopFollow();


			}


			Match(input, TokenTypes.Up, null); 

			DebugLocation(655, 5);
			 result = new TsAmbientDeclaration(e); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ambientDeclaration", 80);
			LeaveRule("ambientDeclaration", 80);
			LeaveRule_ambientDeclaration();
		}
		DebugLocation(656, 4);
		} finally { DebugExitRule(GrammarFileName, "ambientDeclaration"); }
		return result;

	}
	// $ANTLR end "ambientDeclaration"

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();
	// $ANTLR start "identifier"
	// TypeScriptWalker.g3:658:1: identifier returns [string result] : (x= ANY |x= CONSTRUCTOR |x= DECLARE |x= GET |x= SET |x= MODULE |x= REQUIRE |x= NUMBER |x= STRING |x= TYPE |x= FINAL |x= THROWS |x= Identifier ) ;
	[GrammarRule("identifier")]
	private string identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 81);
		TraceIn("identifier", 81);
		string result = default(string);


		CommonTree x = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(658, 4);
		try
		{
			// TypeScriptWalker.g3:659:5: ( (x= ANY |x= CONSTRUCTOR |x= DECLARE |x= GET |x= SET |x= MODULE |x= REQUIRE |x= NUMBER |x= STRING |x= TYPE |x= FINAL |x= THROWS |x= Identifier ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:659:7: (x= ANY |x= CONSTRUCTOR |x= DECLARE |x= GET |x= SET |x= MODULE |x= REQUIRE |x= NUMBER |x= STRING |x= TYPE |x= FINAL |x= THROWS |x= Identifier )
			{
			DebugLocation(659, 7);
			// TypeScriptWalker.g3:659:7: (x= ANY |x= CONSTRUCTOR |x= DECLARE |x= GET |x= SET |x= MODULE |x= REQUIRE |x= NUMBER |x= STRING |x= TYPE |x= FINAL |x= THROWS |x= Identifier )
			int alt116=13;
			try { DebugEnterSubRule(116);
			try { DebugEnterDecision(116, false);
			switch (input.LA(1))
			{
			case ANY:
				{
				alt116 = 1;
				}
				break;
			case CONSTRUCTOR:
				{
				alt116 = 2;
				}
				break;
			case DECLARE:
				{
				alt116 = 3;
				}
				break;
			case GET:
				{
				alt116 = 4;
				}
				break;
			case SET:
				{
				alt116 = 5;
				}
				break;
			case MODULE:
				{
				alt116 = 6;
				}
				break;
			case REQUIRE:
				{
				alt116 = 7;
				}
				break;
			case NUMBER:
				{
				alt116 = 8;
				}
				break;
			case STRING:
				{
				alt116 = 9;
				}
				break;
			case TYPE:
				{
				alt116 = 10;
				}
				break;
			case FINAL:
				{
				alt116 = 11;
				}
				break;
			case THROWS:
				{
				alt116 = 12;
				}
				break;
			case Identifier:
				{
				alt116 = 13;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 116, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(116); }
			switch (alt116)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:659:8: x= ANY
				{
				DebugLocation(659, 9);
				x=(CommonTree)Match(input,ANY,Follow._ANY_in_identifier5376); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TypeScriptWalker.g3:660:7: x= CONSTRUCTOR
				{
				DebugLocation(660, 8);
				x=(CommonTree)Match(input,CONSTRUCTOR,Follow._CONSTRUCTOR_in_identifier5387); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TypeScriptWalker.g3:661:7: x= DECLARE
				{
				DebugLocation(661, 8);
				x=(CommonTree)Match(input,DECLARE,Follow._DECLARE_in_identifier5398); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TypeScriptWalker.g3:662:7: x= GET
				{
				DebugLocation(662, 8);
				x=(CommonTree)Match(input,GET,Follow._GET_in_identifier5409); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TypeScriptWalker.g3:663:7: x= SET
				{
				DebugLocation(663, 8);
				x=(CommonTree)Match(input,SET,Follow._SET_in_identifier5420); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TypeScriptWalker.g3:664:7: x= MODULE
				{
				DebugLocation(664, 8);
				x=(CommonTree)Match(input,MODULE,Follow._MODULE_in_identifier5431); 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// TypeScriptWalker.g3:665:7: x= REQUIRE
				{
				DebugLocation(665, 8);
				x=(CommonTree)Match(input,REQUIRE,Follow._REQUIRE_in_identifier5442); 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// TypeScriptWalker.g3:666:7: x= NUMBER
				{
				DebugLocation(666, 8);
				x=(CommonTree)Match(input,NUMBER,Follow._NUMBER_in_identifier5453); 

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// TypeScriptWalker.g3:667:7: x= STRING
				{
				DebugLocation(667, 8);
				x=(CommonTree)Match(input,STRING,Follow._STRING_in_identifier5464); 

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// TypeScriptWalker.g3:668:7: x= TYPE
				{
				DebugLocation(668, 8);
				x=(CommonTree)Match(input,TYPE,Follow._TYPE_in_identifier5475); 

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// TypeScriptWalker.g3:669:7: x= FINAL
				{
				DebugLocation(669, 8);
				x=(CommonTree)Match(input,FINAL,Follow._FINAL_in_identifier5486); 

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// TypeScriptWalker.g3:670:7: x= THROWS
				{
				DebugLocation(670, 8);
				x=(CommonTree)Match(input,THROWS,Follow._THROWS_in_identifier5497); 

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// TypeScriptWalker.g3:671:7: x= Identifier
				{
				DebugLocation(671, 8);
				x=(CommonTree)Match(input,Identifier,Follow._Identifier_in_identifier5508); 

				}
				break;

			}
			} finally { DebugExitSubRule(116); }

			DebugLocation(672, 5);
			 result = x.Text; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("identifier", 81);
			LeaveRule("identifier", 81);
			LeaveRule_identifier();
		}
		DebugLocation(673, 4);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return result;

	}
	// $ANTLR end "identifier"

	partial void EnterRule_importDeclaration();
	partial void LeaveRule_importDeclaration();
	// $ANTLR start "importDeclaration"
	// TypeScriptWalker.g3:675:1: importDeclaration returns [TsSourceElement result] : ^( IMPORT a= identifier m= StringLiteral ) ;
	[GrammarRule("importDeclaration")]
	private TsSourceElement importDeclaration()
	{
		EnterRule_importDeclaration();
		EnterRule("importDeclaration", 82);
		TraceIn("importDeclaration", 82);
		TsSourceElement result = default(TsSourceElement);


		CommonTree m = default(CommonTree);
		string a = default(string);

		try { DebugEnterRule(GrammarFileName, "importDeclaration");
		DebugLocation(675, 4);
		try
		{
			// TypeScriptWalker.g3:676:5: ( ^( IMPORT a= identifier m= StringLiteral ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:676:7: ^( IMPORT a= identifier m= StringLiteral )
			{
			DebugLocation(676, 7);
			DebugLocation(676, 9);
			Match(input,IMPORT,Follow._IMPORT_in_importDeclaration5537); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(676, 18);
			PushFollow(Follow._identifier_in_importDeclaration5543);
			a=identifier();
			PopFollow();

			DebugLocation(676, 33);
			m=(CommonTree)Match(input,StringLiteral,Follow._StringLiteral_in_importDeclaration5549); 

			Match(input, TokenTypes.Up, null); 

			DebugLocation(677, 5);
			 result = new TsImportDeclaration(a,m.Text.Substring(1, m.Text.Length - 2)); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("importDeclaration", 82);
			LeaveRule("importDeclaration", 82);
			LeaveRule_importDeclaration();
		}
		DebugLocation(678, 4);
		} finally { DebugExitRule(GrammarFileName, "importDeclaration"); }
		return result;

	}
	// $ANTLR end "importDeclaration"

	partial void EnterRule_memberVariableDeclaration();
	partial void LeaveRule_memberVariableDeclaration();
	// $ANTLR start "memberVariableDeclaration"
	// TypeScriptWalker.g3:680:1: memberVariableDeclaration returns [TsClassMember result] : ^( VAR (a= accessibilityModifier )? ( STATIC )? i= identifier (ann= typeAnnotation )? ( ASSIGN e= expression )? ) ;
	[GrammarRule("memberVariableDeclaration")]
	private TsClassMember memberVariableDeclaration()
	{
		EnterRule_memberVariableDeclaration();
		EnterRule("memberVariableDeclaration", 83);
		TraceIn("memberVariableDeclaration", 83);
		TsClassMember result = default(TsClassMember);


		AccessibilityModifier a = default(AccessibilityModifier);
		string i = default(string);
		TsType ann = default(TsType);
		JsExpression e = default(JsExpression);

		 AccessibilityModifier? accessibility = null; bool s = false; 
		try { DebugEnterRule(GrammarFileName, "memberVariableDeclaration");
		DebugLocation(680, 4);
		try
		{
			// TypeScriptWalker.g3:682:5: ( ^( VAR (a= accessibilityModifier )? ( STATIC )? i= identifier (ann= typeAnnotation )? ( ASSIGN e= expression )? ) )
			DebugEnterAlt(1);
			// TypeScriptWalker.g3:682:7: ^( VAR (a= accessibilityModifier )? ( STATIC )? i= identifier (ann= typeAnnotation )? ( ASSIGN e= expression )? )
			{
			DebugLocation(682, 7);
			DebugLocation(682, 10);
			Match(input,VAR,Follow._VAR_in_memberVariableDeclaration5588); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(682, 14);
			// TypeScriptWalker.g3:682:14: (a= accessibilityModifier )?
			int alt117=2;
			try { DebugEnterSubRule(117);
			try { DebugEnterDecision(117, false);
			int LA117_1 = input.LA(1);

			if ((LA117_1==PRIVATE||LA117_1==PROTECTED||LA117_1==PUBLIC))
			{
				alt117 = 1;
			}
			} finally { DebugExitDecision(117); }
			switch (alt117)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:682:15: a= accessibilityModifier
				{
				DebugLocation(682, 16);
				PushFollow(Follow._accessibilityModifier_in_memberVariableDeclaration5593);
				a=accessibilityModifier();
				PopFollow();

				DebugLocation(682, 39);
				accessibility = a;

				}
				break;

			}
			} finally { DebugExitSubRule(117); }

			DebugLocation(682, 62);
			// TypeScriptWalker.g3:682:62: ( STATIC )?
			int alt118=2;
			try { DebugEnterSubRule(118);
			try { DebugEnterDecision(118, false);
			int LA118_1 = input.LA(1);

			if ((LA118_1==STATIC))
			{
				alt118 = 1;
			}
			} finally { DebugExitDecision(118); }
			switch (alt118)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:682:63: STATIC
				{
				DebugLocation(682, 63);
				Match(input,STATIC,Follow._STATIC_in_memberVariableDeclaration5600); 
				DebugLocation(682, 70);
				 s=true;

				}
				break;

			}
			} finally { DebugExitSubRule(118); }

			DebugLocation(682, 84);
			PushFollow(Follow._identifier_in_memberVariableDeclaration5608);
			i=identifier();
			PopFollow();

			DebugLocation(682, 99);
			// TypeScriptWalker.g3:682:99: (ann= typeAnnotation )?
			int alt119=2;
			try { DebugEnterSubRule(119);
			try { DebugEnterDecision(119, false);
			int LA119_1 = input.LA(1);

			if ((LA119_1==COLON))
			{
				alt119 = 1;
			}
			} finally { DebugExitDecision(119); }
			switch (alt119)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:682:99: ann= typeAnnotation
				{
				DebugLocation(682, 99);
				PushFollow(Follow._typeAnnotation_in_memberVariableDeclaration5612);
				ann=typeAnnotation();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(119); }

			DebugLocation(682, 116);
			// TypeScriptWalker.g3:682:116: ( ASSIGN e= expression )?
			int alt120=2;
			try { DebugEnterSubRule(120);
			try { DebugEnterDecision(120, false);
			int LA120_1 = input.LA(1);

			if ((LA120_1==ASSIGN))
			{
				alt120 = 1;
			}
			} finally { DebugExitDecision(120); }
			switch (alt120)
			{
			case 1:
				DebugEnterAlt(1);
				// TypeScriptWalker.g3:682:117: ASSIGN e= expression
				{
				DebugLocation(682, 117);
				Match(input,ASSIGN,Follow._ASSIGN_in_memberVariableDeclaration5616); 
				DebugLocation(682, 125);
				PushFollow(Follow._expression_in_memberVariableDeclaration5620);
				e=expression();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(120); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(683, 5);
			 result = new TsClassMemberDeclaration(accessibility,s,new JsVariableDeclaration(i, e, ann)); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("memberVariableDeclaration", 83);
			LeaveRule("memberVariableDeclaration", 83);
			LeaveRule_memberVariableDeclaration();
		}
		DebugLocation(684, 4);
		} finally { DebugExitRule(GrammarFileName, "memberVariableDeclaration"); }
		return result;

	}
	// $ANTLR end "memberVariableDeclaration"
	#endregion Rules


	#region DFA
	private DFA1 dfa1;
	private DFA2 dfa2;
	private DFA3 dfa3;
	private DFA4 dfa4;
	private DFA8 dfa8;
	private DFA12 dfa12;
	private DFA15 dfa15;
	private DFA18 dfa18;
	private DFA19 dfa19;
	private DFA22 dfa22;
	private DFA24 dfa24;
	private DFA23 dfa23;
	private DFA25 dfa25;
	private DFA35 dfa35;
	private DFA36 dfa36;
	private DFA43 dfa43;
	private DFA64 dfa64;
	private DFA65 dfa65;
	private DFA66 dfa66;
	private DFA67 dfa67;
	private DFA114 dfa114;
	private DFA115 dfa115;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa1 = new DFA1( this );
		dfa2 = new DFA2( this );
		dfa3 = new DFA3( this );
		dfa4 = new DFA4( this );
		dfa8 = new DFA8( this );
		dfa12 = new DFA12( this );
		dfa15 = new DFA15( this );
		dfa18 = new DFA18( this );
		dfa19 = new DFA19( this );
		dfa22 = new DFA22( this );
		dfa24 = new DFA24( this );
		dfa23 = new DFA23( this );
		dfa25 = new DFA25( this );
		dfa35 = new DFA35( this );
		dfa36 = new DFA36( this );
		dfa43 = new DFA43( this );
		dfa64 = new DFA64( this );
		dfa65 = new DFA65( this );
		dfa66 = new DFA66( this );
		dfa67 = new DFA67( this );
		dfa114 = new DFA114( this );
		dfa115 = new DFA115( this );
	}

	private class DFA1 : DFA
	{
		private const string DFA1_eotS =
			"\x67\xFFFF";
		private const string DFA1_eofS =
			"\x1\x1\x66\xFFFF";
		private const string DFA1_minS =
			"\x1\x5\x66\xFFFF";
		private const string DFA1_maxS =
			"\x1\xCE\x66\xFFFF";
		private const string DFA1_acceptS =
			"\x1\xFFFF\x1\x2\x1\x1\x64\xFFFF";
		private const string DFA1_specialS =
			"\x67\xFFFF}>";
		private static readonly string[] DFA1_transitionS =
			{
				"\x6\x2\x1\xFFFF\x1\x2\x2\xFFFF\x3\x2\x1\xFFFF\x1\x2\x1\xFFFF\x2\x2\x2"+
				"\xFFFF\x1\x2\x3\xFFFF\x1\x2\x1\xFFFF\x1\x2\x3\xFFFF\x1\x2\x3\xFFFF\x1"+
				"\x2\x2\xFFFF\x2\x2\x1\xFFFF\x4\x2\x5\xFFFF\x1\x2\x4\xFFFF\x2\x2\x4\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x2\x2\x2\xFFFF\x4\x2\x2"+
				"\xFFFF\x2\x2\x1\xFFFF\x3\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2\x2\x1\xFFFF\x1"+
				"\x2\x3\xFFFF\x2\x2\x4\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF\x5\x2\x4\xFFFF"+
				"\x2\x2\x1\xFFFF\x5\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x4\x2\x5"+
				"\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF\x6\x2\x1\xFFFF\x4\x2\x3\xFFFF\x3"+
				"\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x3\x2\x1\xFFFF\x2\x2\x1\xFFFF"+
				"\x2\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x2\x2\x1\xFFFF\x3\x2",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA1_eot = DFA.UnpackEncodedString(DFA1_eotS);
		private static readonly short[] DFA1_eof = DFA.UnpackEncodedString(DFA1_eofS);
		private static readonly char[] DFA1_min = DFA.UnpackEncodedStringToUnsignedChars(DFA1_minS);
		private static readonly char[] DFA1_max = DFA.UnpackEncodedStringToUnsignedChars(DFA1_maxS);
		private static readonly short[] DFA1_accept = DFA.UnpackEncodedString(DFA1_acceptS);
		private static readonly short[] DFA1_special = DFA.UnpackEncodedString(DFA1_specialS);
		private static readonly short[][] DFA1_transition;

		static DFA1()
		{
			int numStates = DFA1_transitionS.Length;
			DFA1_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA1_transition[i] = DFA.UnpackEncodedString(DFA1_transitionS[i]);
			}
		}

		public DFA1( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 1;
			this.eot = DFA1_eot;
			this.eof = DFA1_eof;
			this.min = DFA1_min;
			this.max = DFA1_max;
			this.accept = DFA1_accept;
			this.special = DFA1_special;
			this.transition = DFA1_transition;
		}

		public override string Description { get { return "()* loopback of 117:4: (s= sourceElement )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA2 : DFA
	{
		private const string DFA2_eotS =
			"\x144\xFFFF";
		private const string DFA2_eofS =
			"\x5\xFFFF\x1\x1\x2\xFFFF\x1\x1\x13B\xFFFF";
		private const string DFA2_minS =
			"\x1\x5\x4\xFFFF\x1\x2\x2\xFFFF\x1\x2\xC5\xFFFF\x1\xA\x75\xFFFF";
		private const string DFA2_maxS =
			"\x1\xCE\x4\xFFFF\x1\xCE\x2\xFFFF\x1\xCE\xC5\xFFFF\x1\xBD\x75\xFFFF";
		private const string DFA2_acceptS =
			"\x1\xFFFF\x1\x1\x5F\xFFFF\x1\x2\x1\x3\x1\x6\x1\x8\x1\x9\x1\x7\xCF\xFFFF"+
			"\x1\x4\x1\x5\xC\xFFFF";
		private const string DFA2_specialS =
			"\x144\xFFFF}>";
		private static readonly string[] DFA2_transitionS =
			{
				"\x2\x1\x1\x64\x3\x1\x1\xFFFF\x1\x1\x2\xFFFF\x3\x1\x1\xFFFF\x1\x1\x1"+
				"\xFFFF\x2\x1\x2\xFFFF\x1\x1\x3\xFFFF\x1\x1\x1\xFFFF\x1\x62\x3\xFFFF"+
				"\x1\x1\x3\xFFFF\x1\x1\x2\xFFFF\x1\x1\x1\x5\x1\xFFFF\x4\x1\x5\xFFFF\x1"+
				"\x1\x4\xFFFF\x1\x1\x1\x63\x4\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1"+
				"\x1\x2\xFFFF\x2\x1\x2\xFFFF\x4\x1\x2\xFFFF\x2\x1\x1\xFFFF\x1\x65\x2"+
				"\x1\x2\xFFFF\x1\x1\x1\xFFFF\x1\x61\x1\x1\x1\xFFFF\x1\x1\x3\xFFFF\x2"+
				"\x1\x4\xFFFF\x1\x1\x2\xFFFF\x2\x1\x3\xFFFF\x2\x1\x1\x8\x2\x1\x4\xFFFF"+
				"\x2\x1\x1\xFFFF\x5\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1\x1\x5\xFFFF\x4\x1\x5"+
				"\xFFFF\x1\x1\x2\xFFFF\x2\x1\x3\xFFFF\x6\x1\x1\xFFFF\x4\x1\x3\xFFFF\x3"+
				"\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1\x1\xFFFF\x3\x1\x1\xFFFF\x2\x1\x1\xFFFF"+
				"\x2\x1\x5\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF\x2\x1\x1\xFFFF\x3\x1",
				"",
				"",
				"",
				"",
				"\x1\x66\x1\x1\x1\xFFFF\x6\x1\x1\xFFFF\x1\x1\x2\xFFFF\x3\x1\x1\xFFFF"+
				"\x1\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1\x1\x3\xFFFF\x1\x1\x1\xFFFF\x1\x1\x3"+
				"\xFFFF\x1\x1\x3\xFFFF\x1\x1\x2\xFFFF\x2\x1\x1\xFFFF\x4\x1\x5\xFFFF\x1"+
				"\x1\x4\xFFFF\x2\x1\x4\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1\x2\xFFFF"+
				"\x2\x1\x2\xFFFF\x4\x1\x2\xFFFF\x2\x1\x1\xFFFF\x3\x1\x2\xFFFF\x1\x1\x1"+
				"\xFFFF\x2\x1\x1\xFFFF\x1\x1\x3\xFFFF\x2\x1\x4\xFFFF\x1\x1\x2\xFFFF\x2"+
				"\x1\x3\xFFFF\x5\x1\x4\xFFFF\x2\x1\x1\xFFFF\x5\x1\x1\xFFFF\x2\x1\x2\xFFFF"+
				"\x1\x1\x5\xFFFF\x4\x1\x5\xFFFF\x1\x1\x2\xFFFF\x2\x1\x3\xFFFF\x6\x1\x1"+
				"\xFFFF\x4\x1\x3\xFFFF\x3\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1\x1\xFFFF\x3"+
				"\x1\x1\xFFFF\x2\x1\x1\xFFFF\x2\x1\x5\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF"+
				"\x2\x1\x1\xFFFF\x3\x1",
				"",
				"",
				"\x1\xCE\x1\x1\x1\xFFFF\x6\x1\x1\xFFFF\x1\x1\x2\xFFFF\x3\x1\x1\xFFFF"+
				"\x1\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1\x1\x3\xFFFF\x1\x1\x1\xFFFF\x1\x1\x3"+
				"\xFFFF\x1\x1\x3\xFFFF\x1\x1\x2\xFFFF\x2\x1\x1\xFFFF\x4\x1\x5\xFFFF\x1"+
				"\x1\x4\xFFFF\x2\x1\x4\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1\x2\xFFFF"+
				"\x2\x1\x2\xFFFF\x4\x1\x2\xFFFF\x2\x1\x1\xFFFF\x3\x1\x2\xFFFF\x1\x1\x1"+
				"\xFFFF\x2\x1\x1\xFFFF\x1\x1\x3\xFFFF\x2\x1\x4\xFFFF\x1\x1\x2\xFFFF\x2"+
				"\x1\x3\xFFFF\x5\x1\x4\xFFFF\x2\x1\x1\xFFFF\x5\x1\x1\xFFFF\x2\x1\x2\xFFFF"+
				"\x1\x1\x5\xFFFF\x4\x1\x5\xFFFF\x1\x1\x2\xFFFF\x2\x1\x3\xFFFF\x6\x1\x1"+
				"\xFFFF\x4\x1\x3\xFFFF\x3\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1\x1\xFFFF\x3"+
				"\x1\x1\xFFFF\x2\x1\x1\xFFFF\x2\x1\x5\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF"+
				"\x2\x1\x1\xFFFF\x3\x1",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x137\x18\xFFFF\x1\x137\x7\xFFFF\x1\x137\x17\xFFFF\x1\x137\x9\xFFFF"+
				"\x1\x137\x12\xFFFF\x1\x137\x13\xFFFF\x1\x137\xC\xFFFF\x1\x137\x18\xFFFF"+
				"\x1\x137\x7\xFFFF\x1\x137\xA\xFFFF\x1\x137\x6\xFFFF\x1\x136\x3\xFFFF"+
				"\x1\x137\x4\xFFFF\x1\x137",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA2_eot = DFA.UnpackEncodedString(DFA2_eotS);
		private static readonly short[] DFA2_eof = DFA.UnpackEncodedString(DFA2_eofS);
		private static readonly char[] DFA2_min = DFA.UnpackEncodedStringToUnsignedChars(DFA2_minS);
		private static readonly char[] DFA2_max = DFA.UnpackEncodedStringToUnsignedChars(DFA2_maxS);
		private static readonly short[] DFA2_accept = DFA.UnpackEncodedString(DFA2_acceptS);
		private static readonly short[] DFA2_special = DFA.UnpackEncodedString(DFA2_specialS);
		private static readonly short[][] DFA2_transition;

		static DFA2()
		{
			int numStates = DFA2_transitionS.Length;
			DFA2_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA2_transition[i] = DFA.UnpackEncodedString(DFA2_transitionS[i]);
			}
		}

		public DFA2( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 2;
			this.eot = DFA2_eot;
			this.eof = DFA2_eof;
			this.min = DFA2_min;
			this.max = DFA2_max;
			this.accept = DFA2_accept;
			this.special = DFA2_special;
			this.transition = DFA2_transition;
		}

		public override string Description { get { return "121:7: ( (e= statementElement ) | (e= interfaceElement ) | (e= classElement ) | (e= moduleElement ) | (e= namespaceElement ) | (e= exportDeclaration ) | (e= ambientDeclaration ) | (e= ambientFunctionDeclaration ) | (e= importDeclaration ) )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA3 : DFA
	{
		private const string DFA3_eotS =
			"\x61\xFFFF";
		private const string DFA3_eofS =
			"\x61\xFFFF";
		private const string DFA3_minS =
			"\x1\x5\x60\xFFFF";
		private const string DFA3_maxS =
			"\x1\xCE\x60\xFFFF";
		private const string DFA3_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x4C\xFFFF\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1"+
			"\x9\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12\x1\x13\x1"+
			"\x14";
		private const string DFA3_specialS =
			"\x61\xFFFF}>";
		private static readonly string[] DFA3_transitionS =
			{
				"\x2\x3\x1\xFFFF\x3\x3\x1\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\x5F\x1\x1\x1"+
				"\xFFFF\x1\x55\x1\xFFFF\x2\x3\x2\xFFFF\x1\x3\x3\xFFFF\x1\x3\x5\xFFFF"+
				"\x1\x3\x3\xFFFF\x1\x54\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x1\x51\x5\xFFFF"+
				"\x1\x3\x4\xFFFF\x1\x3\x5\xFFFF\x1\x3\x1\xFFFF\x1\x3\x2\xFFFF\x1\x53"+
				"\x2\xFFFF\x1\x3\x1\x5C\x2\xFFFF\x1\x3\x1\x5D\x2\x3\x2\xFFFF\x1\x3\x1"+
				"\x50\x2\xFFFF\x2\x3\x2\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\xFFFF\x1\x3\x3"+
				"\xFFFF\x1\x58\x1\x3\x4\xFFFF\x1\x3\x2\xFFFF\x2\x3\x3\xFFFF\x5\x3\x4"+
				"\xFFFF\x2\x3\x1\xFFFF\x5\x3\x1\xFFFF\x2\x3\x2\xFFFF\x1\x3\x5\xFFFF\x4"+
				"\x3\x5\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\x56\x3\xFFFF\x2\x3\x1\x60\x3\x3"+
				"\x1\xFFFF\x4\x3\x3\xFFFF\x3\x3\x1\xFFFF\x1\x59\x2\xFFFF\x1\x3\x1\xFFFF"+
				"\x1\x3\x1\x5A\x1\x3\x1\xFFFF\x1\x3\x1\x5B\x1\xFFFF\x2\x3\x5\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x3\x2\xFFFF\x1\x52\x1\x57\x1\xFFFF\x2\x3\x1\x5E",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA3_eot = DFA.UnpackEncodedString(DFA3_eotS);
		private static readonly short[] DFA3_eof = DFA.UnpackEncodedString(DFA3_eofS);
		private static readonly char[] DFA3_min = DFA.UnpackEncodedStringToUnsignedChars(DFA3_minS);
		private static readonly char[] DFA3_max = DFA.UnpackEncodedStringToUnsignedChars(DFA3_maxS);
		private static readonly short[] DFA3_accept = DFA.UnpackEncodedString(DFA3_acceptS);
		private static readonly short[] DFA3_special = DFA.UnpackEncodedString(DFA3_specialS);
		private static readonly short[][] DFA3_transition;

		static DFA3()
		{
			int numStates = DFA3_transitionS.Length;
			DFA3_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA3_transition[i] = DFA.UnpackEncodedString(DFA3_transitionS[i]);
			}
		}

		public DFA3( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 3;
			this.eot = DFA3_eot;
			this.eof = DFA3_eof;
			this.min = DFA3_min;
			this.max = DFA3_max;
			this.accept = DFA3_accept;
			this.special = DFA3_special;
			this.transition = DFA3_transition;
		}

		public override string Description { get { return "139:4: (x= block |x= variableDeclaration |e= expression |x= ifStatement |x= doStatement |x= whileStatement |x= forStatement |x= continueStatement |x= breakStatement |x= returnStatement |x= withStatement |x= labelledStatement |x= switchStatement |x= throwStatement |x= tryStatement |x= functionDeclaration |x= gotoStatement |x= yieldStatement |x= awaitStatement | SEMIC )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA4 : DFA
	{
		private const string DFA4_eotS =
			"\x62\xFFFF";
		private const string DFA4_eofS =
			"\x62\xFFFF";
		private const string DFA4_minS =
			"\x1\x3\x61\xFFFF";
		private const string DFA4_maxS =
			"\x1\xCE\x61\xFFFF";
		private const string DFA4_acceptS =
			"\x1\xFFFF\x1\x2\x1\x1\x5F\xFFFF";
		private const string DFA4_specialS =
			"\x62\xFFFF}>";
		private static readonly string[] DFA4_transitionS =
			{
				"\x1\x1\x1\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x1\x2\x2\xFFFF\x3\x2\x1"+
				"\xFFFF\x1\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x3\xFFFF\x1\x2\x5\xFFFF\x1"+
				"\x2\x3\xFFFF\x1\x2\x2\xFFFF\x2\x2\x1\xFFFF\x4\x2\x5\xFFFF\x1\x2\x4\xFFFF"+
				"\x1\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x2\x2\x2"+
				"\xFFFF\x4\x2\x2\xFFFF\x2\x2\x2\xFFFF\x2\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x3\xFFFF\x2\x2\x4\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF"+
				"\x5\x2\x4\xFFFF\x2\x2\x1\xFFFF\x5\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x5"+
				"\xFFFF\x4\x2\x5\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF\x6\x2\x1\xFFFF\x4"+
				"\x2\x3\xFFFF\x3\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x3\x2\x1\xFFFF"+
				"\x2\x2\x1\xFFFF\x2\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x2\x2\x1"+
				"\xFFFF\x3\x2",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA4_eot = DFA.UnpackEncodedString(DFA4_eotS);
		private static readonly short[] DFA4_eof = DFA.UnpackEncodedString(DFA4_eofS);
		private static readonly char[] DFA4_min = DFA.UnpackEncodedStringToUnsignedChars(DFA4_minS);
		private static readonly char[] DFA4_max = DFA.UnpackEncodedStringToUnsignedChars(DFA4_maxS);
		private static readonly short[] DFA4_accept = DFA.UnpackEncodedString(DFA4_acceptS);
		private static readonly short[] DFA4_special = DFA.UnpackEncodedString(DFA4_specialS);
		private static readonly short[][] DFA4_transition;

		static DFA4()
		{
			int numStates = DFA4_transitionS.Length;
			DFA4_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA4_transition[i] = DFA.UnpackEncodedString(DFA4_transitionS[i]);
			}
		}

		public DFA4( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 4;
			this.eot = DFA4_eot;
			this.eof = DFA4_eof;
			this.min = DFA4_min;
			this.max = DFA4_max;
			this.accept = DFA4_accept;
			this.special = DFA4_special;
			this.transition = DFA4_transition;
		}

		public override string Description { get { return "()* loopback of 164:13: (s= statement )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA8 : DFA
	{
		private const string DFA8_eotS =
			"\x62\xFFFF";
		private const string DFA8_eofS =
			"\x62\xFFFF";
		private const string DFA8_minS =
			"\x1\x3\x61\xFFFF";
		private const string DFA8_maxS =
			"\x1\xCE\x61\xFFFF";
		private const string DFA8_acceptS =
			"\x1\xFFFF\x1\x1\x5F\xFFFF\x1\x2";
		private const string DFA8_specialS =
			"\x62\xFFFF}>";
		private static readonly string[] DFA8_transitionS =
			{
				"\x1\x61\x1\xFFFF\x2\x1\x1\xFFFF\x3\x1\x1\xFFFF\x1\x1\x2\xFFFF\x3\x1"+
				"\x1\xFFFF\x1\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1\x1\x3\xFFFF\x1\x1\x5\xFFFF"+
				"\x1\x1\x3\xFFFF\x1\x1\x2\xFFFF\x2\x1\x1\xFFFF\x4\x1\x5\xFFFF\x1\x1\x4"+
				"\xFFFF\x1\x1\x5\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1\x2\xFFFF\x2"+
				"\x1\x2\xFFFF\x4\x1\x2\xFFFF\x2\x1\x2\xFFFF\x2\x1\x2\xFFFF\x1\x1\x2\xFFFF"+
				"\x1\x1\x1\xFFFF\x1\x1\x3\xFFFF\x2\x1\x4\xFFFF\x1\x1\x2\xFFFF\x2\x1\x3"+
				"\xFFFF\x5\x1\x4\xFFFF\x2\x1\x1\xFFFF\x5\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1"+
				"\x1\x5\xFFFF\x4\x1\x5\xFFFF\x1\x1\x2\xFFFF\x2\x1\x3\xFFFF\x6\x1\x1\xFFFF"+
				"\x4\x1\x3\xFFFF\x3\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1\x1\xFFFF\x3\x1\x1"+
				"\xFFFF\x2\x1\x1\xFFFF\x2\x1\x5\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF\x2"+
				"\x1\x1\xFFFF\x3\x1",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA8_eot = DFA.UnpackEncodedString(DFA8_eotS);
		private static readonly short[] DFA8_eof = DFA.UnpackEncodedString(DFA8_eofS);
		private static readonly char[] DFA8_min = DFA.UnpackEncodedStringToUnsignedChars(DFA8_minS);
		private static readonly char[] DFA8_max = DFA.UnpackEncodedStringToUnsignedChars(DFA8_maxS);
		private static readonly short[] DFA8_accept = DFA.UnpackEncodedString(DFA8_acceptS);
		private static readonly short[] DFA8_special = DFA.UnpackEncodedString(DFA8_specialS);
		private static readonly short[][] DFA8_transition;

		static DFA8()
		{
			int numStates = DFA8_transitionS.Length;
			DFA8_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA8_transition[i] = DFA.UnpackEncodedString(DFA8_transitionS[i]);
			}
		}

		public DFA8( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 8;
			this.eot = DFA8_eot;
			this.eof = DFA8_eof;
			this.min = DFA8_min;
			this.max = DFA8_max;
			this.accept = DFA8_accept;
			this.special = DFA8_special;
			this.transition = DFA8_transition;
		}

		public override string Description { get { return "175:36: (b= statement )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA12 : DFA
	{
		private const string DFA12_eotS =
			"\x4F\xFFFF";
		private const string DFA12_eofS =
			"\x4F\xFFFF";
		private const string DFA12_minS =
			"\x1\x3\x4E\xFFFF";
		private const string DFA12_maxS =
			"\x1\xCD\x4E\xFFFF";
		private const string DFA12_acceptS =
			"\x1\xFFFF\x1\x1\x4C\xFFFF\x1\x2";
		private const string DFA12_specialS =
			"\x4F\xFFFF}>";
		private static readonly string[] DFA12_transitionS =
			{
				"\x1\x4E\x1\xFFFF\x2\x1\x1\xFFFF\x3\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1"+
				"\x5\xFFFF\x2\x1\x2\xFFFF\x1\x1\x3\xFFFF\x1\x1\x5\xFFFF\x1\x1\x6\xFFFF"+
				"\x2\x1\x1\xFFFF\x3\x1\x6\xFFFF\x1\x1\x4\xFFFF\x1\x1\x5\xFFFF\x1\x1\x1"+
				"\xFFFF\x1\x1\x5\xFFFF\x1\x1\x3\xFFFF\x1\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1"+
				"\x1\x3\xFFFF\x2\x1\x2\xFFFF\x1\x1\x2\xFFFF\x1\x1\x1\xFFFF\x1\x1\x4\xFFFF"+
				"\x1\x1\x4\xFFFF\x1\x1\x2\xFFFF\x2\x1\x3\xFFFF\x5\x1\x4\xFFFF\x2\x1\x1"+
				"\xFFFF\x5\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1\x1\x5\xFFFF\x4\x1\x5\xFFFF\x1"+
				"\x1\x2\xFFFF\x1\x1\x4\xFFFF\x2\x1\x1\xFFFF\x3\x1\x1\xFFFF\x4\x1\x3\xFFFF"+
				"\x3\x1\x4\xFFFF\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2"+
				"\xFFFF\x2\x1\x7\xFFFF\x1\x1\x5\xFFFF\x2\x1",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA12_eot = DFA.UnpackEncodedString(DFA12_eotS);
		private static readonly short[] DFA12_eof = DFA.UnpackEncodedString(DFA12_eofS);
		private static readonly char[] DFA12_min = DFA.UnpackEncodedStringToUnsignedChars(DFA12_minS);
		private static readonly char[] DFA12_max = DFA.UnpackEncodedStringToUnsignedChars(DFA12_maxS);
		private static readonly short[] DFA12_accept = DFA.UnpackEncodedString(DFA12_acceptS);
		private static readonly short[] DFA12_special = DFA.UnpackEncodedString(DFA12_specialS);
		private static readonly short[][] DFA12_transition;

		static DFA12()
		{
			int numStates = DFA12_transitionS.Length;
			DFA12_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA12_transition[i] = DFA.UnpackEncodedString(DFA12_transitionS[i]);
			}
		}

		public DFA12( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 12;
			this.eot = DFA12_eot;
			this.eof = DFA12_eof;
			this.min = DFA12_min;
			this.max = DFA12_max;
			this.accept = DFA12_accept;
			this.special = DFA12_special;
			this.transition = DFA12_transition;
		}

		public override string Description { get { return "196:13: (x= expression )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA15 : DFA
	{
		private const string DFA15_eotS =
			"\x4F\xFFFF";
		private const string DFA15_eofS =
			"\x4F\xFFFF";
		private const string DFA15_minS =
			"\x1\x3\x4E\xFFFF";
		private const string DFA15_maxS =
			"\x1\xCD\x4E\xFFFF";
		private const string DFA15_acceptS =
			"\x1\xFFFF\x1\x1\x4C\xFFFF\x1\x2";
		private const string DFA15_specialS =
			"\x4F\xFFFF}>";
		private static readonly string[] DFA15_transitionS =
			{
				"\x1\x4E\x1\xFFFF\x2\x1\x1\xFFFF\x3\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1"+
				"\x5\xFFFF\x2\x1\x2\xFFFF\x1\x1\x3\xFFFF\x1\x1\x5\xFFFF\x1\x1\x6\xFFFF"+
				"\x2\x1\x1\xFFFF\x3\x1\x6\xFFFF\x1\x1\x4\xFFFF\x1\x1\x5\xFFFF\x1\x1\x1"+
				"\xFFFF\x1\x1\x5\xFFFF\x1\x1\x3\xFFFF\x1\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1"+
				"\x1\x3\xFFFF\x2\x1\x2\xFFFF\x1\x1\x2\xFFFF\x1\x1\x1\xFFFF\x1\x1\x4\xFFFF"+
				"\x1\x1\x4\xFFFF\x1\x1\x2\xFFFF\x2\x1\x3\xFFFF\x5\x1\x4\xFFFF\x2\x1\x1"+
				"\xFFFF\x5\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1\x1\x5\xFFFF\x4\x1\x5\xFFFF\x1"+
				"\x1\x2\xFFFF\x1\x1\x4\xFFFF\x2\x1\x1\xFFFF\x3\x1\x1\xFFFF\x4\x1\x3\xFFFF"+
				"\x3\x1\x4\xFFFF\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2"+
				"\xFFFF\x2\x1\x7\xFFFF\x1\x1\x5\xFFFF\x2\x1",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA15_eot = DFA.UnpackEncodedString(DFA15_eotS);
		private static readonly short[] DFA15_eof = DFA.UnpackEncodedString(DFA15_eofS);
		private static readonly char[] DFA15_min = DFA.UnpackEncodedStringToUnsignedChars(DFA15_minS);
		private static readonly char[] DFA15_max = DFA.UnpackEncodedStringToUnsignedChars(DFA15_maxS);
		private static readonly short[] DFA15_accept = DFA.UnpackEncodedString(DFA15_acceptS);
		private static readonly short[] DFA15_special = DFA.UnpackEncodedString(DFA15_specialS);
		private static readonly short[][] DFA15_transition;

		static DFA15()
		{
			int numStates = DFA15_transitionS.Length;
			DFA15_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA15_transition[i] = DFA.UnpackEncodedString(DFA15_transitionS[i]);
			}
		}

		public DFA15( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 15;
			this.eot = DFA15_eot;
			this.eof = DFA15_eof;
			this.min = DFA15_min;
			this.max = DFA15_max;
			this.accept = DFA15_accept;
			this.special = DFA15_special;
			this.transition = DFA15_transition;
		}

		public override string Description { get { return "212:15: (x= expression )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA18 : DFA
	{
		private const string DFA18_eotS =
			"\x62\xFFFF";
		private const string DFA18_eofS =
			"\x62\xFFFF";
		private const string DFA18_minS =
			"\x1\x3\x61\xFFFF";
		private const string DFA18_maxS =
			"\x1\xCE\x61\xFFFF";
		private const string DFA18_acceptS =
			"\x1\xFFFF\x1\x2\x1\x1\x5F\xFFFF";
		private const string DFA18_specialS =
			"\x62\xFFFF}>";
		private static readonly string[] DFA18_transitionS =
			{
				"\x1\x1\x1\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x1\x2\x2\xFFFF\x3\x2\x1"+
				"\xFFFF\x1\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x3\xFFFF\x1\x2\x5\xFFFF\x1"+
				"\x2\x3\xFFFF\x1\x2\x2\xFFFF\x2\x2\x1\xFFFF\x4\x2\x5\xFFFF\x1\x2\x4\xFFFF"+
				"\x1\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x2\x2\x2"+
				"\xFFFF\x4\x2\x2\xFFFF\x2\x2\x2\xFFFF\x2\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x3\xFFFF\x2\x2\x4\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF"+
				"\x5\x2\x4\xFFFF\x2\x2\x1\xFFFF\x5\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x5"+
				"\xFFFF\x4\x2\x5\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF\x6\x2\x1\xFFFF\x4"+
				"\x2\x3\xFFFF\x3\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x3\x2\x1\xFFFF"+
				"\x2\x2\x1\xFFFF\x2\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x2\x2\x1"+
				"\xFFFF\x3\x2",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA18_eot = DFA.UnpackEncodedString(DFA18_eotS);
		private static readonly short[] DFA18_eof = DFA.UnpackEncodedString(DFA18_eofS);
		private static readonly char[] DFA18_min = DFA.UnpackEncodedStringToUnsignedChars(DFA18_minS);
		private static readonly char[] DFA18_max = DFA.UnpackEncodedStringToUnsignedChars(DFA18_maxS);
		private static readonly short[] DFA18_accept = DFA.UnpackEncodedString(DFA18_acceptS);
		private static readonly short[] DFA18_special = DFA.UnpackEncodedString(DFA18_specialS);
		private static readonly short[][] DFA18_transition;

		static DFA18()
		{
			int numStates = DFA18_transitionS.Length;
			DFA18_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA18_transition[i] = DFA.UnpackEncodedString(DFA18_transitionS[i]);
			}
		}

		public DFA18( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 18;
			this.eot = DFA18_eot;
			this.eof = DFA18_eof;
			this.min = DFA18_min;
			this.max = DFA18_max;
			this.accept = DFA18_accept;
			this.special = DFA18_special;
			this.transition = DFA18_transition;
		}

		public override string Description { get { return "()* loopback of 234:15: (s= statement )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA19 : DFA
	{
		private const string DFA19_eotS =
			"\x62\xFFFF";
		private const string DFA19_eofS =
			"\x62\xFFFF";
		private const string DFA19_minS =
			"\x1\x3\x61\xFFFF";
		private const string DFA19_maxS =
			"\x1\xCE\x61\xFFFF";
		private const string DFA19_acceptS =
			"\x1\xFFFF\x1\x2\x1\x1\x5F\xFFFF";
		private const string DFA19_specialS =
			"\x62\xFFFF}>";
		private static readonly string[] DFA19_transitionS =
			{
				"\x1\x1\x1\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x1\x2\x2\xFFFF\x3\x2\x1"+
				"\xFFFF\x1\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x3\xFFFF\x1\x2\x5\xFFFF\x1"+
				"\x2\x3\xFFFF\x1\x2\x2\xFFFF\x2\x2\x1\xFFFF\x4\x2\x5\xFFFF\x1\x2\x4\xFFFF"+
				"\x1\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x2\x2\x2"+
				"\xFFFF\x4\x2\x2\xFFFF\x2\x2\x2\xFFFF\x2\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x3\xFFFF\x2\x2\x4\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF"+
				"\x5\x2\x4\xFFFF\x2\x2\x1\xFFFF\x5\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x5"+
				"\xFFFF\x4\x2\x5\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF\x6\x2\x1\xFFFF\x4"+
				"\x2\x3\xFFFF\x3\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x3\x2\x1\xFFFF"+
				"\x2\x2\x1\xFFFF\x2\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x2\x2\x1"+
				"\xFFFF\x3\x2",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA19_eot = DFA.UnpackEncodedString(DFA19_eotS);
		private static readonly short[] DFA19_eof = DFA.UnpackEncodedString(DFA19_eofS);
		private static readonly char[] DFA19_min = DFA.UnpackEncodedStringToUnsignedChars(DFA19_minS);
		private static readonly char[] DFA19_max = DFA.UnpackEncodedStringToUnsignedChars(DFA19_maxS);
		private static readonly short[] DFA19_accept = DFA.UnpackEncodedString(DFA19_acceptS);
		private static readonly short[] DFA19_special = DFA.UnpackEncodedString(DFA19_specialS);
		private static readonly short[][] DFA19_transition;

		static DFA19()
		{
			int numStates = DFA19_transitionS.Length;
			DFA19_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA19_transition[i] = DFA.UnpackEncodedString(DFA19_transitionS[i]);
			}
		}

		public DFA19( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 19;
			this.eot = DFA19_eot;
			this.eof = DFA19_eof;
			this.min = DFA19_min;
			this.max = DFA19_max;
			this.accept = DFA19_accept;
			this.special = DFA19_special;
			this.transition = DFA19_transition;
		}

		public override string Description { get { return "()* loopback of 239:25: (s= statement )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA22 : DFA
	{
		private const string DFA22_eotS =
			"\x4F\xFFFF";
		private const string DFA22_eofS =
			"\x4F\xFFFF";
		private const string DFA22_minS =
			"\x1\x3\x4E\xFFFF";
		private const string DFA22_maxS =
			"\x1\xCD\x4E\xFFFF";
		private const string DFA22_acceptS =
			"\x1\xFFFF\x1\x1\x4C\xFFFF\x1\x2";
		private const string DFA22_specialS =
			"\x4F\xFFFF}>";
		private static readonly string[] DFA22_transitionS =
			{
				"\x1\x4E\x1\xFFFF\x2\x1\x1\xFFFF\x3\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1"+
				"\x5\xFFFF\x2\x1\x2\xFFFF\x1\x1\x3\xFFFF\x1\x1\x5\xFFFF\x1\x1\x6\xFFFF"+
				"\x2\x1\x1\xFFFF\x3\x1\x6\xFFFF\x1\x1\x4\xFFFF\x1\x1\x5\xFFFF\x1\x1\x1"+
				"\xFFFF\x1\x1\x5\xFFFF\x1\x1\x3\xFFFF\x1\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1"+
				"\x1\x3\xFFFF\x2\x1\x2\xFFFF\x1\x1\x2\xFFFF\x1\x1\x1\xFFFF\x1\x1\x4\xFFFF"+
				"\x1\x1\x4\xFFFF\x1\x1\x2\xFFFF\x2\x1\x3\xFFFF\x5\x1\x4\xFFFF\x2\x1\x1"+
				"\xFFFF\x5\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1\x1\x5\xFFFF\x4\x1\x5\xFFFF\x1"+
				"\x1\x2\xFFFF\x1\x1\x4\xFFFF\x2\x1\x1\xFFFF\x3\x1\x1\xFFFF\x4\x1\x3\xFFFF"+
				"\x3\x1\x4\xFFFF\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2"+
				"\xFFFF\x2\x1\x7\xFFFF\x1\x1\x5\xFFFF\x2\x1",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA22_eot = DFA.UnpackEncodedString(DFA22_eotS);
		private static readonly short[] DFA22_eof = DFA.UnpackEncodedString(DFA22_eofS);
		private static readonly char[] DFA22_min = DFA.UnpackEncodedStringToUnsignedChars(DFA22_minS);
		private static readonly char[] DFA22_max = DFA.UnpackEncodedStringToUnsignedChars(DFA22_maxS);
		private static readonly short[] DFA22_accept = DFA.UnpackEncodedString(DFA22_acceptS);
		private static readonly short[] DFA22_special = DFA.UnpackEncodedString(DFA22_specialS);
		private static readonly short[][] DFA22_transition;

		static DFA22()
		{
			int numStates = DFA22_transitionS.Length;
			DFA22_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA22_transition[i] = DFA.UnpackEncodedString(DFA22_transitionS[i]);
			}
		}

		public DFA22( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 22;
			this.eot = DFA22_eot;
			this.eof = DFA22_eof;
			this.min = DFA22_min;
			this.max = DFA22_max;
			this.accept = DFA22_accept;
			this.special = DFA22_special;
			this.transition = DFA22_transition;
		}

		public override string Description { get { return "263:14: (x= expression )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA24 : DFA
	{
		private const string DFA24_eotS =
			"\x4E\xFFFF";
		private const string DFA24_eofS =
			"\x4E\xFFFF";
		private const string DFA24_minS =
			"\x1\x5\x4D\xFFFF";
		private const string DFA24_maxS =
			"\x1\xCD\x4D\xFFFF";
		private const string DFA24_acceptS =
			"\x1\xFFFF\x1\x1\x4B\xFFFF\x1\x2";
		private const string DFA24_specialS =
			"\x4E\xFFFF}>";
		private static readonly string[] DFA24_transitionS =
			{
				"\x2\x1\x1\xFFFF\x3\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1\x5\xFFFF\x2\x1\x2"+
				"\xFFFF\x1\x1\x3\xFFFF\x1\x4D\x5\xFFFF\x1\x1\x6\xFFFF\x2\x1\x1\xFFFF"+
				"\x3\x1\x6\xFFFF\x1\x1\x4\xFFFF\x1\x1\x5\xFFFF\x1\x1\x1\xFFFF\x1\x1\x5"+
				"\xFFFF\x1\x1\x3\xFFFF\x1\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1\x1\x3\xFFFF\x2"+
				"\x1\x2\xFFFF\x1\x1\x2\xFFFF\x1\x1\x1\xFFFF\x1\x1\x4\xFFFF\x1\x1\x4\xFFFF"+
				"\x1\x1\x2\xFFFF\x2\x1\x3\xFFFF\x5\x1\x4\xFFFF\x2\x1\x1\xFFFF\x5\x1\x1"+
				"\xFFFF\x2\x1\x2\xFFFF\x1\x1\x5\xFFFF\x4\x1\x5\xFFFF\x1\x1\x2\xFFFF\x1"+
				"\x1\x4\xFFFF\x2\x1\x1\xFFFF\x3\x1\x1\xFFFF\x4\x1\x3\xFFFF\x3\x1\x4\xFFFF"+
				"\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF\x2\x1\x7"+
				"\xFFFF\x1\x1\x5\xFFFF\x2\x1",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA24_eot = DFA.UnpackEncodedString(DFA24_eotS);
		private static readonly short[] DFA24_eof = DFA.UnpackEncodedString(DFA24_eofS);
		private static readonly char[] DFA24_min = DFA.UnpackEncodedStringToUnsignedChars(DFA24_minS);
		private static readonly char[] DFA24_max = DFA.UnpackEncodedStringToUnsignedChars(DFA24_maxS);
		private static readonly short[] DFA24_accept = DFA.UnpackEncodedString(DFA24_acceptS);
		private static readonly short[] DFA24_special = DFA.UnpackEncodedString(DFA24_specialS);
		private static readonly short[][] DFA24_transition;

		static DFA24()
		{
			int numStates = DFA24_transitionS.Length;
			DFA24_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA24_transition[i] = DFA.UnpackEncodedString(DFA24_transitionS[i]);
			}
		}

		public DFA24( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 24;
			this.eot = DFA24_eot;
			this.eof = DFA24_eof;
			this.min = DFA24_min;
			this.max = DFA24_max;
			this.accept = DFA24_accept;
			this.special = DFA24_special;
			this.transition = DFA24_transition;
		}

		public override string Description { get { return "270:8: public expression returns [JsExpression result] : (x= expr | ^( CEXPR (x= expr )+ ) );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA23 : DFA
	{
		private const string DFA23_eotS =
			"\x4E\xFFFF";
		private const string DFA23_eofS =
			"\x4E\xFFFF";
		private const string DFA23_minS =
			"\x1\x3\x4D\xFFFF";
		private const string DFA23_maxS =
			"\x1\xCD\x4D\xFFFF";
		private const string DFA23_acceptS =
			"\x1\xFFFF\x1\x2\x1\x1\x4B\xFFFF";
		private const string DFA23_specialS =
			"\x4E\xFFFF}>";
		private static readonly string[] DFA23_transitionS =
			{
				"\x1\x1\x1\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x5"+
				"\xFFFF\x2\x2\x2\xFFFF\x1\x2\x9\xFFFF\x1\x2\x6\xFFFF\x2\x2\x1\xFFFF\x3"+
				"\x2\x6\xFFFF\x1\x2\x4\xFFFF\x1\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x5\xFFFF"+
				"\x1\x2\x3\xFFFF\x1\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2"+
				"\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x1\x2\x4\xFFFF\x1\x2\x4\xFFFF\x1"+
				"\x2\x2\xFFFF\x2\x2\x3\xFFFF\x5\x2\x4\xFFFF\x2\x2\x1\xFFFF\x5\x2\x1\xFFFF"+
				"\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x4\x2\x5\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4"+
				"\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x4\x2\x3\xFFFF\x3\x2\x4\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x2\x2\x7\xFFFF"+
				"\x1\x2\x5\xFFFF\x2\x2",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA23_eot = DFA.UnpackEncodedString(DFA23_eotS);
		private static readonly short[] DFA23_eof = DFA.UnpackEncodedString(DFA23_eofS);
		private static readonly char[] DFA23_min = DFA.UnpackEncodedStringToUnsignedChars(DFA23_minS);
		private static readonly char[] DFA23_max = DFA.UnpackEncodedStringToUnsignedChars(DFA23_maxS);
		private static readonly short[] DFA23_accept = DFA.UnpackEncodedString(DFA23_acceptS);
		private static readonly short[] DFA23_special = DFA.UnpackEncodedString(DFA23_specialS);
		private static readonly short[][] DFA23_transition;

		static DFA23()
		{
			int numStates = DFA23_transitionS.Length;
			DFA23_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA23_transition[i] = DFA.UnpackEncodedString(DFA23_transitionS[i]);
			}
		}

		public DFA23( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 23;
			this.eot = DFA23_eot;
			this.eof = DFA23_eof;
			this.min = DFA23_min;
			this.max = DFA23_max;
			this.accept = DFA23_accept;
			this.special = DFA23_special;
			this.transition = DFA23_transition;
		}

		public override string Description { get { return "()+ loopback of 272:54: (x= expr )+"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA25 : DFA
	{
		private const string DFA25_eotS =
			"\x4D\xFFFF";
		private const string DFA25_eofS =
			"\x4D\xFFFF";
		private const string DFA25_minS =
			"\x1\x5\x4C\xFFFF";
		private const string DFA25_maxS =
			"\x1\xCD\x4C\xFFFF";
		private const string DFA25_acceptS =
			"\x1\xFFFF\x1\x1\x1C\xFFFF\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1"+
			"\x9\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12\x1\x13\x1"+
			"\x14\x1\x15\x1\x16\x1\x17\x1\x18\x1\x19\x1\x1A\x1\x1B\x1\x1C\x1\x1D\x1"+
			"\x1E\x1\x1F\x1\x20\x1\x21\x1\x22\x1\x23\x1\x24\x1\x25\x1\x26\x1\x27\x1"+
			"\x28\x1\x29\x1\x2A\x1\x2B\x1\x2C\x1\x2D\x1\x2E\x1\x2F\x1\x30";
		private const string DFA25_specialS =
			"\x4D\xFFFF}>";
		private static readonly string[] DFA25_transitionS =
			{
				"\x1\x3D\x1\x22\x1\xFFFF\x1\x2D\x1\x27\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF"+
				"\x1\x1E\x5\xFFFF\x2\x1\x2\xFFFF\x1\x1\x9\xFFFF\x1\x1\x6\xFFFF\x1\x46"+
				"\x1\x1\x1\xFFFF\x1\x42\x1\x40\x1\x20\x6\xFFFF\x1\x1\x4\xFFFF\x1\x30"+
				"\x5\xFFFF\x1\x1\x1\xFFFF\x1\x1\x5\xFFFF\x1\x1\x3\xFFFF\x1\x1\x1\xFFFF"+
				"\x1\x35\x1\x37\x2\xFFFF\x1\x1\x3\xFFFF\x1\x39\x1\x45\x2\xFFFF\x1\x38"+
				"\x2\xFFFF\x1\x49\x1\xFFFF\x1\x1\x4\xFFFF\x1\x2C\x4\xFFFF\x1\x2B\x2\xFFFF"+
				"\x1\x34\x1\x36\x3\xFFFF\x1\x41\x1\x21\x1\x1\x1\x3F\x1\x1F\x4\xFFFF\x1"+
				"\x48\x1\x31\x1\xFFFF\x1\x4A\x1\x33\x3\x1\x1\xFFFF\x1\x2E\x1\x29\x2\xFFFF"+
				"\x1\x1\x5\xFFFF\x1\x1\x1\x4C\x1\x4B\x1\x47\x5\xFFFF\x1\x2A\x2\xFFFF"+
				"\x1\x1\x4\xFFFF\x1\x1\x1\x32\x1\xFFFF\x1\x1\x1\x3A\x1\x24\x1\xFFFF\x1"+
				"\x3B\x1\x25\x1\x3C\x1\x26\x3\xFFFF\x1\x1\x1\x3E\x1\x23\x4\xFFFF\x1\x1"+
				"\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1\x1\x44"+
				"\x7\xFFFF\x1\x43\x5\xFFFF\x1\x2F\x1\x28",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA25_eot = DFA.UnpackEncodedString(DFA25_eotS);
		private static readonly short[] DFA25_eof = DFA.UnpackEncodedString(DFA25_eofS);
		private static readonly char[] DFA25_min = DFA.UnpackEncodedStringToUnsignedChars(DFA25_minS);
		private static readonly char[] DFA25_max = DFA.UnpackEncodedStringToUnsignedChars(DFA25_maxS);
		private static readonly short[] DFA25_accept = DFA.UnpackEncodedString(DFA25_acceptS);
		private static readonly short[] DFA25_special = DFA.UnpackEncodedString(DFA25_specialS);
		private static readonly short[][] DFA25_transition;

		static DFA25()
		{
			int numStates = DFA25_transitionS.Length;
			DFA25_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA25_transition[i] = DFA.UnpackEncodedString(DFA25_transitionS[i]);
			}
		}

		public DFA25( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 25;
			this.eot = DFA25_eot;
			this.eof = DFA25_eof;
			this.min = DFA25_min;
			this.max = DFA25_max;
			this.accept = DFA25_accept;
			this.special = DFA25_special;
			this.transition = DFA25_transition;
		}

		public override string Description { get { return "275:1: expr returns [JsExpression result] : (x= leftHandSideExpression | ^( ASSIGN a= expr b= expr ) | ^( MULASS a= expr b= expr ) | ^( DIVASS a= expr b= expr ) | ^( MODASS a= expr b= expr ) | ^( ADDASS a= expr b= expr ) | ^( SUBASS a= expr b= expr ) | ^( SHLASS a= expr b= expr ) | ^( SHRASS a= expr b= expr ) | ^( SHUASS a= expr b= expr ) | ^( ANDASS a= expr b= expr ) | ^( XORASS a= expr b= expr ) | ^( ORASS a= expr b= expr ) | ^( QUE a= expr b= expr c= expr ) | ^( LOR a= expr b= expr ) | ^( LAND a= expr b= expr ) | ^( AND a= expr b= expr ) | ^( OR a= expr b= expr ) | ^( XOR a= expr b= expr ) | ^( EQ a= expr b= expr ) | ^( NEQ a= expr b= expr ) | ^( SAME a= expr b= expr ) | ^( NSAME a= expr b= expr ) | ^( LT a= expr b= expr ) | ^( GT a= expr b= expr ) | ^( LTE a= expr b= expr ) | ^( GTE a= expr b= expr ) | ^( INSTANCEOF a= expr b= expr ) | ^( IN a= expr b= expr ) | ^( SHL a= expr b= expr ) | ^( SHR a= expr b= expr ) | ^( SHU a= expr b= expr ) | ^( ADD a= expr b= expr ) | ^( SUB a= expr b= expr ) | ^( MUL a= expr b= expr ) | ^( DIV a= expr b= expr ) | ^( MOD a= expr b= expr ) | ^( DELETE a= expr ) | ^( VOID a= expr ) | ^( TYPEOF a= expr ) | ^( INC a= expr ) | ^( DEC a= expr ) | ^( POS a= expr ) | ^( NEG a= expr ) | ^( INV a= expr ) | ^( NOT a= expr ) | ^( PINC a= expr ) | ^( PDEC a= expr ) );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA35 : DFA
	{
		private const string DFA35_eotS =
			"\x4E\xFFFF";
		private const string DFA35_eofS =
			"\x4E\xFFFF";
		private const string DFA35_minS =
			"\x1\x3\x4D\xFFFF";
		private const string DFA35_maxS =
			"\x1\xCD\x4D\xFFFF";
		private const string DFA35_acceptS =
			"\x1\xFFFF\x1\x2\x1\x1\x4B\xFFFF";
		private const string DFA35_specialS =
			"\x4E\xFFFF}>";
		private static readonly string[] DFA35_transitionS =
			{
				"\x1\x1\x1\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x5"+
				"\xFFFF\x2\x2\x2\xFFFF\x1\x2\x9\xFFFF\x1\x2\x6\xFFFF\x2\x2\x1\xFFFF\x3"+
				"\x2\x6\xFFFF\x1\x2\x4\xFFFF\x1\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x5\xFFFF"+
				"\x1\x2\x3\xFFFF\x1\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2"+
				"\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x1\x2\x4\xFFFF\x1\x2\x4\xFFFF\x1"+
				"\x2\x2\xFFFF\x2\x2\x3\xFFFF\x5\x2\x4\xFFFF\x2\x2\x1\xFFFF\x5\x2\x1\xFFFF"+
				"\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x4\x2\x5\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4"+
				"\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x4\x2\x3\xFFFF\x3\x2\x4\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x2\x2\x7\xFFFF"+
				"\x1\x2\x5\xFFFF\x2\x2",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA35_eot = DFA.UnpackEncodedString(DFA35_eotS);
		private static readonly short[] DFA35_eof = DFA.UnpackEncodedString(DFA35_eofS);
		private static readonly char[] DFA35_min = DFA.UnpackEncodedStringToUnsignedChars(DFA35_minS);
		private static readonly char[] DFA35_max = DFA.UnpackEncodedStringToUnsignedChars(DFA35_maxS);
		private static readonly short[] DFA35_accept = DFA.UnpackEncodedString(DFA35_acceptS);
		private static readonly short[] DFA35_special = DFA.UnpackEncodedString(DFA35_specialS);
		private static readonly short[][] DFA35_transition;

		static DFA35()
		{
			int numStates = DFA35_transitionS.Length;
			DFA35_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA35_transition[i] = DFA.UnpackEncodedString(DFA35_transitionS[i]);
			}
		}

		public DFA35( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 35;
			this.eot = DFA35_eot;
			this.eof = DFA35_eof;
			this.min = DFA35_min;
			this.max = DFA35_max;
			this.accept = DFA35_accept;
			this.special = DFA35_special;
			this.transition = DFA35_transition;
		}

		public override string Description { get { return "()* loopback of 367:54: (a= expr )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA36 : DFA
	{
		private const string DFA36_eotS =
			"\x4E\xFFFF";
		private const string DFA36_eofS =
			"\x4E\xFFFF";
		private const string DFA36_minS =
			"\x1\x3\x4D\xFFFF";
		private const string DFA36_maxS =
			"\x1\xCD\x4D\xFFFF";
		private const string DFA36_acceptS =
			"\x1\xFFFF\x1\x2\x1\x1\x4B\xFFFF";
		private const string DFA36_specialS =
			"\x4E\xFFFF}>";
		private static readonly string[] DFA36_transitionS =
			{
				"\x1\x1\x1\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x5"+
				"\xFFFF\x2\x2\x2\xFFFF\x1\x2\x9\xFFFF\x1\x2\x6\xFFFF\x2\x2\x1\xFFFF\x3"+
				"\x2\x6\xFFFF\x1\x2\x4\xFFFF\x1\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x5\xFFFF"+
				"\x1\x2\x3\xFFFF\x1\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2"+
				"\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x1\x2\x4\xFFFF\x1\x2\x4\xFFFF\x1"+
				"\x2\x2\xFFFF\x2\x2\x3\xFFFF\x5\x2\x4\xFFFF\x2\x2\x1\xFFFF\x5\x2\x1\xFFFF"+
				"\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x4\x2\x5\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4"+
				"\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x4\x2\x3\xFFFF\x3\x2\x4\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x2\x2\x7\xFFFF"+
				"\x1\x2\x5\xFFFF\x2\x2",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA36_eot = DFA.UnpackEncodedString(DFA36_eotS);
		private static readonly short[] DFA36_eof = DFA.UnpackEncodedString(DFA36_eofS);
		private static readonly char[] DFA36_min = DFA.UnpackEncodedStringToUnsignedChars(DFA36_minS);
		private static readonly char[] DFA36_max = DFA.UnpackEncodedStringToUnsignedChars(DFA36_maxS);
		private static readonly short[] DFA36_accept = DFA.UnpackEncodedString(DFA36_acceptS);
		private static readonly short[] DFA36_special = DFA.UnpackEncodedString(DFA36_specialS);
		private static readonly short[][] DFA36_transition;

		static DFA36()
		{
			int numStates = DFA36_transitionS.Length;
			DFA36_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA36_transition[i] = DFA.UnpackEncodedString(DFA36_transitionS[i]);
			}
		}

		public DFA36( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 36;
			this.eot = DFA36_eot;
			this.eof = DFA36_eof;
			this.min = DFA36_min;
			this.max = DFA36_max;
			this.accept = DFA36_accept;
			this.special = DFA36_special;
			this.transition = DFA36_transition;
		}

		public override string Description { get { return "()* loopback of 368:45: (a= expr )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA43 : DFA
	{
		private const string DFA43_eotS =
			"\x4E\xFFFF";
		private const string DFA43_eofS =
			"\x4E\xFFFF";
		private const string DFA43_minS =
			"\x1\x3\x4D\xFFFF";
		private const string DFA43_maxS =
			"\x1\xCD\x4D\xFFFF";
		private const string DFA43_acceptS =
			"\x1\xFFFF\x1\x1\x4B\xFFFF\x1\x2";
		private const string DFA43_specialS =
			"\x4E\xFFFF}>";
		private static readonly string[] DFA43_transitionS =
			{
				"\x1\x4D\x1\xFFFF\x2\x1\x1\xFFFF\x3\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1"+
				"\x5\xFFFF\x2\x1\x2\xFFFF\x1\x1\x9\xFFFF\x1\x1\x6\xFFFF\x2\x1\x1\xFFFF"+
				"\x3\x1\x6\xFFFF\x1\x1\x4\xFFFF\x1\x1\x5\xFFFF\x1\x1\x1\xFFFF\x1\x1\x5"+
				"\xFFFF\x1\x1\x3\xFFFF\x1\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1\x1\x3\xFFFF\x2"+
				"\x1\x2\xFFFF\x1\x1\x2\xFFFF\x1\x1\x1\xFFFF\x1\x1\x4\xFFFF\x1\x1\x4\xFFFF"+
				"\x1\x1\x2\xFFFF\x2\x1\x3\xFFFF\x5\x1\x4\xFFFF\x2\x1\x1\xFFFF\x5\x1\x1"+
				"\xFFFF\x2\x1\x2\xFFFF\x1\x1\x5\xFFFF\x4\x1\x5\xFFFF\x1\x1\x2\xFFFF\x1"+
				"\x1\x4\xFFFF\x2\x1\x1\xFFFF\x3\x1\x1\xFFFF\x4\x1\x3\xFFFF\x3\x1\x4\xFFFF"+
				"\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF\x2\x1\x7"+
				"\xFFFF\x1\x1\x5\xFFFF\x2\x1",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA43_eot = DFA.UnpackEncodedString(DFA43_eotS);
		private static readonly short[] DFA43_eof = DFA.UnpackEncodedString(DFA43_eofS);
		private static readonly char[] DFA43_min = DFA.UnpackEncodedStringToUnsignedChars(DFA43_minS);
		private static readonly char[] DFA43_max = DFA.UnpackEncodedStringToUnsignedChars(DFA43_maxS);
		private static readonly short[] DFA43_accept = DFA.UnpackEncodedString(DFA43_acceptS);
		private static readonly short[] DFA43_special = DFA.UnpackEncodedString(DFA43_specialS);
		private static readonly short[][] DFA43_transition;

		static DFA43()
		{
			int numStates = DFA43_transitionS.Length;
			DFA43_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA43_transition[i] = DFA.UnpackEncodedString(DFA43_transitionS[i]);
			}
		}

		public DFA43( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 43;
			this.eot = DFA43_eot;
			this.eof = DFA43_eof;
			this.min = DFA43_min;
			this.max = DFA43_max;
			this.accept = DFA43_accept;
			this.special = DFA43_special;
			this.transition = DFA43_transition;
		}

		public override string Description { get { return "406:38: (x= expr )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA64 : DFA
	{
		private const string DFA64_eotS =
			"\x52\xFFFF";
		private const string DFA64_eofS =
			"\x52\xFFFF";
		private const string DFA64_minS =
			"\x1\x3\x51\xFFFF";
		private const string DFA64_maxS =
			"\x1\xCD\x51\xFFFF";
		private const string DFA64_acceptS =
			"\x1\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4D\xFFFF";
		private const string DFA64_specialS =
			"\x52\xFFFF}>";
		private static readonly string[] DFA64_transitionS =
			{
				"\x1\x4\x1\xFFFF\x2\x4\x1\xFFFF\x3\x4\x1\xFFFF\x1\x4\x2\xFFFF\x1\x4\x5"+
				"\xFFFF\x2\x4\x2\xFFFF\x1\x4\x6\xFFFF\x1\x4\x2\xFFFF\x1\x4\x6\xFFFF\x2"+
				"\x4\x1\xFFFF\x3\x4\x6\xFFFF\x1\x4\x4\xFFFF\x1\x4\x5\xFFFF\x1\x4\x1\xFFFF"+
				"\x1\x4\x5\xFFFF\x1\x4\x3\xFFFF\x1\x4\x1\xFFFF\x2\x4\x2\xFFFF\x1\x4\x3"+
				"\xFFFF\x2\x4\x2\xFFFF\x1\x4\x2\xFFFF\x1\x4\x1\xFFFF\x1\x4\x4\xFFFF\x1"+
				"\x4\x4\xFFFF\x1\x4\x2\xFFFF\x2\x4\x3\xFFFF\x5\x4\x4\xFFFF\x2\x4\x1\xFFFF"+
				"\x5\x4\x1\xFFFF\x2\x4\x2\xFFFF\x1\x4\x5\xFFFF\x4\x4\x1\x1\x1\xFFFF\x1"+
				"\x1\x1\xFFFF\x1\x1\x1\x4\x2\xFFFF\x1\x4\x4\xFFFF\x2\x4\x1\xFFFF\x3\x4"+
				"\x1\xFFFF\x4\x4\x3\xFFFF\x3\x4\x4\xFFFF\x1\x4\x1\xFFFF\x1\x4\x1\xFFFF"+
				"\x1\x4\x1\xFFFF\x1\x4\x2\xFFFF\x2\x4\x7\xFFFF\x1\x4\x5\xFFFF\x2\x4",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA64_eot = DFA.UnpackEncodedString(DFA64_eotS);
		private static readonly short[] DFA64_eof = DFA.UnpackEncodedString(DFA64_eofS);
		private static readonly char[] DFA64_min = DFA.UnpackEncodedStringToUnsignedChars(DFA64_minS);
		private static readonly char[] DFA64_max = DFA.UnpackEncodedStringToUnsignedChars(DFA64_maxS);
		private static readonly short[] DFA64_accept = DFA.UnpackEncodedString(DFA64_acceptS);
		private static readonly short[] DFA64_special = DFA.UnpackEncodedString(DFA64_specialS);
		private static readonly short[][] DFA64_transition;

		static DFA64()
		{
			int numStates = DFA64_transitionS.Length;
			DFA64_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA64_transition[i] = DFA.UnpackEncodedString(DFA64_transitionS[i]);
			}
		}

		public DFA64( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 64;
			this.eot = DFA64_eot;
			this.eof = DFA64_eof;
			this.min = DFA64_min;
			this.max = DFA64_max;
			this.accept = DFA64_accept;
			this.special = DFA64_special;
			this.transition = DFA64_transition;
		}

		public override string Description { get { return "507:33: (modifier= accessibilityModifier )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA65 : DFA
	{
		private const string DFA65_eotS =
			"\x9E\xFFFF";
		private const string DFA65_eofS =
			"\x9E\xFFFF";
		private const string DFA65_minS =
			"\x1\x3\x1\x2\x9C\xFFFF";
		private const string DFA65_maxS =
			"\x2\xCD\x9C\xFFFF";
		private const string DFA65_acceptS =
			"\x2\xFFFF\x1\x2\x4D\xFFFF\x1\x1\x4D\xFFFF";
		private const string DFA65_specialS =
			"\x9E\xFFFF}>";
		private static readonly string[] DFA65_transitionS =
			{
				"\x1\x2\x1\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x5"+
				"\xFFFF\x2\x2\x2\xFFFF\x1\x2\x6\xFFFF\x1\x2\x2\xFFFF\x1\x2\x6\xFFFF\x2"+
				"\x2\x1\xFFFF\x3\x2\x6\xFFFF\x1\x2\x4\xFFFF\x1\x2\x5\xFFFF\x1\x2\x1\xFFFF"+
				"\x1\x2\x5\xFFFF\x1\x2\x3\xFFFF\x1\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x3"+
				"\xFFFF\x2\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x1\x2\x4\xFFFF\x1"+
				"\x2\x4\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF\x5\x2\x4\xFFFF\x2\x2\x1\xFFFF"+
				"\x5\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x4\x2\x5\xFFFF\x1\x1\x2"+
				"\xFFFF\x1\x2\x4\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x4\x2\x3\xFFFF\x3"+
				"\x2\x4\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF"+
				"\x2\x2\x7\xFFFF\x1\x2\x5\xFFFF\x2\x2",
				"\x1\x2\x1\x50\x1\xFFFF\x2\x50\x1\xFFFF\x3\x50\x1\xFFFF\x1\x50\x2\xFFFF"+
				"\x1\x50\x5\xFFFF\x2\x50\x2\xFFFF\x1\x50\x6\xFFFF\x1\x50\x2\xFFFF\x1"+
				"\x50\x6\xFFFF\x2\x50\x1\xFFFF\x3\x50\x6\xFFFF\x1\x50\x4\xFFFF\x1\x50"+
				"\x5\xFFFF\x1\x50\x1\xFFFF\x1\x50\x5\xFFFF\x1\x50\x3\xFFFF\x1\x50\x1"+
				"\xFFFF\x2\x50\x2\xFFFF\x1\x50\x3\xFFFF\x2\x50\x2\xFFFF\x1\x50\x2\xFFFF"+
				"\x1\x50\x1\xFFFF\x1\x50\x4\xFFFF\x1\x50\x4\xFFFF\x1\x50\x2\xFFFF\x2"+
				"\x50\x3\xFFFF\x5\x50\x4\xFFFF\x2\x50\x1\xFFFF\x5\x50\x1\xFFFF\x2\x50"+
				"\x2\xFFFF\x1\x50\x5\xFFFF\x4\x50\x5\xFFFF\x1\x50\x2\xFFFF\x1\x50\x4"+
				"\xFFFF\x2\x50\x1\xFFFF\x3\x50\x1\xFFFF\x4\x50\x3\xFFFF\x3\x50\x4\xFFFF"+
				"\x1\x50\x1\xFFFF\x1\x50\x1\xFFFF\x1\x50\x1\xFFFF\x1\x50\x2\xFFFF\x2"+
				"\x50\x7\xFFFF\x1\x50\x5\xFFFF\x2\x50",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA65_eot = DFA.UnpackEncodedString(DFA65_eotS);
		private static readonly short[] DFA65_eof = DFA.UnpackEncodedString(DFA65_eofS);
		private static readonly char[] DFA65_min = DFA.UnpackEncodedStringToUnsignedChars(DFA65_minS);
		private static readonly char[] DFA65_max = DFA.UnpackEncodedStringToUnsignedChars(DFA65_maxS);
		private static readonly short[] DFA65_accept = DFA.UnpackEncodedString(DFA65_acceptS);
		private static readonly short[] DFA65_special = DFA.UnpackEncodedString(DFA65_specialS);
		private static readonly short[][] DFA65_transition;

		static DFA65()
		{
			int numStates = DFA65_transitionS.Length;
			DFA65_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA65_transition[i] = DFA.UnpackEncodedString(DFA65_transitionS[i]);
			}
		}

		public DFA65( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 65;
			this.eot = DFA65_eot;
			this.eof = DFA65_eof;
			this.min = DFA65_min;
			this.max = DFA65_max;
			this.accept = DFA65_accept;
			this.special = DFA65_special;
			this.transition = DFA65_transition;
		}

		public override string Description { get { return "507:84: ( QUE )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA66 : DFA
	{
		private const string DFA66_eotS =
			"\x4F\xFFFF";
		private const string DFA66_eofS =
			"\x4F\xFFFF";
		private const string DFA66_minS =
			"\x1\x3\x4E\xFFFF";
		private const string DFA66_maxS =
			"\x1\xCD\x4E\xFFFF";
		private const string DFA66_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x4C\xFFFF";
		private const string DFA66_specialS =
			"\x4F\xFFFF}>";
		private static readonly string[] DFA66_transitionS =
			{
				"\x1\x2\x1\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x5"+
				"\xFFFF\x2\x2\x2\xFFFF\x1\x2\x6\xFFFF\x1\x1\x2\xFFFF\x1\x2\x6\xFFFF\x2"+
				"\x2\x1\xFFFF\x3\x2\x6\xFFFF\x1\x2\x4\xFFFF\x1\x2\x5\xFFFF\x1\x2\x1\xFFFF"+
				"\x1\x2\x5\xFFFF\x1\x2\x3\xFFFF\x1\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x3"+
				"\xFFFF\x2\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x1\x2\x4\xFFFF\x1"+
				"\x2\x4\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF\x5\x2\x4\xFFFF\x2\x2\x1\xFFFF"+
				"\x5\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x4\x2\x5\xFFFF\x1\x2\x2"+
				"\xFFFF\x1\x2\x4\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x4\x2\x3\xFFFF\x3"+
				"\x2\x4\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF"+
				"\x2\x2\x7\xFFFF\x1\x2\x5\xFFFF\x2\x2",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA66_eot = DFA.UnpackEncodedString(DFA66_eotS);
		private static readonly short[] DFA66_eof = DFA.UnpackEncodedString(DFA66_eofS);
		private static readonly char[] DFA66_min = DFA.UnpackEncodedStringToUnsignedChars(DFA66_minS);
		private static readonly char[] DFA66_max = DFA.UnpackEncodedStringToUnsignedChars(DFA66_maxS);
		private static readonly short[] DFA66_accept = DFA.UnpackEncodedString(DFA66_acceptS);
		private static readonly short[] DFA66_special = DFA.UnpackEncodedString(DFA66_specialS);
		private static readonly short[][] DFA66_transition;

		static DFA66()
		{
			int numStates = DFA66_transitionS.Length;
			DFA66_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA66_transition[i] = DFA.UnpackEncodedString(DFA66_transitionS[i]);
			}
		}

		public DFA66( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 66;
			this.eot = DFA66_eot;
			this.eof = DFA66_eof;
			this.min = DFA66_min;
			this.max = DFA66_max;
			this.accept = DFA66_accept;
			this.special = DFA66_special;
			this.transition = DFA66_transition;
		}

		public override string Description { get { return "507:110: (a= typeAnnotation )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA67 : DFA
	{
		private const string DFA67_eotS =
			"\x4E\xFFFF";
		private const string DFA67_eofS =
			"\x4E\xFFFF";
		private const string DFA67_minS =
			"\x1\x3\x4D\xFFFF";
		private const string DFA67_maxS =
			"\x1\xCD\x4D\xFFFF";
		private const string DFA67_acceptS =
			"\x1\xFFFF\x1\x1\x4B\xFFFF\x1\x2";
		private const string DFA67_specialS =
			"\x4E\xFFFF}>";
		private static readonly string[] DFA67_transitionS =
			{
				"\x1\x4D\x1\xFFFF\x2\x1\x1\xFFFF\x3\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1"+
				"\x5\xFFFF\x2\x1\x2\xFFFF\x1\x1\x9\xFFFF\x1\x1\x6\xFFFF\x2\x1\x1\xFFFF"+
				"\x3\x1\x6\xFFFF\x1\x1\x4\xFFFF\x1\x1\x5\xFFFF\x1\x1\x1\xFFFF\x1\x1\x5"+
				"\xFFFF\x1\x1\x3\xFFFF\x1\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1\x1\x3\xFFFF\x2"+
				"\x1\x2\xFFFF\x1\x1\x2\xFFFF\x1\x1\x1\xFFFF\x1\x1\x4\xFFFF\x1\x1\x4\xFFFF"+
				"\x1\x1\x2\xFFFF\x2\x1\x3\xFFFF\x5\x1\x4\xFFFF\x2\x1\x1\xFFFF\x5\x1\x1"+
				"\xFFFF\x2\x1\x2\xFFFF\x1\x1\x5\xFFFF\x4\x1\x5\xFFFF\x1\x1\x2\xFFFF\x1"+
				"\x1\x4\xFFFF\x2\x1\x1\xFFFF\x3\x1\x1\xFFFF\x4\x1\x3\xFFFF\x3\x1\x4\xFFFF"+
				"\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF\x2\x1\x7"+
				"\xFFFF\x1\x1\x5\xFFFF\x2\x1",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA67_eot = DFA.UnpackEncodedString(DFA67_eotS);
		private static readonly short[] DFA67_eof = DFA.UnpackEncodedString(DFA67_eofS);
		private static readonly char[] DFA67_min = DFA.UnpackEncodedStringToUnsignedChars(DFA67_minS);
		private static readonly char[] DFA67_max = DFA.UnpackEncodedStringToUnsignedChars(DFA67_maxS);
		private static readonly short[] DFA67_accept = DFA.UnpackEncodedString(DFA67_acceptS);
		private static readonly short[] DFA67_special = DFA.UnpackEncodedString(DFA67_specialS);
		private static readonly short[][] DFA67_transition;

		static DFA67()
		{
			int numStates = DFA67_transitionS.Length;
			DFA67_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA67_transition[i] = DFA.UnpackEncodedString(DFA67_transitionS[i]);
			}
		}

		public DFA67( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 67;
			this.eot = DFA67_eot;
			this.eof = DFA67_eof;
			this.min = DFA67_min;
			this.max = DFA67_max;
			this.accept = DFA67_accept;
			this.special = DFA67_special;
			this.transition = DFA67_transition;
		}

		public override string Description { get { return "507:131: (x= expr )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA114 : DFA
	{
		private const string DFA114_eotS =
			"\x67\xFFFF";
		private const string DFA114_eofS =
			"\x67\xFFFF";
		private const string DFA114_minS =
			"\x1\x3\x66\xFFFF";
		private const string DFA114_maxS =
			"\x1\xCE\x66\xFFFF";
		private const string DFA114_acceptS =
			"\x1\xFFFF\x1\x2\x1\x1\x64\xFFFF";
		private const string DFA114_specialS =
			"\x67\xFFFF}>";
		private static readonly string[] DFA114_transitionS =
			{
				"\x1\x1\x1\xFFFF\x6\x2\x1\xFFFF\x1\x2\x2\xFFFF\x3\x2\x1\xFFFF\x1\x2\x1"+
				"\xFFFF\x2\x2\x2\xFFFF\x1\x2\x3\xFFFF\x1\x2\x1\xFFFF\x1\x2\x3\xFFFF\x1"+
				"\x2\x3\xFFFF\x1\x2\x2\xFFFF\x2\x2\x1\xFFFF\x4\x2\x5\xFFFF\x1\x2\x4\xFFFF"+
				"\x2\x2\x4\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x2\x2\x2"+
				"\xFFFF\x4\x2\x2\xFFFF\x2\x2\x1\xFFFF\x3\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2"+
				"\x2\x1\xFFFF\x1\x2\x3\xFFFF\x2\x2\x4\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF"+
				"\x5\x2\x4\xFFFF\x2\x2\x1\xFFFF\x5\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x5"+
				"\xFFFF\x4\x2\x5\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF\x6\x2\x1\xFFFF\x4"+
				"\x2\x3\xFFFF\x3\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x3\x2\x1\xFFFF"+
				"\x2\x2\x1\xFFFF\x2\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x2\x2\x1"+
				"\xFFFF\x3\x2",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA114_eot = DFA.UnpackEncodedString(DFA114_eotS);
		private static readonly short[] DFA114_eof = DFA.UnpackEncodedString(DFA114_eofS);
		private static readonly char[] DFA114_min = DFA.UnpackEncodedStringToUnsignedChars(DFA114_minS);
		private static readonly char[] DFA114_max = DFA.UnpackEncodedStringToUnsignedChars(DFA114_maxS);
		private static readonly short[] DFA114_accept = DFA.UnpackEncodedString(DFA114_acceptS);
		private static readonly short[] DFA114_special = DFA.UnpackEncodedString(DFA114_specialS);
		private static readonly short[][] DFA114_transition;

		static DFA114()
		{
			int numStates = DFA114_transitionS.Length;
			DFA114_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA114_transition[i] = DFA.UnpackEncodedString(DFA114_transitionS[i]);
			}
		}

		public DFA114( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 114;
			this.eot = DFA114_eot;
			this.eof = DFA114_eof;
			this.min = DFA114_min;
			this.max = DFA114_max;
			this.accept = DFA114_accept;
			this.special = DFA114_special;
			this.transition = DFA114_transition;
		}

		public override string Description { get { return "()* loopback of 638:34: (e= sourceElement )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA115 : DFA
	{
		private const string DFA115_eotS =
			"\x67\xFFFF";
		private const string DFA115_eofS =
			"\x67\xFFFF";
		private const string DFA115_minS =
			"\x1\x3\x66\xFFFF";
		private const string DFA115_maxS =
			"\x1\xCE\x66\xFFFF";
		private const string DFA115_acceptS =
			"\x1\xFFFF\x1\x2\x1\x1\x64\xFFFF";
		private const string DFA115_specialS =
			"\x67\xFFFF}>";
		private static readonly string[] DFA115_transitionS =
			{
				"\x1\x1\x1\xFFFF\x6\x2\x1\xFFFF\x1\x2\x2\xFFFF\x3\x2\x1\xFFFF\x1\x2\x1"+
				"\xFFFF\x2\x2\x2\xFFFF\x1\x2\x3\xFFFF\x1\x2\x1\xFFFF\x1\x2\x3\xFFFF\x1"+
				"\x2\x3\xFFFF\x1\x2\x2\xFFFF\x2\x2\x1\xFFFF\x4\x2\x5\xFFFF\x1\x2\x4\xFFFF"+
				"\x2\x2\x4\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x2\x2\x2"+
				"\xFFFF\x4\x2\x2\xFFFF\x2\x2\x1\xFFFF\x3\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2"+
				"\x2\x1\xFFFF\x1\x2\x3\xFFFF\x2\x2\x4\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF"+
				"\x5\x2\x4\xFFFF\x2\x2\x1\xFFFF\x5\x2\x1\xFFFF\x2\x2\x2\xFFFF\x1\x2\x5"+
				"\xFFFF\x4\x2\x5\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF\x6\x2\x1\xFFFF\x4"+
				"\x2\x3\xFFFF\x3\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x3\x2\x1\xFFFF"+
				"\x2\x2\x1\xFFFF\x2\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x2\x2\x1"+
				"\xFFFF\x3\x2",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA115_eot = DFA.UnpackEncodedString(DFA115_eotS);
		private static readonly short[] DFA115_eof = DFA.UnpackEncodedString(DFA115_eofS);
		private static readonly char[] DFA115_min = DFA.UnpackEncodedStringToUnsignedChars(DFA115_minS);
		private static readonly char[] DFA115_max = DFA.UnpackEncodedStringToUnsignedChars(DFA115_maxS);
		private static readonly short[] DFA115_accept = DFA.UnpackEncodedString(DFA115_acceptS);
		private static readonly short[] DFA115_special = DFA.UnpackEncodedString(DFA115_specialS);
		private static readonly short[][] DFA115_transition;

		static DFA115()
		{
			int numStates = DFA115_transitionS.Length;
			DFA115_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA115_transition[i] = DFA.UnpackEncodedString(DFA115_transitionS[i]);
			}
		}

		public DFA115( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 115;
			this.eot = DFA115_eot;
			this.eof = DFA115_eof;
			this.min = DFA115_min;
			this.max = DFA115_max;
			this.accept = DFA115_accept;
			this.special = DFA115_special;
			this.transition = DFA115_transition;
		}

		public override string Description { get { return "()* loopback of 644:31: (e= sourceElement )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _sourceElement_in_program76 = new BitSet(new ulong[]{0x1841EC88A26B97E2UL,0xD87C643169D9E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _statementElement_in_sourceElement106 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interfaceElement_in_sourceElement120 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classElement_in_sourceElement134 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _moduleElement_in_sourceElement148 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _namespaceElement_in_sourceElement162 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _exportDeclaration_in_sourceElement176 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ambientDeclaration_in_sourceElement190 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ambientFunctionDeclaration_in_sourceElement204 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _importDeclaration_in_sourceElement218 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_statementElement253 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_statement282 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDeclaration_in_statement289 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_statement296 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifStatement_in_statement305 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _doStatement_in_statement312 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whileStatement_in_statement319 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forStatement_in_statement326 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _continueStatement_in_statement333 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _breakStatement_in_statement340 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _returnStatement_in_statement347 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _withStatement_in_statement354 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _labelledStatement_in_statement361 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _switchStatement_in_statement368 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _throwStatement_in_statement375 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tryStatement_in_statement382 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionDeclaration_in_statement389 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _gotoStatement_in_statement396 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _yieldStatement_in_statement403 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _awaitStatement_in_statement410 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMIC_in_statement415 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BLOCK_in_block444 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_block449 = new BitSet(new ulong[]{0x841EC88226B9768UL,0xD87C64314999E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _VAR_in_variableDeclaration480 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_variableDeclaration486 = new BitSet(new ulong[]{0x80900008408UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _typeAnnotation_in_variableDeclaration490 = new BitSet(new ulong[]{0x80800008408UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _ASSIGN_in_variableDeclaration494 = new BitSet(new ulong[]{0x840EC0822609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expression_in_variableDeclaration498 = new BitSet(new ulong[]{0x80800000408UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _IF_in_ifStatement529 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_ifStatement533 = new BitSet(new ulong[]{0x841EC88226B9760UL,0xD87C64314999E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _statement_in_ifStatement537 = new BitSet(new ulong[]{0x841EC88226B9768UL,0xD87C64314999E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _statement_in_ifStatement541 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DO_in_doStatement563 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_doStatement567 = new BitSet(new ulong[]{0x840EC0822609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expression_in_doStatement571 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _WHILE_in_whileStatement592 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_whileStatement596 = new BitSet(new ulong[]{0x841EC88226B9760UL,0xD87C64314999E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _statement_in_whileStatement600 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FOR_in_forStatement622 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _FORSTEP_in_forStatement636 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _exprOptClause_in_forStatement644 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _variableDeclaration_in_forStatement652 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _exprOptClause_in_forStatement660 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _exprOptClause_in_forStatement664 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _statement_in_forStatement670 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FORITER_in_forStatement684 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _EXPR_in_forStatement692 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_forStatement696 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _VAR_in_forStatement704 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_forStatement708 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _exprClause_in_forStatement718 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _statement_in_forStatement724 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_exprOptClause749 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_exprOptClause753 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_exprClause775 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_exprClause779 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CONTINUE_in_continueStatement800 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_continueStatement804 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BREAK_in_breakStatement826 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_breakStatement830 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RETURN_in_returnStatement852 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_returnStatement857 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _WITH_in_withStatement879 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_withStatement883 = new BitSet(new ulong[]{0x841EC88226B9760UL,0xD87C64314999E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _statement_in_withStatement887 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LABELLED_in_labelledStatement908 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_labelledStatement912 = new BitSet(new ulong[]{0x841EC88226B9760UL,0xD87C64314999E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _statement_in_labelledStatement916 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SWITCH_in_switchStatement942 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_switchStatement948 = new BitSet(new ulong[]{0x100008000008UL});
		public static readonly BitSet _defaultClause_in_switchStatement964 = new BitSet(new ulong[]{0x100008000008UL});
		public static readonly BitSet _caseClause_in_switchStatement976 = new BitSet(new ulong[]{0x100008000008UL});
		public static readonly BitSet _DEFAULT_in_defaultClause1019 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_defaultClause1024 = new BitSet(new ulong[]{0x841EC88226B9768UL,0xD87C64314999E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _CASE_in_caseClause1052 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_caseClause1056 = new BitSet(new ulong[]{0x841EC88226B9768UL,0xD87C64314999E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _statement_in_caseClause1061 = new BitSet(new ulong[]{0x841EC88226B9768UL,0xD87C64314999E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _THROW_in_throwStatement1086 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_throwStatement1090 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TRY_in_tryStatement1111 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_tryStatement1115 = new BitSet(new ulong[]{0x10000008UL,0x10UL});
		public static readonly BitSet _catchClause_in_tryStatement1119 = new BitSet(new ulong[]{0x8UL,0x10UL});
		public static readonly BitSet _finallyClause_in_tryStatement1124 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CATCH_in_catchClause1147 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_catchClause1151 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _block_in_catchClause1155 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FINALLY_in_finallyClause1177 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_finallyClause1181 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _GOTO_in_gotoStatement1202 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_gotoStatement1206 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _YIELD_in_yieldStatement1227 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_yieldStatement1231 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _AWAIT_in_awaitStatement1253 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_awaitStatement1257 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_awaitStatement1261 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _expr_in_expression1284 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CEXPR_in_expression1293 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expression1300 = new BitSet(new ulong[]{0x840EC0802609768UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _leftHandSideExpression_in_expr1324 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASSIGN_in_expr1337 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1341 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1345 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MULASS_in_expr1356 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1360 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1364 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DIVASS_in_expr1375 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1379 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1383 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MODASS_in_expr1394 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1398 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1402 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ADDASS_in_expr1413 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1417 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1421 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SUBASS_in_expr1432 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1436 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1440 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SHLASS_in_expr1451 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1455 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1459 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SHRASS_in_expr1470 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1474 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1478 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SHUASS_in_expr1489 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1493 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1497 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ANDASS_in_expr1508 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1512 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1516 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _XORASS_in_expr1527 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1531 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1535 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ORASS_in_expr1546 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1551 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1555 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _QUE_in_expr1570 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1574 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1578 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1582 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LOR_in_expr1598 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1609 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1613 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LAND_in_expr1624 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1634 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1638 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _AND_in_expr1653 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1664 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1668 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _OR_in_expr1679 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1691 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1695 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _XOR_in_expr1706 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1717 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1721 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EQ_in_expr1736 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1748 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1752 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NEQ_in_expr1763 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1774 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1778 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SAME_in_expr1789 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1799 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1803 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NSAME_in_expr1814 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1823 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1827 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LT_in_expr1842 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1854 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1858 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _GT_in_expr1869 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1881 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1885 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LTE_in_expr1896 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1907 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1911 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _GTE_in_expr1922 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1933 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1937 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _INSTANCEOF_in_expr1948 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1952 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1956 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IN_in_expr1967 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1979 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr1983 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SHL_in_expr1998 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2009 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr2013 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SHR_in_expr2024 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2035 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr2039 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SHU_in_expr2050 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2061 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr2065 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ADD_in_expr2080 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2091 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr2095 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SUB_in_expr2106 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2117 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr2121 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MUL_in_expr2136 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2147 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr2151 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DIV_in_expr2162 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2173 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr2177 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MOD_in_expr2188 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2199 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_expr2203 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DELETE_in_expr2218 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2222 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _VOID_in_expr2233 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2239 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPEOF_in_expr2250 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2254 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _INC_in_expr2265 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2272 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DEC_in_expr2283 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2290 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POS_in_expr2301 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2308 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NEG_in_expr2319 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2326 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _INV_in_expr2337 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2344 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NOT_in_expr2355 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2362 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PINC_in_expr2377 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2383 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PDEC_in_expr2394 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr2400 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _primaryExpression_in_leftHandSideExpression2421 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionExpression_in_leftHandSideExpression2431 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _callExpression_in_leftHandSideExpression2440 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _memberExpression_in_leftHandSideExpression2453 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_functionExpression2479 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_functionExpression2483 = new BitSet(new ulong[]{0x80000100020000UL,0x0UL,0x800UL,0x2UL});
		public static readonly BitSet _typeParameters_in_functionExpression2491 = new BitSet(new ulong[]{0x80000100020000UL,0x0UL,0x800UL});
		public static readonly BitSet _parameterList_in_functionExpression2500 = new BitSet(new ulong[]{0x100020000UL});
		public static readonly BitSet _typeAnnotation_in_functionExpression2509 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _block_in_functionExpression2516 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FUNCTIONDECLARATION_in_functionDeclaration2543 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_functionDeclaration2547 = new BitSet(new ulong[]{0x80000100020008UL,0x0UL,0x800UL,0x2UL});
		public static readonly BitSet _typeParameters_in_functionDeclaration2554 = new BitSet(new ulong[]{0x80000100020008UL,0x0UL,0x800UL});
		public static readonly BitSet _parameterList_in_functionDeclaration2563 = new BitSet(new ulong[]{0x100020008UL});
		public static readonly BitSet _typeAnnotation_in_functionDeclaration2572 = new BitSet(new ulong[]{0x20008UL});
		public static readonly BitSet _block_in_functionDeclaration2579 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CALL_in_callExpression2607 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _NEW_in_callExpression2611 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _leftHandSideExpression_in_callExpression2615 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ARGS_in_callExpression2621 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_callExpression2626 = new BitSet(new ulong[]{0x840EC0802609768UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _CALL_in_callExpression2643 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _leftHandSideExpression_in_callExpression2647 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _ARGS_in_callExpression2651 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_callExpression2656 = new BitSet(new ulong[]{0x840EC0802609768UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _BYINDEX_in_memberExpression2684 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _leftHandSideExpression_in_memberExpression2688 = new BitSet(new ulong[]{0x840EC0822609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expression_in_memberExpression2692 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BYFIELD_in_memberExpression2703 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _leftHandSideExpression_in_memberExpression2707 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_memberExpression2711 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _identifier_in_primaryExpression2732 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _literal_in_primaryExpression2741 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PAREXPR_in_primaryExpression2749 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_primaryExpression2753 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _THIS_in_literal2771 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULL_in_literal2778 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booleanLiteral_in_literal2787 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numericLiteral_in_literal2796 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_literal2803 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RegularExpressionLiteral_in_literal2810 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arrayLiteral_in_literal2819 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _objectLiteral_in_literal2828 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_booleanLiteral2845 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_booleanLiteral2853 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DecimalLiteral_in_numericLiteral2870 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OctalIntegerLiteral_in_numericLiteral2882 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _HexIntegerLiteral_in_numericLiteral2889 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ARRAY_in_arrayLiteral2915 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ITEM_in_arrayLiteral2921 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_arrayLiteral2927 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _OBJECT_in_objectLiteral2961 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _NAMEDVALUE_in_objectLiteral2967 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _propertyName_in_objectLiteral2971 = new BitSet(new ulong[]{0x840EC0802609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_objectLiteral2975 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _identifier_in_propertyName3003 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_propertyName3016 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numericLiteral_in_propertyName3028 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeReference_in_type3055 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _primitiveType_in_type3070 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _objectType_in_type3085 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _constructorType_in_type3100 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _functionType_in_type3115 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _tupleType_in_type3130 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _ARRAY_TYPE_in_type3140 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _TYPEREF_in_typeReference3167 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_typeReference3171 = new BitSet(new ulong[]{0x8UL,0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _typeArguments_in_typeReference3175 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_ARGS_in_typeArguments3211 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _type_in_typeArguments3216 = new BitSet(new ulong[]{0x4000040408UL,0x1000UL,0x900020000000000AUL,0x40UL});
		public static readonly BitSet _ANY_in_primitiveType3250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUMBER_in_primitiveType3262 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BOOLEAN_in_primitiveType3274 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_primitiveType3286 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VOID_in_primitiveType3298 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OBJECT_TYPE_in_objectType3332 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeMember_in_objectType3337 = new BitSet(new ulong[]{0x2004000008UL,0x2000004000000UL,0x80000UL});
		public static readonly BitSet _propertySignature_in_typeMember3374 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _callSignature_in_typeMember3389 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _indexSignature_in_typeMember3403 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodSignature_in_typeMember3417 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constructSignature_in_typeMember3431 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PROP_SIG_in_propertySignature3475 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _propertyName_in_propertySignature3479 = new BitSet(new ulong[]{0x100000008UL,0x0UL,0x800000UL});
		public static readonly BitSet _QUE_in_propertySignature3482 = new BitSet(new ulong[]{0x100000008UL});
		public static readonly BitSet _typeAnnotation_in_propertySignature3490 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _COLON_in_typeAnnotation3514 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _type_in_typeAnnotation3518 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CALL_SIG_in_callSignature3544 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeParameters_in_callSignature3551 = new BitSet(new ulong[]{0x80000100000008UL,0x0UL,0x800UL});
		public static readonly BitSet _parameterList_in_callSignature3560 = new BitSet(new ulong[]{0x100000008UL});
		public static readonly BitSet _typeAnnotation_in_callSignature3569 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_PARAMS_in_typeParameters3603 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeParameter_in_typeParameters3609 = new BitSet(new ulong[]{0x80800000408UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_typeParameter3647 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeConstraint_in_typeParameter3655 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXTENDS_in_typeConstraint3686 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _type_in_typeConstraint3691 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PARAMS_in_parameterList3731 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _parameter_in_parameterList3736 = new BitSet(new ulong[]{0x80000000000008UL,0x0UL,0x400UL});
		public static readonly BitSet _restParameter_in_parameterList3745 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _restParameter_in_parameterList3761 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PARAM_in_parameter3802 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_parameter3807 = new BitSet(new ulong[]{0x840EC0902609768UL,0xD87C64214989A20AUL,0x6550E3DD84D7C137UL,0x3040UL});
		public static readonly BitSet _accessibilityModifier_in_parameter3815 = new BitSet(new ulong[]{0x840EC0902609768UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _QUE_in_parameter3821 = new BitSet(new ulong[]{0x840EC0902609768UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _typeAnnotation_in_parameter3830 = new BitSet(new ulong[]{0x840EC0802609768UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expr_in_parameter3838 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PUBLIC_in_accessibilityModifier3869 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PRIVATE_in_accessibilityModifier3881 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PROTECTED_in_accessibilityModifier3893 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELLIPSIS_in_restParameter3918 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_restParameter3923 = new BitSet(new ulong[]{0x100000008UL});
		public static readonly BitSet _typeAnnotation_in_restParameter3929 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _INDEX_SIG_in_indexSignature3968 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_indexSignature3973 = new BitSet(new ulong[]{0x0UL,0x0UL,0x200000000002UL});
		public static readonly BitSet _STRING_in_indexSignature3978 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _NUMBER_in_indexSignature3986 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _typeAnnotation_in_indexSignature3994 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _METH_SIG_in_methodSignature4032 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _propertyName_in_methodSignature4036 = new BitSet(new ulong[]{0x80000100000008UL,0x0UL,0x800800UL,0x2UL});
		public static readonly BitSet _QUE_in_methodSignature4039 = new BitSet(new ulong[]{0x80000100000008UL,0x0UL,0x800UL,0x2UL});
		public static readonly BitSet _typeParameters_in_methodSignature4050 = new BitSet(new ulong[]{0x80000100000008UL,0x0UL,0x800UL});
		public static readonly BitSet _parameterList_in_methodSignature4059 = new BitSet(new ulong[]{0x100000008UL});
		public static readonly BitSet _typeAnnotation_in_methodSignature4068 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _AMBIENTFUNCTION_in_ambientFunctionDeclaration4107 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_ambientFunctionDeclaration4111 = new BitSet(new ulong[]{0x80000100000008UL,0x0UL,0x800800UL,0x2UL});
		public static readonly BitSet _QUE_in_ambientFunctionDeclaration4114 = new BitSet(new ulong[]{0x80000100000008UL,0x0UL,0x800UL,0x2UL});
		public static readonly BitSet _typeParameters_in_ambientFunctionDeclaration4125 = new BitSet(new ulong[]{0x80000100000008UL,0x0UL,0x800UL});
		public static readonly BitSet _parameterList_in_ambientFunctionDeclaration4134 = new BitSet(new ulong[]{0x100000008UL});
		public static readonly BitSet _typeAnnotation_in_ambientFunctionDeclaration4143 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CONST_SIG_in_constructSignature4173 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeParameters_in_constructSignature4180 = new BitSet(new ulong[]{0x80000100000008UL,0x0UL,0x800UL});
		public static readonly BitSet _parameterList_in_constructSignature4189 = new BitSet(new ulong[]{0x100000008UL});
		public static readonly BitSet _typeAnnotation_in_constructSignature4198 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FUNC_TYPE_in_functionType4229 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeParameters_in_functionType4236 = new BitSet(new ulong[]{0x80004000040408UL,0x1000UL,0x900020000000080AUL,0x40UL});
		public static readonly BitSet _parameterList_in_functionType4245 = new BitSet(new ulong[]{0x4000040408UL,0x1000UL,0x900020000000000AUL,0x40UL});
		public static readonly BitSet _type_in_functionType4254 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CONST_TYPE_in_constructorType4285 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeParameters_in_constructorType4292 = new BitSet(new ulong[]{0x80004000040408UL,0x1000UL,0x900020000000080AUL,0x40UL});
		public static readonly BitSet _parameterList_in_constructorType4301 = new BitSet(new ulong[]{0x4000040408UL,0x1000UL,0x900020000000000AUL,0x40UL});
		public static readonly BitSet _type_in_constructorType4310 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TUPLE_TYPE_in_tupleType4350 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _type_in_tupleType4357 = new BitSet(new ulong[]{0x4000040408UL,0x1000UL,0x900020000000000AUL,0x40UL});
		public static readonly BitSet _INTERFACE_in_interfaceElement4399 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_interfaceElement4403 = new BitSet(new ulong[]{0x4000002004000008UL,0x2000004000000UL,0x80000UL,0x2UL});
		public static readonly BitSet _typeParameters_in_interfaceElement4407 = new BitSet(new ulong[]{0x4000002004000008UL,0x2000004000000UL,0x80000UL});
		public static readonly BitSet _extendsClause_in_interfaceElement4412 = new BitSet(new ulong[]{0x2004000008UL,0x2000004000000UL,0x80000UL});
		public static readonly BitSet _typeMember_in_interfaceElement4418 = new BitSet(new ulong[]{0x2004000008UL,0x2000004000000UL,0x80000UL});
		public static readonly BitSet _EXTENDS_in_extendsClause4460 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeReference_in_extendsClause4467 = new BitSet(new ulong[]{0x8UL,0x0UL,0x8000000000000000UL});
		public static readonly BitSet _IMPLEMENTS_in_implementsClause4508 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeReference_in_implementsClause4515 = new BitSet(new ulong[]{0x8UL,0x0UL,0x8000000000000000UL});
		public static readonly BitSet _CLASS_in_classElement4556 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_classElement4561 = new BitSet(new ulong[]{0x4000001000000008UL,0x1000004202000UL,0x400000000UL,0x12UL});
		public static readonly BitSet _typeParameters_in_classElement4567 = new BitSet(new ulong[]{0x4000001000000008UL,0x1000004202000UL,0x400000000UL,0x10UL});
		public static readonly BitSet _extendsClause_in_classElement4574 = new BitSet(new ulong[]{0x1000000008UL,0x1000004202000UL,0x400000000UL,0x10UL});
		public static readonly BitSet _implementsClause_in_classElement4581 = new BitSet(new ulong[]{0x1000000008UL,0x1000004002000UL,0x400000000UL,0x10UL});
		public static readonly BitSet _classMember_in_classElement4589 = new BitSet(new ulong[]{0x1000000008UL,0x1000004002000UL,0x400000000UL,0x10UL});
		public static readonly BitSet _constructorDeclaration_in_classMember4628 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodDeclaration_in_classMember4643 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classIndexSignature_in_classMember4658 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _getAccessor_in_classMember4673 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _setAccessor_in_classMember4688 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _memberVariableDeclaration_in_classMember4703 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONST_DECL_in_constructorDeclaration4742 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _constructorCallSignature_in_constructorDeclaration4749 = new BitSet(new ulong[]{0x2000020000UL});
		public static readonly BitSet _block_in_constructorDeclaration4760 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CONST_SIG_in_constructorCallSignature4799 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _accessibilityModifier_in_constructorCallSignature4804 = new BitSet(new ulong[]{0x80000000000008UL,0x0UL,0x800UL});
		public static readonly BitSet _parameterList_in_constructorCallSignature4815 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _METH_DECL_in_methodDeclaration4855 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _methodCallSignature_in_methodDeclaration4862 = new BitSet(new ulong[]{0x20000UL,0x2000000000000UL});
		public static readonly BitSet _block_in_methodDeclaration4873 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _METH_SIG_in_methodCallSignature4912 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _accessibilityModifier_in_methodCallSignature4917 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100300404000002UL});
		public static readonly BitSet _STATIC_in_methodCallSignature4924 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_methodCallSignature4933 = new BitSet(new ulong[]{0x80000100000008UL,0x0UL,0x800UL,0x2UL});
		public static readonly BitSet _typeParameters_in_methodCallSignature4941 = new BitSet(new ulong[]{0x80000100000008UL,0x0UL,0x800UL});
		public static readonly BitSet _parameterList_in_methodCallSignature4950 = new BitSet(new ulong[]{0x100000008UL});
		public static readonly BitSet _typeAnnotation_in_methodCallSignature4959 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _indexSignature_in_classIndexSignature4995 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GET_in_getAccessor5034 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _accessibilityModifier_in_getAccessor5039 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100300404000002UL});
		public static readonly BitSet _STATIC_in_getAccessor5046 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_getAccessor5055 = new BitSet(new ulong[]{0x100020000UL});
		public static readonly BitSet _typeAnnotation_in_getAccessor5063 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _block_in_getAccessor5072 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SET_in_setAccessor5111 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _accessibilityModifier_in_setAccessor5116 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100300404000002UL});
		public static readonly BitSet _STATIC_in_setAccessor5123 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_setAccessor5132 = new BitSet(new ulong[]{0x0UL,0x0UL,0x400UL});
		public static readonly BitSet _parameter_in_setAccessor5140 = new BitSet(new ulong[]{0x100020000UL});
		public static readonly BitSet _typeAnnotation_in_setAccessor5148 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _block_in_setAccessor5157 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MODULE_in_moduleElement5196 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _StringLiteral_in_moduleElement5201 = new BitSet(new ulong[]{0x1841EC88A26B97E8UL,0xD87C643169D9E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _sourceElement_in_moduleElement5209 = new BitSet(new ulong[]{0x1841EC88A26B97E8UL,0xD87C643169D9E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _MODULE_in_namespaceElement5251 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_namespaceElement5256 = new BitSet(new ulong[]{0x1841EC88A26B97E8UL,0xD87C643169D9E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _sourceElement_in_namespaceElement5264 = new BitSet(new ulong[]{0x1841EC88A26B97E8UL,0xD87C643169D9E64AUL,0x6DD2E3DF8C83C137UL,0x7650UL});
		public static readonly BitSet _EXPORT_in_exportDeclaration5297 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _sourceElement_in_exportDeclaration5305 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DECLARE_in_ambientDeclaration5335 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _sourceElement_in_ambientDeclaration5343 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ANY_in_identifier5376 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONSTRUCTOR_in_identifier5387 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DECLARE_in_identifier5398 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GET_in_identifier5409 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SET_in_identifier5420 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MODULE_in_identifier5431 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REQUIRE_in_identifier5442 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUMBER_in_identifier5453 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_identifier5464 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPE_in_identifier5475 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FINAL_in_identifier5486 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _THROWS_in_identifier5497 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_identifier5508 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IMPORT_in_importDeclaration5537 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_importDeclaration5543 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000000000UL});
		public static readonly BitSet _StringLiteral_in_importDeclaration5549 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _VAR_in_memberVariableDeclaration5588 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _accessibilityModifier_in_memberVariableDeclaration5593 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100300404000002UL});
		public static readonly BitSet _STATIC_in_memberVariableDeclaration5600 = new BitSet(new ulong[]{0x80800000400UL,0x10000100002008UL,0x2100200404000002UL});
		public static readonly BitSet _identifier_in_memberVariableDeclaration5608 = new BitSet(new ulong[]{0x100008008UL});
		public static readonly BitSet _typeAnnotation_in_memberVariableDeclaration5612 = new BitSet(new ulong[]{0x8008UL});
		public static readonly BitSet _ASSIGN_in_memberVariableDeclaration5616 = new BitSet(new ulong[]{0x840EC0822609760UL,0xD87C64214989A20AUL,0x6550E3DD8483C137UL,0x3040UL});
		public static readonly BitSet _expression_in_memberVariableDeclaration5620 = new BitSet(new ulong[]{0x8UL});
	}
	#endregion Follow sets
}

} // namespace  TypeScriptParser.TypeScriptParserImpl 
